<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Poetry&#39;s Blog</title>
  
  <subtitle>Choose a gesture to allow yourself to live irreplaceable.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.poetries.top/"/>
  <updated>2019-01-07T08:48:58.284Z</updated>
  <id>http://blog.poetries.top/</id>
  
  <author>
    <name>Poetry</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初识Electron</title>
    <link href="http://blog.poetries.top/2019/01/06/electron-summary/"/>
    <id>http://blog.poetries.top/2019/01/06/electron-summary/</id>
    <published>2019-01-06T09:40:43.000Z</published>
    <updated>2019-01-07T08:48:58.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><ul><li><code>NW.js</code> 和 <code>Electron</code> 都可以用前端的知识来开发桌面应用。<code>NW.js</code> 和 <code>Electron</code>起初是同一 个作者开发。后来种种原因分为两个产品。一个命名为 <code>NW.js</code>(英特尔公司提供技术支持)、 另一命名为 <code>Electron</code>(Github 公司提供技术支持)。</li><li><code>NW.js</code> 和 <code>Electron</code> 可以用 <code>Nodejs</code> 中几乎所有的模块。<code>NW.js</code> 和 <code>Electron</code>不仅可以把 <code>html</code> 写的 <code>web</code> 页面打包成跨平台可以安装到电脑上面的软件，也可以通过 <code>javascript</code> 访问操作 系统原生的 <code>UI</code> 和 <code>Api</code>(控制窗口、添加菜单项目、托盘应用菜单、读写文件、访问剪贴板)。</li></ul><blockquote><p> <code>github</code> 的 <code>atom</code> 编辑器、微软的 <code>vscode</code> 编辑器，包括阿里内部的一些 软件也是用 <code>electron</code> 开发的</p></blockquote><p><strong>1. Electron 是由谁开发的?</strong></p><blockquote><p><code>Electron</code> 是由 <code>Github</code> 开发</p></blockquote><p><strong>2.  Electron 是什么?</strong></p><blockquote><p><code>Electron</code> 是一个用 <code>HTML</code>，<code>CSS</code> 和 <code>JavaScript</code> 来构建跨平台桌面应用程序的一个开源库</p></blockquote><p><strong>3. Electron 把 HTML，CSS 和 JavaScript 组合的程序构建为跨平台桌面应用程序的原理 是什么?</strong></p><blockquote><p>原理为 <code>Electron</code> 通过将 <code>Chromium</code> 和 <code>Node.js</code> 合并到同一个运行时环境中，并将其打包为 <code>Mac</code>，<code>Windows</code> 和 <code>Linux</code> 系统下的应用来实现这一目的。</p></blockquote><p><strong>4. Electron 何时出现的，为什么会出现?</strong></p><blockquote><p><code>Electron</code> 于 <code>2013</code> 年作为构建 <code>Atom</code> 的框架而被开发出来。这两个项目在 <code>2014</code> 春季开源。 (Atom:为 Github 上可编程的文本编辑器)</p></blockquote><p><strong>一些历史:</strong></p><ul><li><code>2013</code> 年 <code>4</code> 月 <code>Atom Shell</code> 项目启动 。</li><li><code>2014</code> 年 <code>5</code> 月 <code>Atom Shell</code> 被开源 。</li><li><code>2015</code> 年 <code>4</code> 月 <code>Atom Shell</code> 被重命名为 <code>Electron</code> </li><li><code>2016</code> 年 <code>5</code> 月 <code>Electron</code> 发布了 <code>v1.0.0</code> 版本 </li></ul><p><strong>5. Electron 当前流行程度?</strong></p><blockquote><p>目前 <code>Electron</code> 已成为开源开发者、初创企业和老牌公司常用的开发工具。</p></blockquote><p><strong>6. Electron 当前由那些人在维护支持?</strong></p><blockquote><p><code>Electron</code> 当前由 <code>Github</code> 上的一支团队和一群活跃的贡献者维护。有些贡献者是独立开发者，有些则在用 <code>Electron</code> 构建应用的大型公司里工作。</p></blockquote><p><strong>7. Electron 新版本多久发布一次?</strong></p><blockquote><p><code>Electron</code> 的版本发布相当频繁。每当 <code>Chromium</code>、<code>Node.js</code> 有重要的 <code>bug</code> 修复，新 <code>API</code> 或是版本更新时 <code>Electron</code> 会发布新版本。</p></blockquote><ul><li>一般 <code>Chromium</code> 发行新的稳定版后的一到两周之内，<code>Electron</code> 中 <code>Chromium</code> 的版本会对其进行更新，具体时间根据升级所需的工作量而定。<br>一般 <code>Node.js</code> 发行新的稳定版一个月后，<code>Electron</code> 中 <code>Node.js</code> 的版本会对其进行更新，具 体时间根据升级所需的工作量而定。</li></ul><p><strong>8. Electron 的核心理念是什么?</strong></p><blockquote><p><code>Electron</code> 的核心理念是:保持 <code>Electron</code> 的体积小和可持续性开发。<br>如:为了保持 <code>Electron</code> 的小巧 (文件体积) 和可持续性开发 (以防依赖库和 <code>API</code> 的泛滥) ， <code>Electron</code> 限制了所使用的核心项目的数量。<br>比如 <code>Electron</code> 只用了 <code>Chromium</code> 的渲染库而不是其全部组件。这使得升级 <code>Chromium</code> 更加容易，但也意味着 <code>Electron</code> 缺少了 <code>Google Chrome</code> 里的一些浏览器相关的特性。 添加到 <code>Electron</code> 的新功能应该主要是原生 <code>API</code>。 如果可以的话，一个功能应该尽可能的成 为一个 <code>Node.js</code> 模块。</p></blockquote><p><strong>9. Electron 当前的最新版本为多少?</strong></p><blockquote><p><code>Electron</code> 当前的最新版本为 <code>4.0.1</code> (当前时间为 <code>2019</code> 年 <code>1</code> 月 <code>6</code> 号)</p></blockquote><h1 id="二、环境搭建"><a href="#二、环境搭建" class="headerlink" title="二、环境搭建"></a>二、环境搭建</h1><p><strong>1. 安装 electron</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g electron</span><br></pre></td></tr></table></figure><p><strong>2. 克隆一个仓库、快速启动一个项目</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆示例项目的仓库</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/electron/electron-quick-start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入这个仓库</span></span><br><span class="line"><span class="built_in">cd</span> electron-quick-start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖并运行</span></span><br><span class="line">npm install &amp;&amp; npm start</span><br></pre></td></tr></table></figure><p><strong>3. 手动搭建一个 electron 项目</strong></p><ol><li>新建一个项目目录 例如: <code>electrondemo01</code></li><li>在 <code>electrondemo01</code> 目录下面新建三个文件: <code>index.html</code>、<code>main.js</code> 、<code>package.json</code></li><li><code>index.html</code> 里面用 <code>css</code> 进行布局(以前怎么写现在还是怎么写)</li><li>在 <code>main.js</code> 中写如下代码</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> electron =<span class="built_in">require</span>(<span class="string">'electron'</span>); <span class="comment">//electron 对象的引用</span></span><br><span class="line"><span class="keyword">const</span> app=electron.app; <span class="comment">//BrowserWindow 类的引用</span></span><br><span class="line"><span class="keyword">const</span> BrowserWindow=electron.BrowserWindow;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mainWindow=<span class="literal">null</span>; <span class="comment">//监听应用准备完成的事件 app.on('ready',function()&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//监听应用准备完成的事件</span></span><br><span class="line">app.on(<span class="string">'ready'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//创建窗口</span></span><br><span class="line">    mainWindow=<span class="keyword">new</span> BrowserWindow(&#123;<span class="attr">width</span>: <span class="number">800</span>, <span class="attr">height</span>: <span class="number">600</span>&#125;); mainWindow.loadFile(<span class="string">'index.html'</span>);</span><br><span class="line">    </span><br><span class="line">    mainWindow.on(<span class="string">'closed'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        mainWindow = <span class="literal">null</span>; &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听所有窗口关闭的事件 </span></span><br><span class="line">app.on(<span class="string">'window-all-closed'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// On OS X it is common for applications and their menu bar // to stay active until the user quits explicitly with Cmd + Q </span></span><br><span class="line">    <span class="keyword">if</span> (process.platform !== <span class="string">'darwin'</span>) &#123;</span><br><span class="line">        app.quit(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="5"><li>运行</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">electron . <span class="comment">#注意:命令后面有个点</span></span><br></pre></td></tr></table></figure><p><strong>4. electron-forge 搭建一个 electron 项目</strong></p><blockquote><p><code>electron-forge</code> 相当于 <code>electron</code> 的一个脚手架，可以让我们更方便的创建、运行、打包 <code>electron</code> 项目</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm install -g electron-forge </span><br><span class="line"></span><br><span class="line">electron-forge init my-new-app </span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> my-new-app</span><br><span class="line"></span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><h1 id="三、Electron-运行流程"><a href="#三、Electron-运行流程" class="headerlink" title="三、Electron 运行流程"></a>三、Electron 运行流程</h1><h2 id="3-1-Electron-运行的流程"><a href="#3-1-Electron-运行的流程" class="headerlink" title="3.1 Electron 运行的流程"></a>3.1 Electron 运行的流程</h2><p><img src="https://upload-images.jianshu.io/upload_images/1480597-7d07da8dccab3159.png" alt="image.png"></p><h2 id="3-2-Electron-主进程和渲染进程"><a href="#3-2-Electron-主进程和渲染进程" class="headerlink" title="3.2 Electron 主进程和渲染进程"></a>3.2 Electron 主进程和渲染进程</h2><ul><li><code>Electron</code> 运行 <code>package.json</code> 的 <code>main</code> 脚本的进程被称为主进程。 </li><li>在主进程中运行的脚本通过创建 <code>web</code> 页面来展示用户界面。 一个 <code>Electron</code> 应用总是有且只有一个主进程。</li><li>由于 <code>Electron</code> 使用了 <code>Chromium</code>(谷歌浏览器)来展示 <code>web</code> 页面，所以 <code>Chromium</code> 的 多进程架构也被使用到。 每个 <code>Electron</code> 中的 <code>web</code> 页面运行在它自己的渲染进程中。</li><li>主进程使用 <code>BrowserWindow</code> 实例创建页面。每个 <code>BrowserWindow</code> 实例都在自己的渲 染进程里运行页面。 当一个 <code>BrowserWindow</code>实例被销毁后，相应的渲染进程也会被终止</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1480597-ed01221126a5fe76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/1480597-d84ba41d44a3e672.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>进程:进程是计算机中的程序关于某数据集合上的一次运行活动，是 系统进行资源分配和调度的基本单位，是操作系统结构的基础。</li><li>线程:在一个程序里的一个执行路线就叫做线程(<code>thread</code>)。更准确的定义是: 线程是“一个进程内部的控制序列”。</li><li>线程和进程:一个程序至少有一个进程,一个进程至少有一个线程</li></ul><h2 id="3-3-Electron-渲染进程中通过-Nodejs-读取本地文件"><a href="#3-3-Electron-渲染进程中通过-Nodejs-读取本地文件" class="headerlink" title="3.3 Electron 渲染进程中通过 Nodejs 读取本地文件"></a>3.3 Electron 渲染进程中通过 Nodejs 读取本地文件</h2><blockquote><p>在普通的浏览器中，<code>web</code>页面通常在一个沙盒环境中运行，不被允许去接触原生的资源。 然而 <code>Electron</code> 的用户在 <code>Node.js</code> 的 <code>API</code>支持下可以在页面中和操作系统进行一些底层交 互。<br><code>Nodejs</code> 在主进程和渲染进程中都可以使用。渲染进程因为安全限制，不能直接操作生 <code>GUI</code>。虽然如此，因为集成了 Nodejs，渲染进程也有了操作系统底层 <code>API</code>的能力，<code>Nodejs</code> 中常用的 <code>Path</code>、<code>fs</code>、<code>Crypto</code> 等模块在 <code>Electron</code> 可以直接使用，方便我们处理链接、路径、 文件 <code>MD5</code> 等，同时 <code>npm</code> 还有成千上万的模块供我们选择。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> content = <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>); </span><br><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>);</span><br><span class="line"></span><br><span class="line">button.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'package.json'</span>,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123; </span><br><span class="line">        content.textContent = data;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-4-Electron-开启调试模式"><a href="#3-4-Electron-开启调试模式" class="headerlink" title="3.4 Electron 开启调试模式"></a>3.4 Electron 开启调试模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mainWindow.webContents.openDevTools();</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1480597-62c31b57f8b94838.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="四、Electron-模块介绍"><a href="#四、Electron-模块介绍" class="headerlink" title="四、Electron 模块介绍"></a>四、Electron 模块介绍</h1><blockquote><p><code>Electron</code> 模块介绍、<code>remote</code> 模块、通 过 <code>BrowserWindow</code> 打开新窗口</p></blockquote><h2 id="4-1-Electron-主进程和渲染进程中的模块"><a href="#4-1-Electron-主进程和渲染进程中的模块" class="headerlink" title="4.1 Electron 主进程和渲染进程中的模块"></a>4.1 Electron 主进程和渲染进程中的模块</h2><p><img src="https://upload-images.jianshu.io/upload_images/1480597-3c15bb39e7080862.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="4-2-Electron-remote-模块"><a href="#4-2-Electron-remote-模块" class="headerlink" title="4.2 Electron remote 模块"></a>4.2 Electron remote 模块</h2><blockquote><p><code>remote</code> 模块提供了一种在渲染进程(网页)和主进程之间进行进程间通讯(<code>IPC</code>)的简便途径</p></blockquote><blockquote><p><code>Electron</code> 中, 与 <code>GUI</code> 相关的模块(如 <code>dialog</code>, <code>menu</code> 等)只存在于主进程，而不在渲染进程中 。为了能从渲染进程中使用它们，需要用<code>ipc</code>模块来给主进程发送进程间消息。使用 <code>remote</code> 模块，可以调用主进程对象的方法，而无需显式地发送进程间消息，这类似于 <code>Java</code> 的 <code>RMI</code></p></blockquote><h2 id="4-3-通过BrowserWindow-打开新窗口"><a href="#4-3-通过BrowserWindow-打开新窗口" class="headerlink" title="4.3 通过BrowserWindow 打开新窗口"></a>4.3 通过BrowserWindow 打开新窗口</h2><blockquote><p><code>Electron</code> 渲染进程中通过 <code>remote</code> 模块调用主进程中的 <code>BrowserWindow</code> 打开新窗口</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主进程代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> electron = <span class="built_in">require</span>(<span class="string">'electron'</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制应用生命周期的模块 </span></span><br><span class="line"><span class="keyword">const</span> &#123;app&#125; = electron;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建本地浏览器窗口的模块 </span></span><br><span class="line"><span class="keyword">const</span> &#123;BrowserWindow&#125; = electron;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向窗口对象的一个全局引用，如果没有这个引用，那么当该 javascript 对象被垃圾回收 的</span></span><br><span class="line"><span class="comment">// 时候该窗口将会自动关闭</span></span><br><span class="line"><span class="keyword">let</span> win;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWindow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个新的浏览器窗口</span></span><br><span class="line">    win = <span class="keyword">new</span> BrowserWindow(&#123;<span class="attr">width</span>: <span class="number">1104</span>, <span class="attr">height</span>: <span class="number">620</span>&#125;);<span class="comment">//570+50</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 并且装载应用的 index.html 页面</span></span><br><span class="line">    win.loadURL(<span class="string">`file://<span class="subst">$&#123;__dirname&#125;</span>/html/index.html`</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开开发工具页面</span></span><br><span class="line">    win.webContents.openDevTools();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当窗口关闭时调用的方法</span></span><br><span class="line">    win.on(<span class="string">'closed'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 解除窗口对象的引用，通常而言如果应用支持多个窗口的话，你会在一个数组里 // 存放窗口对象，在窗口关闭的时候应当删除相应的元素。</span></span><br><span class="line">        win = <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 Electron 完成初始化并且已经创建了浏览器窗口，则该方法将会被调用。</span></span><br><span class="line"><span class="comment">// 有些 API 只能在该事件发生后才能被使用</span></span><br><span class="line">app.on(<span class="string">'ready'</span>, createWindow);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当所有的窗口被关闭后退出应用 </span></span><br><span class="line">app.on(<span class="string">'window-all-closed'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 对于 OS X 系统，应用和相应的菜单栏会一直激活直到用户通过 Cmd + Q 显式退出 </span></span><br><span class="line">    <span class="keyword">if</span> (process.platform !== <span class="string">'darwin'</span>) &#123;</span><br><span class="line">        app.quit(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.on(<span class="string">'activate'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 对于 OS X 系统，当 dock 图标被点击后会重新创建一个 app 窗口，并且不会有其他</span></span><br><span class="line">    <span class="comment">// 窗口打开</span></span><br><span class="line">    <span class="keyword">if</span> (win === <span class="literal">null</span>) &#123;</span><br><span class="line">        createWindow(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这个文件后面你可以直接包含你应用特定的由主进程运行的代码。 </span></span><br><span class="line"><span class="comment">// 也可以把这些代码放在另一个文件中然后在这里导入</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 渲染进程代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'#btn'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> BrowerWindow = <span class="built_in">require</span>(<span class="string">'electron'</span>).remote.BrowserWindow;</span><br><span class="line"></span><br><span class="line">btn.onclick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    win = <span class="keyword">new</span> BrowerWindow(&#123; </span><br><span class="line">        width: <span class="number">300</span>,</span><br><span class="line">        height: <span class="number">200</span>, </span><br><span class="line">        frame: <span class="literal">false</span>, </span><br><span class="line">        transparent: <span class="literal">true</span> <span class="comment">// fullscreen:true</span></span><br><span class="line">    &#125;) </span><br><span class="line"></span><br><span class="line">    win.loadURL(path.join(<span class="string">'file:'</span>,__dirname,<span class="string">'news.html'</span>));</span><br><span class="line"></span><br><span class="line">    win.on(<span class="string">'close'</span>,()=&gt;&#123;win = <span class="literal">null</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、自定义顶部菜单-右键菜单"><a href="#五、自定义顶部菜单-右键菜单" class="headerlink" title="五、自定义顶部菜单/右键菜单"></a>五、自定义顶部菜单/右键菜单</h1><h2 id="5-1-自定义软件顶部菜单"><a href="#5-1-自定义软件顶部菜单" class="headerlink" title="5.1 自定义软件顶部菜单"></a>5.1 自定义软件顶部菜单</h2><blockquote><p><code>Electron</code> 中 <code>Menu</code> 模块可以用来创建原生菜单，它可用作应用菜单和 <code>context</code> 菜单</p></blockquote><blockquote><p>这个模块是一个主进程的模块，并且可以通过 <code>remote</code> 模块给渲染进程调用</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Menu &#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> template = [</span><br><span class="line">&#123;</span><br><span class="line">    label: <span class="string">'文件'</span>,</span><br><span class="line">    submenu: [ </span><br><span class="line">        &#123;</span><br><span class="line">            label: <span class="string">'新建窗口'</span>, </span><br><span class="line">            click: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'aaa'</span>) </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">            type: <span class="string">'separator'</span> </span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            label: <span class="string">'打开文件'</span>,</span><br><span class="line">            accelerator:<span class="string">'ctrl+x'</span>, </span><br><span class="line">            click: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'bbb'</span>) </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    ] </span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    label :<span class="string">'编辑'</span>,</span><br><span class="line">    submenu: [ </span><br><span class="line">        &#123;</span><br><span class="line">            role:<span class="string">'cut'</span>, </span><br><span class="line">            label:<span class="string">'剪切'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            role:<span class="string">'copy'</span>, </span><br><span class="line">            label:<span class="string">'复制'</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m=Menu.buildFromTemplate(template); </span><br><span class="line"></span><br><span class="line">Menu.setApplicationMenu(m);</span><br></pre></td></tr></table></figure><h2 id="5-2-自定义右键菜单"><a href="#5-2-自定义右键菜单" class="headerlink" title="5.2 自定义右键菜单"></a>5.2 自定义右键菜单</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'contextmenu'</span>, (e) = &gt;&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    m.popup(&#123;</span><br><span class="line">        <span class="built_in">window</span>: remote.getCurrentWindow()</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h1 id="六、进程通信"><a href="#六、进程通信" class="headerlink" title="六、进程通信"></a>六、进程通信</h1><h2 id="6-1-主进程与渲染进程之间的通信"><a href="#6-1-主进程与渲染进程之间的通信" class="headerlink" title="6.1 主进程与渲染进程之间的通信"></a>6.1 主进程与渲染进程之间的通信</h2><blockquote><p>有时候我们想在渲染进程中通过一个事件去执行主进程里面的方法。或者在渲染进程中通知 主进程处理事件，主进程处理完成后广播一个事件让渲染进程去处理一些事情。这个时候就 用到了主进程和渲染进程之间的相互通信</p></blockquote><blockquote><p><code>Electron</code> 主进程，和渲染进程的通信主要用到两个模块:<code>ipcMain</code> 和 <code>ipcRenderer</code></p></blockquote><ul><li><code>ipcMain</code>:当在主进程中使用时，它处理从渲染器进程(网页)发送出来的异步和同步信息,当然也有可能从主进程向渲染进程发送消息。</li><li><code>ipcRenderer</code>: 使用它提供的一些方法从渲染进程 (<code>web</code> 页面) 发送同步或异步的消息到主进程。 也可以接收主进程回复的消息</li></ul><p><strong>场景 1:渲染进程给主进程发送异步消息</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//渲染进程</span></span><br><span class="line"><span class="keyword">const</span> &#123; ipcRenderer &#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line"></span><br><span class="line">ipcRenderer.send(<span class="string">'msg'</span>,&#123;<span class="attr">name</span>:<span class="string">'张三'</span>&#125;); <span class="comment">//异步</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主进程</span></span><br><span class="line"><span class="keyword">const</span> &#123; ipcMain &#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>);</span><br><span class="line"></span><br><span class="line">ipcMain.on(<span class="string">'msg'</span>,(event,arg) =&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>场景 2:渲染进程给主进程发送异步消息，主进程接收到异步消息以后通知渲染进程:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//渲染进程</span></span><br><span class="line"><span class="keyword">const</span> &#123; ipcRenderer &#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line"></span><br><span class="line">ipcRenderer.send(<span class="string">'msg'</span>,&#123;<span class="attr">name</span>:<span class="string">'张三'</span>&#125;); <span class="comment">//异步</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主进程</span></span><br><span class="line"><span class="keyword">const</span> &#123; ipcMain &#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>);</span><br><span class="line"></span><br><span class="line">ipcMain.on(<span class="string">'msg'</span>,(event,arg) =&gt; &#123; </span><br><span class="line">    event.sender.send(<span class="string">'reply'</span>, <span class="string">'pong'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//渲染进程</span></span><br><span class="line"><span class="keyword">const</span> &#123; ipcRenderer &#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line"></span><br><span class="line">ipcRenderer.on(<span class="string">'reply'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event, arg</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(arg); <span class="comment">// prints "pong"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>场景 3:渲染进程给主进程发送同步消息</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//渲染进程</span></span><br><span class="line"><span class="keyword">const</span> &#123; ipcRenderer &#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> msg = ipcRenderer.sendSync(<span class="string">'msg-a'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(msg)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主进程 </span></span><br><span class="line">ipcMain.on(<span class="string">'msg-a'</span>,(event)=&gt; &#123;</span><br><span class="line">    event.returnValue = <span class="string">'hello'</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>通过主进程渲染进程的通信改造右键菜单</strong></p><blockquote><p>@TODO</p></blockquote><h2 id="6-2-渲染进程与渲染进程之间的通信"><a href="#6-2-渲染进程与渲染进程之间的通信" class="headerlink" title="6.2 渲染进程与渲染进程之间的通信"></a>6.2 渲染进程与渲染进程之间的通信</h2><p><strong>1. Electron 渲染进程通过 localstorage 给另一个渲染进程传值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(key,value);</span><br><span class="line"></span><br><span class="line">localStorage.getItem(key);</span><br></pre></td></tr></table></figure><p><strong>2. 通过 BrowserWindow 和 webContents 模块实现渲染进 程和渲染进程的通信</strong></p><blockquote><p><code>webContents</code> 是一个事件发出者.它负责渲染并控制网页，也是 <code>BrowserWindow</code> 对象的属性</p></blockquote><p><strong>需要了解的几个知识点</strong></p><ol><li>获取当前窗口的 <code>id</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> winId = BrowserWindow.getFocusedWindow().id;</span><br></pre></td></tr></table></figure><ol start="2"><li>监听当前窗口加载完成的事件</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">win.webContents.on(<span class="string">'did-finish-load'</span>,(event) =&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="3"><li>同一窗口之间广播数据</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">win.webContents.on(<span class="string">'did-finish-load'</span>,(event) =&gt; &#123;</span><br><span class="line">    win.webContents.send(<span class="string">'msg'</span>,winId,<span class="string">'我是 index.html 的数据'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="4"><li>通过 <code>id</code> 查找窗口</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> win = BrowserWindow.fromId(winId);</span><br></pre></td></tr></table></figure><h1 id="七、Electron-Shell-模块"><a href="#七、Electron-Shell-模块" class="headerlink" title="七、Electron Shell 模块"></a>七、Electron Shell 模块</h1><blockquote><p><code>Electron Shell</code> 模块在用户默认浏览器 中打开 <code>URL</code> 以及 <code>Electron DOM webview</code> 标签</p></blockquote><blockquote><p><code>shell</code> 模块提供了集成其他桌面客户端的关联功能.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shell = <span class="built_in">require</span>(<span class="string">'shell'</span>);</span><br><span class="line"></span><br><span class="line">shell.openExternal(<span class="string">'https://github.com'</span>)</span><br></pre></td></tr></table></figure><p><strong>Electron DOM <webview> 标签</webview></strong></p><blockquote><p><code>Webview</code> 与 <code>iframe</code> 有点相似，但是与 <code>iframe</code> 不同, <code>webview</code> 和你的应用运行的是不同的进程。它不拥有渲染进程的权限，并且应用和嵌入内容之间的交互全部都是异步的。因为这能 保证应用的安全性不受嵌入内容的影响。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">webview</span> <span class="attr">id</span>=<span class="string">"webview"</span> <span class="attr">src</span>=<span class="string">"https://www.itying.com"</span> <span class="attr">style</span>=<span class="string">"position:fixed; width:100%; height:100%"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">webview</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="八、Electron-dialog-弹出框"><a href="#八、Electron-dialog-弹出框" class="headerlink" title="八、Electron dialog 弹出框"></a>八、Electron dialog 弹出框</h1><blockquote><p><code>dialog</code> 模块提供了 <code>api</code> 来展示原生的系统对话框，例如打开文件框，<code>alert</code> 框， 所以 <code>web</code> 应用可以给用户带来跟系统应用相同的体验</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-de7cfb527bf5ea19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dialog.showErrorBox(<span class="string">'title'</span>,<span class="string">'content'</span>);</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1480597-f94a34889a4b1f1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dialog.showMessageBox(&#123;</span><br><span class="line">    type: <span class="string">'info'</span>,</span><br><span class="line">    title: <span class="string">'message'</span>,</span><br><span class="line">    message: <span class="string">'hello'</span>,</span><br><span class="line">    buttons: [<span class="string">'ok'</span>, <span class="string">'cancel'</span>]</span><br><span class="line">&#125;,</span><br><span class="line">(index) = &gt;&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'You click ok.'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'You click cancel'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开目录  选择文件</span></span><br><span class="line"></span><br><span class="line">dialog.showOpenDialog(&#123;</span><br><span class="line">    properties: [<span class="string">'openFile'</span>, <span class="string">'openDirectory'</span>]</span><br><span class="line">&#125;,</span><br><span class="line">(files) = &gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(files);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dialog.showSaveDialog(&#123;</span><br><span class="line">    title: <span class="string">'save some file'</span>,</span><br><span class="line">    filters: [&#123;</span><br><span class="line">        name: <span class="string">'Images'</span>,</span><br><span class="line">        extensions: [<span class="string">'jpg'</span>, <span class="string">'png'</span>, <span class="string">'gif'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">'Movies'</span>,</span><br><span class="line">        extensions: [<span class="string">'mkv'</span>, <span class="string">'avi'</span>, <span class="string">'mp4'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">'Custom File Type'</span>,</span><br><span class="line">        extensions: [<span class="string">'as'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">'All Files'</span>,</span><br><span class="line">        extensions: [<span class="string">'*'</span>]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;,</span><br><span class="line">(filename) = &gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(filename);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1480597-281ce997d8a71eee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="九、系统托盘、托盘右键菜单、托盘图标闪烁"><a href="#九、系统托盘、托盘右键菜单、托盘图标闪烁" class="headerlink" title="九、系统托盘、托盘右键菜单、托盘图标闪烁"></a>九、系统托盘、托盘右键菜单、托盘图标闪烁</h1><blockquote><p>系统托盘 托盘右键菜单、托 盘图标闪烁 点击右上角关闭按钮隐 藏到托盘(仿杀毒软件)</p></blockquote><p><strong>1. Electron 系统托盘、任务通知栏图标介绍</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/1480597-d8cb64eb94d030a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>2. Electron 创建任务栏图标以及任务栏图标右键菜单</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;</span><br><span class="line">    Menu, Tray, app, BrowserWindow</span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> appIcon = <span class="keyword">new</span> Tray(path.join(__dirname, <span class="string">'lover.png'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> menu = Menu.buildFromTemplate([</span><br><span class="line">    &#123;</span><br><span class="line">        label: <span class="string">'设置'</span>,</span><br><span class="line">        click: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">//打开相应页面 </span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        label: <span class="string">'帮助'</span>,</span><br><span class="line">        click: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        label: <span class="string">'关于'</span>,</span><br><span class="line">        click: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        label: <span class="string">'退出'</span>,</span><br><span class="line">        click: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">            <span class="comment">// BrowserWindow.getFocusedWindow().webContents().send('close-main-window');</span></span><br><span class="line">            app.quit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;])</span><br><span class="line">appIcon.setToolTip(<span class="string">'my best app'</span>);</span><br><span class="line">appIcon.setContextMenu(menu);</span><br></pre></td></tr></table></figure><p><strong>3. 监听任务栏图标的单击、双击事件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;</span><br><span class="line">    Menu, Tray, app, BrowserWindow</span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> appIcon = <span class="keyword">new</span> Tray(path.join(__dirname, <span class="string">'lover.png'</span>));</span><br><span class="line"></span><br><span class="line">appIcon.on(<span class="string">'double-click'</span>, () = &gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(win);</span><br><span class="line">    win.show();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>4. Electron 点击右上角关闭按钮隐藏任务栏图标</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> win = BrowserWindow.getFocusedWindow();</span><br><span class="line"></span><br><span class="line">win.on(<span class="string">'close'</span>, (e) = &gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(win.isFocused());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!win.isFocused()) &#123;</span><br><span class="line">        win = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        e.preventDefault();<span class="comment">/*阻止应用退出*/</span></span><br><span class="line">        win.hide();<span class="comment">/*隐藏当前窗口*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>5. Electron 实现任务栏闪烁图标</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">timer = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        appIcon.setImage(path.join(__dirname, <span class="string">'empty.ico'</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        appIcon.setImage(path.join(__dirname, <span class="string">'lover.png'</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="number">500</span>);</span><br></pre></td></tr></table></figure><h1 id="十、消息通知、监听网络变-化、网络变化弹出通知框"><a href="#十、消息通知、监听网络变-化、网络变化弹出通知框" class="headerlink" title="十、消息通知、监听网络变 化、网络变化弹出通知框"></a>十、消息通知、监听网络变 化、网络变化弹出通知框</h1><p><strong>1. Electron 实现消息通知</strong></p><blockquote><p><code>Electron</code> 里面的消息通知是基于 <code>h5</code> 的通知 <code>api</code> 实现的</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-b09035ca49b73ba3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> option = &#123;</span><br><span class="line">    title: <span class="string">'title'</span>,</span><br><span class="line">    body: <span class="string">'body'</span>,</span><br><span class="line">    icon: path.join(<span class="string">'main-process/favicon2.ico'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> myNotification = <span class="keyword">new</span> <span class="built_in">window</span>.Notification(option.title, option);</span><br><span class="line"></span><br><span class="line">myNotification.onclick = () = &gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'clicked'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. Electron 监听网络变化</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'online'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;); <span class="built_in">window</span>.addEventListener(<span class="string">'offline'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);</span><br></pre></td></tr></table></figure><h1 id="十一、注册全局快捷键-剪切板事件-nativeImage-模块"><a href="#十一、注册全局快捷键-剪切板事件-nativeImage-模块" class="headerlink" title="十一、注册全局快捷键/剪切板事件/nativeImage 模块"></a>十一、注册全局快捷键/剪切板事件/nativeImage 模块</h1><blockquote><p><code>Electron</code> 注册全局快捷键 (<code>globalShortcut</code>) 以及 <code>clipboard</code> 剪 切板事件以及 <code>nativeImage</code> 模块(实现类似播放器点击机器码自动复制功 能)</p></blockquote><p> <strong>1. Electron 注册全局快捷键(globalShortcut)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'app'</span>);</span><br><span class="line"><span class="keyword">var</span> globalShortcut = <span class="built_in">require</span>(<span class="string">'electron'</span>).globalShortcut;</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">'ready'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Register a 'ctrl+x' shortcut listener.</span></span><br><span class="line">    <span class="keyword">var</span> ret = globalShortcut.register(<span class="string">'ctrl+x'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'ctrl+x is pressed'</span>);</span><br><span class="line">    &#125;) </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'registration failed'</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// Check whether a shortcut is registered.</span></span><br><span class="line">    <span class="built_in">console</span>.log(globalShortcut.isRegistered(<span class="string">'ctrl+x'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">'will-quit'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Unregister a shortcut.</span></span><br><span class="line">    globalShortcut.unregister(<span class="string">'ctrl+x'</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Unregister all shortcuts.</span></span><br><span class="line">    globalShortcut.unregisterAll();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>2. clipboard 剪切板事件 clipboard 模块以及 nativeImage 模块</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    clipboard,</span><br><span class="line">    nativeImage</span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>);</span><br><span class="line"></span><br><span class="line">clipboard.writeText(<span class="string">"这是一个test"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(clipboard.readText());</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> img = nativeImage.createFromPath(<span class="string">'static/favicon2.ico'</span>);</span><br><span class="line"></span><br><span class="line">clipboard.writeImage(img);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> imgDataURL = clipboard.readImage().toDataURL();</span><br><span class="line"><span class="keyword">const</span> img3 = <span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line">img3.src = imgDataURL;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(img3);</span><br></pre></td></tr></table></figure><h1 id="十二、结合electron-vue"><a href="#十二、结合electron-vue" class="headerlink" title="十二、结合electron-vue"></a>十二、结合electron-vue</h1><h2 id="12-1-electron-vue-的使用"><a href="#12-1-electron-vue-的使用" class="headerlink" title="12.1 electron-vue 的使用"></a>12.1 electron-vue 的使用</h2><p><strong>1. electron-vue 的一些资源</strong></p><blockquote><p><a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">https://github.com/SimulatedGREG/electron-vue</a></p></blockquote><p><code>Electron-vue</code> 文档 <a href="https://simulatedgreg.gitbooks.io/electron-vue/content/cn" target="_blank" rel="noopener">https://simulatedgreg.gitbooks.io/electron-vue/content/cn</a></p><p><strong>2. electron-vue 环境搭建、创建项目</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">npm install -g vue-cli</span><br><span class="line"></span><br><span class="line">vue init simulatedgreg/electron-vue my-project</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> my-project</span><br><span class="line"></span><br><span class="line">yarn <span class="comment"># or npm install</span></span><br><span class="line"></span><br><span class="line">yarn run dev <span class="comment"># or npm run dev</span></span><br></pre></td></tr></table></figure><p><strong>3. electron-vue 目录结构分析</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/1480597-3137d0001e34cf1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="12-2-electron-vue-中使用-sass-ElementUi"><a href="#12-2-electron-vue-中使用-sass-ElementUi" class="headerlink" title="12.2 electron-vue 中使用 sass/ElementUi"></a>12.2 electron-vue 中使用 sass/ElementUi</h2><p><strong>1. electron-vue UI 框架 ElementUi 的使用</strong></p><blockquote><p><a href="http://element-cn.eleme.io/#/zh-CN" target="_blank" rel="noopener">http://element-cn.eleme.io/#/zh-CN</a></p></blockquote><p><strong>2. electron-vue 中使用 sass</strong></p><ul><li><a href="https://simulatedgreg.gitbooks.io/electron-vue/content/cn/using_pre-processors.html" target="_blank" rel="noopener">electron-vue 中使用 sass</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 sass-loader:</span></span><br><span class="line"></span><br><span class="line">npm install --save-dev sass-loader node-sass</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--vue 文件中修改 style 为如下代码:--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"scss"</span>&gt;</span><span class="undefined"> </span></span><br><span class="line"><span class="undefined">    body &#123;</span></span><br><span class="line"><span class="css">        <span class="comment">/* SCSS */</span> </span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="12-3-electron-vue-中隐藏顶部菜单隐藏"><a href="#12-3-electron-vue-中隐藏顶部菜单隐藏" class="headerlink" title="12.3 electron-vue 中隐藏顶部菜单隐藏"></a>12.3 electron-vue 中隐藏顶部菜单隐藏</h2><blockquote><p>electron-vue 中隐藏顶部菜单隐藏顶部最大化、最小化、关闭按钮 自定最大化、最小化 、关闭按钮</p></blockquote><p><strong>1. electron-vue 中隐藏顶部菜单</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mainWindow.setMenu(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p><strong>2. electron-vue 中隐藏关闭 最大化 最小化按钮</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mainWindow = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">    height: <span class="number">620</span>,</span><br><span class="line">    useContentSize: <span class="literal">true</span>,</span><br><span class="line">    width: <span class="number">1280</span> frame: <span class="literal">false</span> <span class="comment">/*去掉顶部导航 去掉关闭按钮 最大化最小化按钮*/</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>3 .electron-vue 自定义关闭/最大化最小化按钮</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ipc.on(<span class="string">'window-min'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    mainWindow.minimize();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//登录窗口最大化 </span></span><br><span class="line">ipc.on(<span class="string">'window-max'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mainWindow.isMaximized()) &#123;</span><br><span class="line">        mainWindow.restore();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mainWindow.maximize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line">ipc.on(<span class="string">'window-close'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    mainWindow.close();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>4. electron-vue 自定义导航可拖拽</strong></p><ul><li>可拖拽的 <code>css</code>: <code>-webkit-app-region: drag;</code></li><li>不可拖拽的 <code>css</code>:  <code>-webkit-app-region: no-drag;</code></li></ul><h1 id="十三、更多参考"><a href="#十三、更多参考" class="headerlink" title="十三、更多参考"></a>十三、更多参考</h1><ul><li><a href="https://github.com/poetries/electron-wiki" target="_blank" rel="noopener">electron常用工具</a></li><li><a href="https://wizardforcel.gitbooks.io/electron-doc/content/faq/electron-faq.html" target="_blank" rel="noopener">electron中文文档</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NW.js&lt;/code&gt; 和 &lt;code&gt;Electron&lt;/code&gt; 都可以用前端的知识来开发桌
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="Node" scheme="http://blog.poetries.top/tags/Node/"/>
    
      <category term="Electron" scheme="http://blog.poetries.top/tags/Electron/"/>
    
  </entry>
  
  <entry>
    <title>浏览器缓存原理总结</title>
    <link href="http://blog.poetries.top/2019/01/02/browser-cache/"/>
    <id>http://blog.poetries.top/2019/01/02/browser-cache/</id>
    <published>2019-01-02T06:20:43.000Z</published>
    <updated>2019-01-07T08:48:58.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、浏览器缓存基本认识"><a href="#一、浏览器缓存基本认识" class="headerlink" title="一、浏览器缓存基本认识"></a>一、浏览器缓存基本认识</h1><p><strong>分为强缓存和协商缓存</strong></p><ol><li>浏览器在加载资源时，先根据这个资源的一些<code>http header</code>判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个<code>css</code>文件，如果浏览器在加载它所在的网页时，这个<code>css</code>文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个<code>css</code>，连请求都不会发送到网页所在服务器</li><li>当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些<code>http header</code>验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源</li><li><strong>强缓存与协商缓存的共同点是</strong>：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：<strong>强缓存不发请求到服务器</strong>，协商缓存会发请求到服务器</li><li>当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据</li></ol><h1 id="二、强缓存的原理"><a href="#二、强缓存的原理" class="headerlink" title="二、强缓存的原理"></a>二、强缓存的原理</h1><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h2><blockquote><p>当浏览器对某个资源的请求命中了强缓存时，返回的<code>http</code>状态为<code>200</code>，在<code>chrome</code>的开发者工具的<code>network</code>里面<code>size</code>会显示为<code>from cache</code>，比如京东的首页里就有很多静态资源配置了强缓存，用<code>chrome</code>打开几次，再用<code>f12</code>查看<code>network</code>，可以看到有不少请求就是从缓存中加载的</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-6341ce9ec238a050.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>强缓存是利用<code>Expires</code>或者<code>Cache-Control</code>这两个<code>http response header</code>实现的，它们都用来表示资源在客户端缓存的有效期。</li></ul><blockquote><p><code>Expires</code>是<code>http1.0</code>提出的一个表示资源过期时间的<code>header</code>，它描述的是一个绝对时间，由服务器返回，用<code>GMT</code>格式的字符串表示，如：<code>Expires:Thu, 31 Dec 2037 23:55:55 GMT</code></p></blockquote><h2 id="2-2-Expires缓存原理"><a href="#2-2-Expires缓存原理" class="headerlink" title="2.2 Expires缓存原理"></a>2.2 Expires缓存原理</h2><ol><li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在<code>respone</code>的<code>header</code>加上<code>Expires</code>，如</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/1480597-72ccb81233fb091a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ol start="2"><li>浏览器在接收到这个资源后，会把这个资源连同所有<code>response header</code>一起缓存下来（所以缓存命中的请求返回的<code>header</code>并不是来自服务器，而是来自之前缓存的<code>header</code>）</li><li>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的<code>Expires</code>跟当前的请求时间比较，如果请求时间在<code>Expires</code>指定的时间之前，就能命中缓存，否则就不行</li><li>如果缓存没有命中，浏览器直接从服务器加载资源时，<code>Expires Header</code>在重新加载的时候会被更新</li></ol><blockquote><p><code>Expires</code>是较老的强缓存管理<code>header</code>，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。所以在<code>http1.1</code>的时候，提出了一个新的<code>header</code>，就是<code>Cache-Control</code>，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：<code>Cache-Control:max-age=315360000</code></p></blockquote><h2 id="2-3-Cache-Control缓存原理"><a href="#2-3-Cache-Control缓存原理" class="headerlink" title="2.3 Cache-Control缓存原理"></a>2.3 Cache-Control缓存原理</h2><ol><li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在<code>respone</code>的<code>header</code>加上<code>Cache-Control</code>，如：</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/1480597-262d2cd0a580eb2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ol start="2"><li>浏览器在接收到这个资源后，会把这个资源连同所有<code>response header</code>一起缓存下来</li><li>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和<code>Cache-Control</code>设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行</li><li>如果缓存没有命中，浏览器直接从服务器加载资源时，<code>Cache-Control Header</code>在重新加载的时候会被更新</li></ol><ul><li><code>Cache-Control</code>描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较<code>Expires</code>，<code>Cache-Control</code>的缓存管理更有效，安全一些。</li><li>这两个<code>header</code>可以只启用一个，也可以同时启用，当<code>response header</code>中，<code>Expires</code>和<code>Cache-Control</code>同时存在时，<code>Cache-Control</code>优先级高于<code>Expires</code>：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1480597-390a31fe7f6af46b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="三、强缓存的管理"><a href="#三、强缓存的管理" class="headerlink" title="三、强缓存的管理"></a>三、强缓存的管理</h1><blockquote><p>前面介绍的是强缓存的原理，在实际应用中我们会碰到需要强缓存的场景和不需要强缓存的场景，通常有2种方式来设置是否启用强缓存</p></blockquote><ol><li>通过代码的方式，在<code>web</code>服务器返回的响应中添加<code>Expires</code>和<code>Cache-Control Header</code></li><li>通过配置<code>web</code>服务器的方式，让<code>web</code>服务器在响应资源的时候统一添加<code>Expires</code>和<code>Cache-Control Header</code></li></ol><blockquote><p>比如在javaweb里面，我们可以使用类似下面的代码设置强缓存</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.util.Date date = <span class="keyword">new</span> java.util.Date();    </span><br><span class="line">response.setDateHeader(<span class="string">"Expires"</span>,date.getTime()+<span class="number">20000</span>); <span class="comment">//Expires:过时期限值 </span></span><br><span class="line">response.setHeader(<span class="string">"Cache-Control"</span>, <span class="string">"public"</span>); <span class="comment">//Cache-Control来控制页面的缓存与否,public:浏览器和缓存服务器都可以缓存页面信息；</span></span><br><span class="line">response.setHeader(<span class="string">"Pragma"</span>, <span class="string">"Pragma"</span>); <span class="comment">//Pragma:设置页面是否缓存，为Pragma则缓存，no-cache则不缓存</span></span><br></pre></td></tr></table></figure><blockquote><p>还可以通过类似下面的<code>java</code>代码设置不启用强缓存</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader( <span class="string">"Pragma"</span>, <span class="string">"no-cache"</span> );   </span><br><span class="line">response.setDateHeader(<span class="string">"Expires"</span>, <span class="number">0</span>);   </span><br><span class="line">response.addHeader( <span class="string">"Cache-Control"</span>, <span class="string">"no-cache"</span> );<span class="comment">//浏览器和缓存服务器都不应该缓存页面信息</span></span><br></pre></td></tr></table></figure><ul><li><code>nginx</code>和<code>apache</code>作为专业的<code>web</code>服务器，都有专门的配置文件，可以配置<code>expires</code>和<code>cache-control</code>，这方面的知识，如果你对运维感兴趣的话，可以在百度上搜索<code>nginx</code> 设置 <code>expires cache-control</code>或 <code>apache 设置 expires cache-control</code> 都能找到不少相关的文章。</li><li>由于在开发的时候不会专门去配置强缓存，而浏览器又默认会缓存图片，<code>css</code>和<code>js</code>等静态资源，所以开发环境下经常会因为强缓存导致资源没有及时更新而看不到最新的效果，解决这个问题的方法有很多，常用的有以下几种</li></ul><p><strong>处理缓存带来的问题</strong></p><ol><li>直接<code>ctrl+f5</code>，这个办法能解决页面直接引用的资源更新的问题</li><li>使用浏览器的隐私模式开发</li><li>如果用的是<code>chrome</code>，可以<code>f12</code>在<code>network</code>那里把缓存给禁掉（这是个非常有效的方法）</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/1480597-5d2598d74fb558fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ol start="4"><li>在开发阶段，给资源加上一个动态的参数，如<code>css/index.css?v=0.0001</code>，由于每次资源的修改都要更新引用的位置，同时修改参数的值，所以操作起来不是很方便，除非你是在动态页面比如jsp里开发就可以用服务器变量来解决（<code>v=${sysRnd}</code>），或者你能用一些前端的构建工具来处理这个参数修改的问题</li><li>如果资源引用的页面，被嵌入到了一个<code>iframe</code>里面，可以在<code>iframe</code>的区域右键单击重新加载该页面，以<code>chrome</code>为例</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/1480597-dcf16f68408965a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ol start="6"><li>如果缓存问题出现在<code>ajax</code>请求中，最有效的解决办法就是<code>ajax</code>的请求地址追加随机数</li><li>还有一种情况就是动态设置<code>iframe</code>的<code>src</code>时，有可能也会因为缓存问题，导致看不到最新的效果，这时候在要设置的<code>src</code>后面添加随机数也能解决问题</li><li>如果你用的是<code>grunt</code>和<code>gulp</code>、<code>webpack</code>这种前端工具开发，通过它们的插件比如<code>grunt-contrib-connect</code>来启动一个静态服务器，则完全不用担心开发阶段的资源更新问题，因为在这个静态服务器下的所有资源返回的<code>respone header</code>中，<code>cache-control</code>始终被设置为不缓存</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/1480597-afa964e8c9329669.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="四、强缓存的应用"><a href="#四、强缓存的应用" class="headerlink" title="四、强缓存的应用"></a>四、强缓存的应用</h1><blockquote><p>强缓存是前端性能优化最有力的工具，没有之一，对于有大量静态资源的网页，一定要利用强缓存，提高响应速度。通常的做法是，为这些静态资源全部配置一个超时时间超长的<code>Expires</code>或<code>Cache-Control</code>，这样用户在访问网页时，只会在第一次加载时从服务器请求静态资源，其它时候只要缓存没有失效并且用户没有强制刷新的条件下都会从自己的缓存中加载，比如前面提到过的京东首页缓存的资源，它的缓存过期时间都设置到了<code>2026</code>年</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-ee120cc92380a2d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>然而这种缓存配置方式会带来一个新的问题，就是发布时资源更新的问题，比如某一张图片，在用户访问第一个版本的时候已经缓存到了用户的电脑上，当网站发布新版本，替换了这个图片时，已经访问过第一个版本的用户由于缓存的设置，导致在默认的情况下不会请求服务器最新的图片资源，除非他清掉或禁用缓存或者强制刷新，否则就看不到最新的图片效果</p></blockquote><p>这个问题已经有成熟的解决方案，具体内容可阅读知乎这篇文章详细了解：<a href="http://www.zhihu.com/question/20790576" target="_blank" rel="noopener">http://www.zhihu.com/question/20790576</a></p><p>文章提到的东西都属于理论上的解决方案，不过现在已经有很多前端工具能够实际地解决这个问题，由于每个工具涉及到的内容细节都有很多，本文没有办法一一深入介绍。有兴趣的可以去了解下<code>grunt</code> <code>gulp</code> <code>webpack</code> <code>fis</code> 还有edp这几个工具，基于这几个工具都能解决这个问题，尤其是<code>fis</code>和<code>edp</code>是百度推出的前端开发平台，有现成的文档可以参考：</p><p><a href="http://fis.baidu.com/fis3/api/index.html" target="_blank" rel="noopener">http://fis.baidu.com/fis3/api/index.html</a></p><p><a href="http://ecomfe.github.io/edp/doc/initialization/install/" target="_blank" rel="noopener">http://ecomfe.github.io/edp/doc/initialization/install/</a></p><blockquote><p>强缓存还有一点需要注意的是，通常都是针对静态资源使用，动态资源需要慎用，除了服务端页面可以看作动态资源外，那些引用静态资源的<code>html</code>也可以看作是动态资源，如果这种<code>html</code>也被缓存，当这些<code>html</code>更新之后，可能就没有机制能够通知浏览器这些html有更新，尤其是前后端分离的应用里，页面都是纯<code>html</code>页面，每个访问地址可能都是直接访问<code>html</code>页面，这些页面通常不加强缓存，以保证浏览器访问这些页面时始终请求服务器最新的资源</p></blockquote><h1 id="五、协商缓存的原理"><a href="#五、协商缓存的原理" class="headerlink" title="五、协商缓存的原理"></a>五、协商缓存的原理</h1><h2 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h2><blockquote><p>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的<code>http</code>状态为<code>304</code>并且会显示一个<code>Not Modified</code>的字符串，比如你打开京东的首页，按<code>f12</code>打开开发者工具，再按<code>f5</code>刷新页面，查看<code>network</code>，可以看到有不少请求就是命中了协商缓存的</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-1a49df2ac7217346.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>查看单个请求的<code>Response Header</code>，也能看到<code>304</code>的状态码和<code>Not Modified</code>的字符串，只要看到这个就可说明这个资源是命中了协商缓存，然后从客户端缓存中加载的，而不是服务器最新的资源</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-ba6199b735178677.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="5-2-Last-Modified，If-Modified-Since控制协商缓存"><a href="#5-2-Last-Modified，If-Modified-Since控制协商缓存" class="headerlink" title="5.2 Last-Modified，If-Modified-Since控制协商缓存"></a>5.2 Last-Modified，If-Modified-Since控制协商缓存</h2><ol><li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在<code>respone</code>的<code>header</code>加上<code>Last-Modified</code>的<code>header</code>，这个<code>header</code>表示这个资源在服务器上的最后修改时间</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/1480597-c94ad8a6eca3523c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ol start="2"><li>浏览器再次跟服务器请求这个资源时，在<code>request</code>的<code>header</code>上加上<code>If-Modified-Since</code>的<code>header</code>，这个<code>header</code>的值就是上一次请求时返回的<code>Last-Modified</code>的值</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/1480597-fb168628a9057045.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ol start="3"><li>服务器再次收到资源请求时，根据浏览器传过来<code>If-Modified-Since</code>和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回<code>304 Not Modified</code>，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回<code>304 Not Modified</code>的响应时，<code>response header</code>中不会再添加<code>Last-Modified</code>的<code>header</code>，因为既然资源没有变化，那么<code>Last-Modified</code>也就不会改变，这是服务器返回<code>304</code>时的<code>response header</code></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/1480597-41b97ffa2d4cb6d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ol start="4"><li>浏览器收到<code>304</code>的响应后，就会从缓存中加载资源</li><li>如果协商缓存没有命中，浏览器直接从服务器加载资源时，<code>Last-Modified</code> <code>Header</code>在重新加载的时候会被更新，下次请求时，<code>If-Modified-Since</code>会启用上次返回的<code>Last-Modified</code>值</li></ol><blockquote><p>【<code>Last-Modified</code>，<code>If-Modified-Since</code>】都是根据服务器时间返回的<code>header</code>，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个<code>header</code>配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对<code>header</code>来管理协商缓存，这对<code>header</code>就是【<code>ETag</code>、<code>If-None-Match</code>】。它们的缓存管理的方式是</p></blockquote><h2 id="5-3-ETag、If-None-Match控制协商缓存"><a href="#5-3-ETag、If-None-Match控制协商缓存" class="headerlink" title="5.3 ETag、If-None-Match控制协商缓存"></a>5.3 ETag、If-None-Match控制协商缓存</h2><ol><li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在<code>respone</code>的<code>header</code>加上<code>ETag</code>的<code>header</code>，这个<code>header</code>是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充<code>Last-Modified</code>的问题</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/1480597-2e7b17cc416372d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ol start="2"><li>浏览器再次跟服务器请求这个资源时，在<code>request</code>的<code>header</code>上加上<code>If-None-Match</code>的<code>header</code>，这个<code>header</code>的值就是上一次请求时返回的<code>ETag</code>的值</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/1480597-4e9de6397823de3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ol start="3"><li>服务器再次收到资源请求时，根据浏览器传过来<code>If-None-Match</code>和然后再根据资源生成一个新的<code>ETag</code>，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回<code>304 Not Modified</code>，但是不会返回资源内容；如果有变化，就正常返回资源内容。与<code>Last-Modified</code>不一样的是，当服务器返回<code>304 Not Modified</code>的响应时，由于<code>ETag</code>重新生成过，<code>response header</code>中还会把这个<code>ETag</code>返回，即使这个<code>ETag</code>跟之前的没有变化</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/1480597-d7e0fed4eb20776b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ol start="4"><li>浏览器收到<code>304</code>的响应后，就会从缓存中加载资源。</li></ol><h1 id="六、协商缓存的管理"><a href="#六、协商缓存的管理" class="headerlink" title="六、协商缓存的管理"></a>六、协商缓存的管理</h1><blockquote><p>协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。大部分<code>web</code>服务器都默认开启协商缓存，而且是同时启用【<code>Last-Modified</code>，<code>If-Modified-Since</code>】和【<code>ETag</code>、<code>If-None-Match</code>】，比如<code>apache</code>:</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-e8a13371862964b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。</p></blockquote><ul><li>【<code>Last-Modified</code>，<code>If-Modified-Since</code>】和【<code>ETag</code>、<code>If-None-Match</code>】一般都是同时启用，这是为了处理<code>Last-Modified</code>不可靠的情况。</li></ul><p><strong>有一种场景需要注意</strong></p><ul><li>分布式系统里多台机器间文件的<code>Last-Modified</code>必须保持一致，以免负载均衡到不同机器导致比对失败；</li><li>分布式系统尽量关闭掉<code>ETag</code>(每台机器生成的<code>ETag</code>都会不一样）；</li><li>京东页面的资源请求，返回的<code>repsones header</code>就只有<code>Last-Modified</code>，没有<code>ETag</code>：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1480597-ca1e0f55f8fb9928.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>协商缓存需要配合强缓存使用，你看前面这个截图中，除了<code>Last-Modified</code>这个<code>header</code>，还有强缓存的相关<code>header</code>，因为如果不启用强缓存的话，协商缓存根本没有意义</p></blockquote><h1 id="七、相关浏览器行为对缓存的影响"><a href="#七、相关浏览器行为对缓存的影响" class="headerlink" title="七、相关浏览器行为对缓存的影响"></a>七、相关浏览器行为对缓存的影响</h1><blockquote><p>如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。这是默认的处理方式，这个方式可能被浏览器的行为改变：</p></blockquote><ul><li>当<code>ctrl+f5</code>强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</li><li>当<code>f5</code>刷新网页时，跳过强缓存，但是会检查协商缓存</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、浏览器缓存基本认识&quot;&gt;&lt;a href=&quot;#一、浏览器缓存基本认识&quot; class=&quot;headerlink&quot; title=&quot;一、浏览器缓存基本认识&quot;&gt;&lt;/a&gt;一、浏览器缓存基本认识&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;分为强缓存和协商缓存&lt;/strong&gt;&lt;/p&gt;
&lt;o
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="HTTP" scheme="http://blog.poetries.top/tags/HTTP/"/>
    
      <category term="缓存" scheme="http://blog.poetries.top/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Typescript+React模板搭建（三）</title>
    <link href="http://blog.poetries.top/2018/12/31/ts-react-template/"/>
    <id>http://blog.poetries.top/2018/12/31/ts-react-template/</id>
    <published>2018-12-31T15:50:14.000Z</published>
    <updated>2019-01-07T08:48:58.312Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>整理于网络</p></blockquote><h1 id="一、项目初始化"><a href="#一、项目初始化" class="headerlink" title="一、项目初始化"></a>一、项目初始化</h1><h2 id="1-1-创建项目"><a href="#1-1-创建项目" class="headerlink" title="1.1 创建项目"></a>1.1 创建项目</h2><blockquote><p>确保安装了 <code>npm install -g typescript</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -S 是--save简写</span></span><br><span class="line"><span class="comment"># -D 是--save-dev简写</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line">mkdir ts-react &amp;&amp; <span class="built_in">cd</span> ts-react</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成package.json、tsconfig.json</span></span><br><span class="line">npm init -y &amp;&amp; tsc --init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装开发工具</span></span><br><span class="line">npm install-D webpack webpack-cli webpack-dev-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装react相关</span></span><br><span class="line">npm install -S react react-dom</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装react相关的ts验证包</span></span><br><span class="line">npm install -D @types/react @types/react-dom</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装ts-loader(或者awesome-typescript-loader) 这两款loader用于将ts代码编译成js代码</span></span><br><span class="line">npm install -D babel-loader</span><br></pre></td></tr></table></figure><h2 id="1-2-webpack配置"><a href="#1-2-webpack配置" class="headerlink" title="1.2 webpack配置"></a>1.2 webpack配置</h2><ol><li>在项目根目录新建一个<code>build</code>文件夹</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir build &amp;&amp; cd build &amp;&amp; touch webpack.config.js</span><br></pre></td></tr></table></figure><ol start="2"><li>根目录下新建src文件夹，然后在src里新建index.tsx文件作为项目入口</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir src &amp;&amp; cd src &amp;&amp; touch index.tsx</span><br></pre></td></tr></table></figure><ol start="3"><li>编写简单的<code>webpack</code>配置，只包含<code>entry</code>和<code>output</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: path.join(__dirname, <span class="string">'../'</span>, <span class="string">'src/index.tsx)</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    output: &#123;</span></span><br><span class="line"><span class="string">        path.join(__dirname, '</span>../<span class="string">', '</span>dist),</span><br><span class="line">        filename: <span class="string">'[name].js</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>编写<code>awesome-typescript-loader</code>配置项:<br>在<code>webpack</code>中的<code>module</code>是专门用来决定如何处理各种模块的配置项，例如本例中的<code>typescript</code>，这里主要用的配置项就是<code>module.rules</code>，而当前只需要简单配置解析<code>.tsx</code>文件类型即可</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f6ab875f614" alt=""></p><ol start="5"><li>在<code>src/index.tsx</code>中写入口文件</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Test <span class="keyword">from</span> <span class="string">'@components/Test'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> render = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ReactDOM.render(</span><br><span class="line">        &lt;div&gt;<span class="number">1234</span>&lt;<span class="regexp">/div&gt;,</span></span><br><span class="line"><span class="regexp">        document.querySelector('#app')</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">render()</span></span><br></pre></td></tr></table></figure><blockquote><p>但是这时候你会发现有一个错误没有处理</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-3ac1896339551fcf.png" alt="image.png"></p><blockquote><p>这是因为在<code>tsconfig</code>里面没有指定<code>JSX</code>的版本，这时候在<code>tsconfig</code>的<code>compilerOptions</code>中添加<code>&quot;jsx&quot;: &quot;react&quot;</code>配置项即可消除错误</p></blockquote><ul><li>此外还需要注意一点，以后需要<code>import xxx from &#39;xxx&#39;</code>这样的文件的话需要在<code>webpack</code>中的<code>resolve</code>项中配置<code>extensions</code>，这样以后引入文件就不需要带扩展名</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        extensions: [<span class="string">'.ts'</span>, <span class="string">'.tsx'</span>, <span class="string">'.js'</span>, <span class="string">'.jsx'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>添加页面模板</li></ol><blockquote><p>在<code>public</code>文件夹下新建文件夹<code>tpl</code>，然后在<code>tpl</code>中新建一个<code>index.html</code>，如下</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir public &amp;&amp; <span class="built_in">cd</span> public &amp;&amp; touch index.html</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这时候有了页面模板还是不够的，还需要将页面模板和打包出来的<code>js</code>文件关联起来，因为考虑到以后打包出来的<code>js</code>的文件不会是一个固定的名称，所以这里需要使用一个<code>webpack</code>的插件<code>html-webpack-plugin</code></p></blockquote><ol start="7"><li>配置<code>html-webpack-plugin</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> HtmlwebpackPlugin(&#123;</span><br><span class="line">            template: <span class="string">'public/index.html'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>配置完成后就可以启动项目了</p></blockquote><ol start="8"><li>配置<code>tsconfig</code></li></ol><ul><li><strong>编译目标</strong> 这时候我们切回<code>tsconfig</code>配置中，会发现在<code>compilerOptions</code>配置项的<code>target</code>是<code>es5</code>，也就是说把<code>ts</code>代码编译成<code>es5</code>规范的代码，如果不做兼容的话，我们可以将它设置为<code>es6</code>，使其编译成<code>es6</code>的代码</li><li><strong>模块处理</strong> 在<code>module</code>项中，会发现生成的是<code>commonjs</code>的模块系统，因为不考虑兼容，所以这里我也将其设定为最新的<code>esnext</code>，并且将模块处理方式改为用<code>node</code>来处理，设置<code>moduleResolution</code>项为<code>node</code>，不做模块处理方式设置的话可能会有报错</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1480597-46772c094f3b6ec4.png" alt="image.png"></p><ol start="9"><li>项目启动</li></ol><blockquote><p>这时候我们可以在<code>package.json</code>中添加启动命令</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"dev"</span>: <span class="string">"webpack-dev-server --config build/webpack.config.js --mode development"</span></span><br></pre></td></tr></table></figure><blockquote><p>其中<code>--mode development</code>用于指定开发模式，否则在<code>webpack4+</code>版本下会有警告<br>然后直接<code>npm run dev</code>即可</p></blockquote><p><strong>总结</strong></p><blockquote><p>其实这个时候项目其实就已经跑起来了，完全可以不用往下看，但是实际上的工作并没有做完，下一章就开始讲解如何提高开发体验</p></blockquote><h1 id="二、提升开发体验"><a href="#二、提升开发体验" class="headerlink" title="二、提升开发体验"></a>二、提升开发体验</h1><blockquote><p>本章主要介绍的是建立在项目初始化的基础上如何优化开发体验 内容包含如下:</p></blockquote><ul><li>支持<code>sass</code></li><li>支持<code>css module</code></li><li>配置公用的<code>sass</code>属性</li><li>支持装饰器</li><li>路径优化</li><li>构建缓存</li><li>构建加速</li></ul><h2 id="2-1-支持sass"><a href="#2-1-支持sass" class="headerlink" title="2.1 支持sass"></a>2.1 支持sass</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装相应包</span></span><br><span class="line">npm install -D node-sass sass-loader style-loader css-loader</span><br></pre></td></tr></table></figure><blockquote><p><code>webpack</code>进行<code>loader</code>编译的顺序是从下到上的:知道上面的顺序后我们在<code>webpack</code>中的配置就非常简单了，直接在<code>module.rules</code>下面加上<code>.scss</code>文件类型的编译配置即可</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-c145c9bc2d7beba3.png" alt="image.png"></p><blockquote><p>查看效果,这时候我们在<code>src</code>下面新建一个<code>index.scss</code>，然后在<code>index.tsx</code>里面引入这个文件查看</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-b74706639dcc96ec.png" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/1480597-1a6a70075e7c7c50.png" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/1480597-fceef9bad33d1c88.png" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/1480597-f2d61554eee89eb8.png" alt="image.png"></p><h2 id="2-2-支持css-module"><a href="#2-2-支持css-module" class="headerlink" title="2.2 支持css module"></a>2.2 支持css module</h2><blockquote><p><code>css module</code>是针对<code>css</code>类名作用域做出限定的一种规范，用以解决<code>css</code>类名冲突的问题</p></blockquote><ul><li>安装对应的包 因为在这里我们用的是<code>TypeScript</code>，所以可以用<code>typings-for-css-modules-loader</code>这个包，这个包也可以替代<code>css-loader</code>的功能，此外这个包还能根据<code>.scss</code>文件里面的类名自动生成对应的<code>.d.ts</code>文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D typings-for-css-modules-loader</span><br></pre></td></tr></table></figure><blockquote><p>配置<code>webpack</code> 这个配置接非常简单了，因为要用<code>typings-for-css-modules-loader</code>替代<code>css-loader</code>的功能，所以直接替换即可，将前面<code>sass</code>的配置修改为如下:</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-a8e5e88cc166e9e9.png" alt="image.png"></p><blockquote><p>修改为这样既可，但是同时我们也发现一个问题:</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-8650cbd1167c3b6e.png" alt="image.png"></p><ul><li>这个问题导致的原因是因为<code>.scss</code>文件中并没有类似<code>export</code>这样的关键词用于导出一个模块，所以也就导致报错找不到模块，这个问题可以通过<code>ts</code>的模块声明(<code>declare module</code>)来解决。</li><li>解决模块声明问题,这时候我们在根目录下新建一个<code>typings</code>文件夹，用于存放<code>.scss</code>的模块声明，以及后续需要用到的全局校验接口，然后新建<code>typed-css-modules.d.ts</code>文件用于存放<code>.scss</code>模块声明，目录结构和声明内容如下</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1480597-d4b2a1e15a409d1f.png" alt="image.png"></p><blockquote><p>这个时候回到<code>index.tsx</code>文件中你会发现错误标红消失了，然后我们在<code>index.scss</code>文件中新增如下代码</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-886d76204ba49b50.png" alt="image.png"></p><blockquote><p>保存后你会发现当前目录下新增了一个<code>index.scss.d.ts</code>文件，打开里面可以发现是针对每个类名的类型校验，当以后新增类名的时候，<code>typed-css-modules.d.ts</code>都会自动在<code>index.scss.d.ts</code>里面新增对应的类型校验</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-ffcf09769cc79135.png" alt="image.png"></p><p>这时候回到页面查看，你会发现类名变成了一个<code>hash</code>值，这样可以有效地避免类名全局污染问题</p><p><img src="https://upload-images.jianshu.io/upload_images/1480597-be3150005a9700ab.png" alt="image.png"></p><h2 id="2-3-配置公共sass属性"><a href="#2-3-配置公共sass属性" class="headerlink" title="2.3 配置公共sass属性"></a>2.3 配置公共sass属性</h2><blockquote><p>既然已经可以使用<code>sass</code>进行更加简便的<code>css</code>代码编写，那么我们也可以将常用的一些样式代码和<code>sass</code>变量写入公共文件中，当使用的时候就可以直接引入使用，这可以提高一定的效率节约时间</p></blockquote><ol><li>新建公共样式目录 </li></ol><blockquote><p>首先在<code>src</code>目录下新建<code>styles</code>文件夹，然后在<code>styles</code>文件夹下新建<code>var.scss</code>文件用于存放样式变量。 之后在<code>var.scss</code>文件里写入一个颜色变量和一个样式:</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-4ada767224de622b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ol start="2"><li>查看效果 </li></ol><blockquote><p>然后在<code>index.scss</code>文件里面引入<code>var.scss</code>，接着就可以直接使用里面的变量了</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-4f452f5cba5782f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/1480597-1554f29f39aa3522.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ol start="3"><li>优化</li></ol><blockquote><p>上面的效果其实已经达成，但还是存在一个不好的问题，就是在引入<code>var.scss</code>的路径上要根据每个文件夹的路径相对来引入非常麻烦，那么我们能否做到只需要<code>@import var.scss</code>就行呢？答案是可以的，我们可以使用一个<code>node-sass</code>的属性<code>includePaths</code>进行路径优化:</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-cc44afa01edc72d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/1480597-ad9864348b48135a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="2-4-支持装饰器"><a href="#2-4-支持装饰器" class="headerlink" title="2.4 支持装饰器"></a>2.4 支持装饰器</h2><blockquote><p>前置工作 在<code>src</code>目录下新建一个<code>components</code>文件夹，用于存放通用组件，然后在<code>components</code>文件及里面新建一个组件<code>Test</code>，然后在网页入口引入这个组件，如下图所示:</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-5492a1601a16945e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/1480597-8ab6539f1b27405c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>什么是装饰器，为什么需要装饰器 装饰器本质上就是一个函数，这个函数对类(<code>class</code>)本身进行一些处理，也可以将装饰器的写法当做一种语法糖，如果不用装饰器的话，可以写成下图这样</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-db9e068794cbc0e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>设置装饰器可用 根据装饰器的语法，我们可以将上面的代码写成如下:</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-eb59e8237811d204.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>但是你会发现这里报了一个错误，这是因为装饰器语法在<code>es6</code>标准中还只是一个提案，并未正式支持，但是在<code>ts</code>中，装饰器已经被正式支持了，不用<code>ts</code>的可以自行安装<code>babel</code>相关包进行支持</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-8633fd1213bb094d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>那么怎么解决这个错误呢？我们根据错误提示进入到<code>tsconfig</code>文件中，将<code>experimentalDecorators</code>设置为<code>true</code>即可，然后回到页面查看<code>log</code>装饰器已经生效了</p></blockquote><h2 id="2-5-优化路径"><a href="#2-5-优化路径" class="headerlink" title="2.5 优化路径"></a>2.5 优化路径</h2><blockquote><p>在上面的例子中我们新建了<code>components</code>文件夹，然后在入口处引入了其中的<code>Test</code>组件</p></blockquote><p>但是这时候需要考虑到一个问题，如果以后在一个层级比较深的文件中引入这个组件会不会产生如下这种情况呢?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Test from &apos;../../../../components/Test&apos;</span><br></pre></td></tr></table></figure><blockquote><p>这样不仅书写起来麻烦还容易出错，因此这时候就需要进行一些路径上的优化，使得无论在哪个地方引入这些组件都能用同一种写法，例如:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Test from &apos;@comonents/Test&apos;</span><br></pre></td></tr></table></figure><blockquote><p>这里针对路径的优化有两种方案，第一种是直接在<code>webpack.resolve.alias</code>中进行路径配置:</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-9fffcce76fa5174d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>但是在这里我们使用了<code>ts</code>，所以还需要在<code>tsconfig</code>中进行配置:</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-59b1a58c538f728f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>这样也能用，不过我们还可以用<code>tsconfig-paths-webpack-plugin</code>这个包将<code>tsconfig</code>中对路径的设置映射<code>到webpack</code>配置中去，这样就不需要在<code>webpack</code>中再进行一次路径的配置了，首先安装:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D tsconfig-paths-webpack-plugin</span><br></pre></td></tr></table></figure><blockquote><p>然后就采用前面<code>tsconfig</code>里面对<code>baseUrl</code>和<code>paths</code>的配置。<br>之后进入<code>webpack</code>配置中，引入<code>tsconfig-paths-webpack-plugin</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const TsconfigPathsPlugin = require(&apos;tsconfig-paths-webpack-plugin&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>接着在<code>webpack.resolve</code>中新增配置项<code>plugins</code>(这里要注意的是新增的不是<code>webpack.plugins</code>，而是<code>webpack.resolve.plugins</code>)，配置如下代码</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-2388745cb4a2d2c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>接着我们就可以愉快地使用简化后的路径了：</p><p><img src="https://upload-images.jianshu.io/upload_images/1480597-a69d77a627210a60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="2-6-构建缓存"><a href="#2-6-构建缓存" class="headerlink" title="2.6 构建缓存"></a>2.6 构建缓存</h2><blockquote><p>我们一般会使用<code>webpack-dev-server</code>来进行项目开发，当我们运行<code>webpack-dev-server</code>的时候它会在内存中进行项目的构建，但是当使用了<code>babel</code>之类的代码转换工具后，会对项目构建产生较大的性能影响，这是因为每一次的构建都会对代码进行重新转换。而构建缓存就是将构建的公用代码缓存在磁盘上，这样做的效果就是第一次构建的时间花销会比不用缓存的构建大，但是在之后每次构建的时间花销都会大大减少</p></blockquote><ul><li><strong>对比</strong> 我们拿一个较大的项目来看区别。 注: 左边是没有设置构建缓存，右边进行了构建缓存。 首先进行对比的是第一次构建时候的时间花销:</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1480597-f6737c7614fa602f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>然后是第二次构建的时间花销</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1480597-8c51fe3ed1ad6416.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>可以看出在第二次构建的时候时间花销减少了百分之五十以上。</p><p><strong>设置构建缓存</strong></p><blockquote><p>在设置构建缓存之前我们首先要考虑的是那些地方需要进行设置，那么在前面的配置过程中，可以看出花销较大的地方有对<code>ts(x)</code>的转换并且以后还会添加对应的<code>babel</code>进去，然后还有针对<code>sass</code>类型的转换，那么我们就先对这两个地方的转换进行配置</p></blockquote><ol><li>对<code>ts(x)</code>的转换</li></ol><blockquote><p>这里因为我们使用的是<code>awesome-typescript-loader</code>，这个库本身自带了开启缓存的选项<code>useCache</code>，然后我们需要指定一个保存缓存文件的地方<code>cacheDirectory</code>，所以配置改为如下:</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f824c8eb2f6" alt=""></p><ol start="2"><li>对<code>sass</code>类型的转换</li></ol><blockquote><p>这个地方我们需要使用到一个库<code>cache-loader</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D cache-loader</span><br></pre></td></tr></table></figure><blockquote><p>然后在对<code>.scss</code>文件类型的转换配置中使用它，在这里我们主要是针对转换出来的<code>css</code>进行缓存，所以需要写在<code>typings-for-css-modules-loader</code>配置的前面:</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-a8612869bf4ba225.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>这样就配置好当前的构建缓存了，当你<code>npm run dev</code>的时候会发现根目录下生成了缓存文件<code>.cache-loader</code></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-aa84471a4af9e4dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>打开它看会发现有对应的缓存代码:</p><p><img src="https://upload-images.jianshu.io/upload_images/1480597-5dc044b34a15bc81.png" alt="image.png"></p><h1 id="三、整理杂项"><a href="#三、整理杂项" class="headerlink" title="三、整理杂项"></a>三、整理杂项</h1><blockquote><p>在上一篇提升开发体验中，我们一下子集成了一堆插件和功能进去，导致项目结构比教混乱，重点问题就在<code>webpack</code>的相关配置项目录<code>build</code>文件夹中，所以今天的工作较为轻松，重点就是进行项目结构整理，然后再进行一些杂项的添加</p></blockquote><ul><li>整理项目结构</li><li>集成<code>Ant Design</code>并进行主题修改</li><li>整合常用函数，并且让所有组件继承这些函数</li><li>集成<code>mobx</code>进行项目的状态管理</li><li>使用<code>react-hot-loader</code>进行热加载</li><li>集成<code>svg-component</code></li></ul><h2 id="3-1-整理项目结构"><a href="#3-1-整理项目结构" class="headerlink" title="3.1 整理项目结构"></a>3.1 整理项目结构</h2><p>在做这一步的时候首先我们来看看现在的项目结构是怎么样的</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8c2afefae4" alt=""></p><blockquote><p>那么当前最先需要做的工作就是进行build文件夹下<code>webapck</code>的配置项整理</p></blockquote><p>针对<code>webpack</code>配置项的整理。做这一步的时候首先需要确定一点就是，我们根据什么来整理<code>webpack</code>配置项目录呢？要确定这一点只需要查看一下<code>webpack</code>中有些什么配置，然后就可以根据每个配置项进行模块划分</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8c2b307da5" alt=""></p><blockquote><p>在这份配置项中，因为<code>entry</code>、<code>output</code>、<code>resolve</code>内容相对较少，往后也不会有太多内容的添加，所以可以忽略</p></blockquote><p><strong>首先将plugins相关内容移出来</strong></p><ol><li>首先在<code>build</code>中新建文件<code>plugins.js</code>，然后将原先的<code>plugin</code>里面的代码拷贝过去</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8c2c047254" alt=""></p><ol start="2"><li>在<code>webpack.config.js</code>中将<code>plugins.js</code>的内容引入进来即可</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8c2c12d407" alt=""></p><p><strong>整合路径选择</strong>在<code>webpack.config.js</code>中你会看到许多使用<code>path.join</code>的地方，这一块也可以抽取出来作为一个工具模块。新建<code>build/utils.js</code>文件，然后写入如下代码，将路径的目标指向根目录，详细路径则通过参数的形式传入</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8c2c08d84e" alt=""></p><p>之后在任何需要使用的地方引入这个函数使用即可</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8c2c233b37" alt=""></p><p><strong>将module相关内容移出来</strong> </p><blockquote><p>因为在<code>module</code>项中相关的配置相对较多，涵盖了对<code>ts(x)</code>和<code>scss</code>等相关文件的<code>loader</code>，以后还需要添加针对图片等文件类型的<code>loader</code>，所以这一块需要分的更加细一些:</p></blockquote><ol><li>在<code>build</code>中新建<code>rules</code>目录，里面新建<code>jsRules</code>和<code>styleRules</code>文件</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8c64eb6fa0" alt=""></p><ol start="2"><li>将之前<code>module</code>中的<code>loader</code>配置一如对应文件中并导出，然后在<code>webpack.config.js</code>中引入: 首先是<code>jsRules</code>内容</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8c68636d4a" alt=""></p><blockquote><p>然后是<code>styleRules</code>内容</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8c6fac503d" alt=""></p><p>最后是引入<code>rules</code>后的<code>webpack.config.js</code></p><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8c79f0f5c4" alt=""></p><blockquote><p>至此我们就将<code>webpack</code>的配置项分离了出来，接下来我们集成<code>Ant DesignUI</code>库(简称<code>antd</code>)，并且修改其主题色。</p></blockquote><h2 id="3-2-集成antd"><a href="#3-2-集成antd" class="headerlink" title="3.2 集成antd"></a>3.2 集成antd</h2><blockquote><p>集成<code>antd</code> 要集成<code>antd</code>非常简单，只需要<code>npm install -S antd</code>即可，然后我们在<code>components/Test</code>组件中引入其中一个组件</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8c97991436" alt=""></p><p><strong>修改<code>antd</code>的主题配色</strong></p><blockquote><p>通常在开发中，我们采用的配色不是<code>antd</code>原本的配色，如果大面积引用<code>antd</code>组件的话，一个个去修改配色确实是非常麻烦的事情，于是这个时候就需要一次性对<code>antd</code>的主题色进行修改</p></blockquote><ol><li><code>antd</code>的样式使用<code>less</code>进行编写，对其主题的修改也就是对其中的<code>less</code>变量进行修改，所以想要修改主题需要安装<code>less</code>和<code>less-loader: npm install -D less less-loader</code></li><li>然后我们在根目录下添加一个<code>theme.js</code>文件，里面是需要修改的主题样式代码，具体有什么主题可以进行修改可以点击<a href="https://ant.design/docs/react/customize-theme-cn" target="_blank" rel="noopener">这里查看</a>:</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8d0b747b7c" alt=""></p><ol start="3"><li>然后编写在<code>build/rules/styleRules</code>中添加针对<code>less</code>文件的<code>loader</code>，如下图: 引入上一步的主题文件</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> theme = <span class="built_in">require</span>(<span class="string">'../../../theme'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8d1e9baa99" alt=""></p><ol start="4"><li>最后我们在<code>components/Test</code>组件中引入<code>Button</code>组件的样式<code>less</code>文件</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8d2765fc0e" alt=""></p><blockquote><p>此时可以查看效果，发现已经主题已经修改成功</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8d27a7dca3" alt=""></p><ol start="5"><li>存在的问题</li></ol><blockquote><p>这个时候进行<code>antd</code>组件的引入和主题修改的步骤中还是存在一些问题的，比如在引入某个组件的同时还需要手动引入其对应的<code>less</code>文件，这是非常麻烦的一件事，那么找我们需要解决的就是在引入<code>antd</code>组件的同时也自动引入其对应的<code>less</code>文件。<br>另外，使用<code>import {Button } from &#39;antd&#39;</code>这样的引入方式存在一个很大的弊端，就是在引入其中某个组件的同时会把整个<code>antd</code>文件都引入进来，影响构建速度，而且打包后体积会变大，这样的话我们还需要做<code>antd</code>的按需加载。所以接下来我们需要解决掉这两个问题，而这两个问题也是可以同时解决的</p></blockquote><p><strong>antd按需加载</strong></p><ul><li>在<code>antd</code>官网中推荐使用<code>babel-plugin-import</code>来做按需加载，但是我们的项目用的是<code>typescript</code>，走的是<code>awesome-typescript-loader</code>编译，所以在我们的项目中<code>babel-plugin-import</code>是不生效的，这时候需要就需要一个叫做<code>ts-import-plugin</code>的插件<br><code>npm install -D ts-import-plugin</code></li><li>第二步我们需要在<code>build/rules/jsRules.js</code>中进行配置，根据<code>ts-import-plugin</code>的教程直接配置即可</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8d44294d39" alt=""></p><ul><li>回到<code>Test</code>组件中 将<code>import &#39;antd/lib/button/style/index.less&#39;</code>这句话删掉，然后重新运行查看效果</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8d564985fd" alt=""></p><h2 id="3-3-整合常用函数"><a href="#3-3-整合常用函数" class="headerlink" title="3.3 整合常用函数"></a>3.3 整合常用函数</h2><blockquote><p>在上一步中，我们集成了<code>antdUI</code>库，在这个库中有许多东西是非常常用的，例如消息组件<code>message</code>和通知组件<code>notification</code>，但是要用到这两个组件的话就得引入，当使用次数较多的时候，我们可以考虑将其整合在一个<code>react</code>组件中，然后所有的组件都继承这个组件即可，这样做的好处是当以后添加了例如<code>axios</code>这样的常用库的时候也可以整合到这个<code>react</code>组件中，使继承这个<code>react</code>组件的组件都可以用到</p></blockquote><p><strong>整合常用函数</strong></p><ol><li>我们先在<code>src</code>下新建<code>utils</code>目录，然后在<code>utils</code>中新建<code>reactExt.tsx</code>文件</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8d5b6090f8" alt=""></p><ol start="2"><li>然后在<code>tsconfig.json</code>中设置好<code>utils</code>的路径，方便以后的路径引用</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8d5c1006a2" alt=""></p><ol start="3"><li>在<code>reactExt.tsx</code>中引入<code>antd</code>常用组件，然后导出这个整合了<code>antd</code>组件的组件，当然你也可以把它叫做类，其中需要注意的是，因为以后的每个<code>react</code>组件使用的都是<code>componentExt</code>，然后在这里我们需要使用<code>typescript</code>的<code>interface</code>来对<code>react</code>组件的<code>state</code>和<code>props</code>进行数据类型上的限制，但与此同时并不能知道每个<code>react</code>组件针对<code>state</code>和<code>props</code>的<code>interface</code>是怎么样的，所以在<code>componentExt</code>中需要用到泛型来灵活化<code>interface</code></li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8d6e8951c5" alt=""></p><ol start="4"><li>最后在<code>components/Test</code>组件中引入<code>comonentExt</code>进行测试:</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8d7b30cfdc" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8d904c2d8c" alt=""></p><blockquote><p>以后如果有常用的功能性函数也可以往<code>components/reactExt</code>中进行添加。</p></blockquote><h2 id="3-4-集成mobx"><a href="#3-4-集成mobx" class="headerlink" title="3.4 集成mobx"></a>3.4 集成mobx</h2><blockquote><p><code>mobx</code>是<code>react</code>技术栈中一款优秀的状态管理工具，它具有数据监测的功能，并且比<code>redux</code>用起来更加方便，也能脱离<code>react</code>进行单独使用，安装<code>mobx</code>只需要<code>npm install -S mobx</code>即可，同时也要安装他和<code>react</code>连接的工具<code>npm install -S mobx-react</code>。接下来就以一个经典的计算器组件来测试<code>mobx</code>。</p></blockquote><p>准备工作 在进行测试之前，我们还需要整理一下组件存放的目录。首先区分一下组件目录的作用</p><ol><li><code>components</code>目录用于存放通用组件，该目录存放的组件不包含任何业务性功能。</li><li>新建<code>src/containers/views</code>目录，这个目录是用于存放业务组件的，并且这些组件不能复用。</li><li>新建<code>src/containers/shared</code>目录，这个目录用于存放可以复用的业务组件。</li><li>在<code>tsconfig.json</code>中设置简短路径方便以后调用</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8d962b539a" alt=""></p><p>这一步在该博客中作用体现不大，但是对真实项目的条理性是存在较好作用的。 如下图</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8dad2a591e" alt=""></p><p><strong>创建store</strong></p><ol><li>新建<code>src/store</code>目录用于存放<code>store</code>文件，然后在该目录下新建<code>globalStore</code>目录和其中的<code>index.tsx</code>文件</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8db62a7861" alt=""></p><ol start="2"><li>然后在这个<code>index.tsx</code>文件中有如下代码:其中的<code>observable</code>和<code>action</code>的功能请自行查看<code>mobx</code>文档</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8db645466b" alt=""></p><ol start="3"><li>然后新建<code>src/store/index.tsx</code>文件用于导出这些<code>store</code></li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8dc2c22e8a" alt=""></p><blockquote><p>连接<code>store</code> 创建了<code>store</code>之后我们还需要将其和<code>react</code>进行连接，这个时候就需要用到<code>mobx-react</code>这个库，我们去到<code>src/index.tsx</code>中进行修改</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8dd42b6277" alt=""></p><blockquote><p>这里面的<code>configure({enforceActions: &#39;observed&#39;})</code>用于限制被<code>observable</code>(也就是<code>store</code>中添加了<code>@observable</code>)的数据的修改方式，让其只能添加了<code>@action</code>的函数中进行修改</p></blockquote><p><strong>编写Counter组件进行测试</strong></p><ol><li>我们去到<code>src/containers/views</code>目录中，新增<code>Counter/index.tsx</code>，并写入如下代码:</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8e6498d5b6" alt=""></p><ol start="2"><li>然后将这个组件用<code>mobx-react</code>变为可观测对象，并使用<code>@inject</code>注入<code>globalStore</code></li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8ebe0fe5a8" alt=""></p><ol start="3"><li>最后我们在<code>src/index.tsx</code>中引入<code>Counter</code>组件，顺便看看它的<code>props</code>中是否带有数据</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8ebdf84fcb" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8ec7ec007f" alt=""></p><ol start="4"><li>最后回到<code>Counter</code>组件中编写方法检验功能是否正常</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8ec93a6e97" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8ed83a36e1" alt=""></p><p><strong>给<code>store</code>添加全局<code>typescript</code>校验</strong></p><blockquote><p>在上面的例子中虽然我们在功能上已经可以正常的使用了，但是显而易见的是有报错，这个错误是因为没有填写针对组件<code>props</code>的验证接口导致<code>typescript</code>认为<code>globalStore</code>不存在而导致的。我们可以写成如下代码解决问题</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8ed94ef498" alt=""></p><blockquote><p>但是每个引入了<code>globalStore</code>的组件都需要写一次显得非常麻烦，那么我们可以将<code>IGlobalStore</code>这个校验接口写成全局的校验接口，直接以如下图形式验证即可:</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8ef763161e" alt=""></p><ol><li>我们在<code>src/store/globalStore</code>下新建<code>type.d.ts</code></li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8efd0a612d" alt=""></p><ol start="2"><li>去到<code>globalStore/index.tsx</code>中，将<code>GlobalStore</code>类导出，我们将会利用这个类作为<code>typescript</code>校验接口来使用(<a href="https://www.tslang.cn/docs/handbook/classes.html" target="_blank" rel="noopener">这种用法可以点这里查看详情</a>):</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8f0c4f3793" alt=""></p><ol start="3"><li>在<code>type.d.ts</code>中引入这个类，然后定义并导出一个全局命名空间(该用法详解点这里)，接着在这个命名空间中把接口导出:</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8f0d3eb028" alt=""></p><ol start="4"><li>回到<code>Counter</code>组件中，将接口改写为如下</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8f228cde5d" alt=""></p><blockquote><p>这里注意需要添加<code>?</code>，因为这个属性是从<code>store</code>中拿过来的，不填写的话，父组件会报错说没有传这个值。 但是因为添加了<code>?</code>，所以这个<code>globalStore</code>验证为不一定有，从而在组件中会有如下报错:</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8f2cbe58cd" alt=""></p><blockquote><p>这个时候我们可以去<code>tsconfig.json</code>中将<code>strictNullChecks</code>项置为<code>false</code>，去掉<code>null</code>和<code>undefined</code>的检测即可</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8f3ae218f9" alt=""></p><ol start="5"><li>到了这一步我们集成<code>Mobx</code>就成功了，并且也针对<code>store</code>添加了对应的<code>typescript</code>验证:</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8fb0f9a40b" alt=""></p><h2 id="3-5-使用react-hot-loader进行热加载"><a href="#3-5-使用react-hot-loader进行热加载" class="headerlink" title="3.5 使用react-hot-loader进行热加载"></a>3.5 使用react-hot-loader进行热加载</h2><blockquote><p>这一步主要针对的是<code>webpack-dev-server</code>的页面自动刷新功能不能保持数据一直都在，有时候在更新组件代码后需要保持数据不变的场景就会很不方便，所以这个时候就需要用到<code>react-hot-loader</code>来进行页面代码变更检测并找到变更部分进行更新，同时保证数据不变</p></blockquote><ol><li>首先我们安装它<code>npm install -D react-hot-loader</code></li><li>然后我们还要用到它里面的<code>react-hot-loader/babel</code>，但是因为我们使用了<code>awesome-typescript-loader</code>，所以不需要在根目录添加<code>.babelrc</code>文件了，直接进到<code>build/rules/jsRules.js</code>中进行配置即可</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8fe0254e3e" alt=""></p><ol start="3"><li>接着我们去到<code>Counter</code>组件中引入<code>react-hot-loader</code>中的<code>hot</code>方法，直接以装饰器的形式包裹组件</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8fe202cfc4" alt=""></p><ol start="4"><li>最后再去<code>package.json</code>中，在<code>dev</code>命令后面加上<code>--hot</code>即可</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8fec22bb00" alt=""></p><ol start="5"><li>回到<code>Counter</code>组件中做个检测，先增加一些数字，然后在增加字样后面加上几个字符，可以看到页面更新的同时保留了数据</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f8fee77cede" alt=""></p><blockquote><p>实际上我们在控制台看到输出这个字样就已经成功了</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f9017aa3c1c" alt=""></p><h2 id="3-6-集成svg-component"><a href="#3-6-集成svg-component" class="headerlink" title="3.6 集成svg-component"></a>3.6 集成svg-component</h2><blockquote><p>在前端开发中，<code>svg</code>格式的图片使用的是非常频繁的，而集成了<code>svg-component</code>后，我们可以将<code>svg</code>图片以组件的形式引入并使用</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f9049d9e78d" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f9053dc41a4" alt=""></p><ol><li>要集成<code>svg-component</code>我们首先要安装<code>@svgr/webpack: npm install -D @svgr/webpack</code>，这是一个<code>loader</code>；</li><li>然后我们在<code>build/rules</code>中新建<code>fileRules.js</code>文件，将<code>svg</code>格式文件用这个<code>loader</code>进行编译</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f90590b139a" alt=""></p><blockquote><p>然后在<code>webpack.config.json</code>中导入并重启项目</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f906b6a9866" alt=""></p><ol start="3"><li>接着我们随便找一个<code>svg</code>格式图片在<code>Counter</code>中引入并测试，虽然可以使用了，但是也导致了一个<code>typescript</code>的报错说找不到模块</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f90846eb8ae" alt=""></p><blockquote><p>导致这个错误的原因是<code>svg</code>图片本身并不具备模块化的功能，也不提供模块导出，所以在导入的时候是不能识别的，要解决这个问题可以模仿我们之前使用<code>css moudles</code>的方式，给它声明一个模块:我们在<code>typings</code>目录下新建<code>svg.d.ts</code>文件，并写入如下代码</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f9087ba0a45" alt=""></p><blockquote><p>这个时候还可以为<code>svg-component</code>的使用提供代码提示和传入属性校验的支持: 我们声明一个接口，然后在声明的模块中用这个接口作为内容</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f908ff2a12b" alt=""></p><blockquote><p>这个接口使用的是<code>react</code>的无状态组件声明，传入属性则为<code>svg</code>文件自带的属性比如<code>col</code> or <code>width</code>之类的，然后我们就可以愉快地使用<code>svg-comonent</code>了</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f9099a156a0" alt=""></p><h1 id="四、项目打包"><a href="#四、项目打包" class="headerlink" title="四、项目打包"></a>四、项目打包</h1><blockquote><p>本章节内容</p></blockquote><ul><li>添加打包命令</li><li>进行<code>css</code>和<code>js</code>分离</li><li>修改<code>html-webpack-plugin</code>配置项</li><li>添加<code>react-loadable</code>和<code>react-router</code>,进行代码分离和按需加载</li><li>添加<code>optimization</code>,进行第三方库代码分离</li><li>进行代码压缩</li><li>关于<code>externals</code></li></ul><h2 id="4-1-添加打包命令"><a href="#4-1-添加打包命令" class="headerlink" title="4.1 添加打包命令"></a>4.1 添加打包命令</h2><blockquote><p>我们先去<code>webpack.config.js</code>中观察一下<code>output</code>这个配置项</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f94ef778e90" alt=""></p><blockquote><p>该配置项指定了打包路径和打包后的<code>js</code>文件名，在<code>webpack</code>的配置项中，<code>output</code>是必须有的。 接着我们去到<code>package.json</code>中在<code>script</code>中添加打包命令<code>build</code>，该命令引用我们的<code>webpack.config.js</code>配置文件</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f94ef97e678" alt=""></p><blockquote><p>之后试试运行<code>npm run build</code>，会发现已经将项目打包出来了</p></blockquote><p><strong>添加打包路径工具</strong></p><blockquote><p>在上一步中，我们已经知道打包出来的文件位于根目录下的<code>dist</code>文件夹中，所以这个路径工具的添加指向<code>dist</code>文件夹： 我们去到<code>build/utils.js</code>文件中，添加如下代码:</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f94f05a96c6" alt=""></p><p>以后指定打包文件存放路径的时候就可以直接使用这个工具进行指定</p><h2 id="4-2-分离css文件"><a href="#4-2-分离css文件" class="headerlink" title="4.2 分离css文件"></a>4.2 分离css文件</h2><blockquote><p>在上面打包的结果中，我们会发现只有一个<code>app.js</code>文件，而实际上我们是有写<code>css</code>样式的，但是现在的却并没有这个<code>css</code>文件，这是因为<code>webpack</code>将所有的资源(包含<code>js,</code> <code>css</code>等等)都看成是<code>chunk</code>，然后一起打包进一个文件中，这样会导致打包出来的<code>js</code>文件体积巨大，从而拖累页面的加载速度</p></blockquote><ol><li>在<code>webpack 4+</code>版本中，我们可以使用<code>mini-css-extract-plugin</code>进行<code>css</code>代码的分离，所以首先安装它<code>npm install -D mini-css-extract-plugin</code>。</li><li>然后我们到<code>build/plugins.js</code>中添加这个插件</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f94f05a22d8" alt=""></p><ol start="3"><li>最后需要注意，之前在提升开发体验这一章中有提到过一点，<code>style-loader</code>用于将<code>css-loader</code>编译出来的代码转为<code>js</code>代码并写入<code>js</code>文件中，所以在这里，我们需要用<code>mini-css-extract-plugin</code>中的<code>loader</code>去替换掉<code>style-loader</code>，让它写入单独的<code>css</code>文件而不是js文件中:</li></ol><blockquote><p>我们去到<code>build/rules/styleRules.js</code>中，将原本的<code>style-loader</code>全都替换成<code>mini-css-extract-plugin</code>的<code>loader</code>(这一步可以进行开发环境和生产环境的区分，在文章中不进行区分</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f94f074b032" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f95243b1af2" alt=""></p><ol start="4"><li>经过上面的步骤，我们可以打包进行测试: 运行<code>npm run build</code>可以发现打包结果中<code>css</code>文件已经进行了分离</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f95246e0168" alt=""></p><blockquote><p>而在打包出来的<code>index.html</code>中也可以发现这个<code>css</code>文件被引入了</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f9525da2e2b" alt=""></p><blockquote><p>最后我们再在打包路径中将打包出来的<code>js</code>文件用<code>js</code>文件夹包裹起来即可</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f9525f9c958" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f952c7c1a74" alt=""></p><h2 id="4-3-修改html-webpack-plugin配置项"><a href="#4-3-修改html-webpack-plugin配置项" class="headerlink" title="4.3 修改html-webpack-plugin配置项"></a>4.3 修改<code>html-webpack-plugin</code>配置项</h2><blockquote><p>这一步主要用于压缩打包出来的<code>index.html</code>文件，但是单页面应用的话<code>html</code>内容其实不多，所以做不做也差不多，在本文章中也只是做个介绍:</p></blockquote><ol><li>首先在<code>html-webpack-plugin</code>中利用的是<code>html-minifier</code>来做压缩工作的，所以详细配置点击进去看即可，常用的如下</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f95327fdfb4" alt=""></p><ol start="2"><li>第二个需要提一下则是<code>inject</code>这个配置项，该项指定资源如何注入，我们直接使用默认的<code>true</code>即可，他会将<code>js</code>资源注入到<code>&lt;body&gt;</code>标签的底部，如果要注入到头部填写<code>head</code>即可</li></ol><h2 id="4-4-代码分离和按需加载"><a href="#4-4-代码分离和按需加载" class="headerlink" title="4.4 代码分离和按需加载"></a>4.4 代码分离和按需加载</h2><blockquote><p>这一步和下一步都是在进行代码的拆分，考虑的是如果所有文件都塞进一个<code>js</code>文件中，会导致这个<code>js</code>文件体积臃肿，而单页面应用的所有构建又是依赖于这个<code>js</code>文件，所以需要进行代码分离，只加载当前页面需要构建的<code>js</code>文件。通常来说，我们会根据<code>react-router</code>分的页面来进行代码分离，再用<code>react-loadable</code>进行分割出来的代码的异步加载(当然你也可以将所有组件都进行代码分离然后异步加载)。所以在这里我们先利用<code>react-router</code>分两个页面home和page出来</p></blockquote><ol><li>首先我们安装<code>react-router: npm install -S react-router-dom</code>，然后在<code>src/containers/views</code>中新建<code>Home</code>和<code>Page</code>组件</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f955223fdb1" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f955498f237" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f955a218dfa" alt=""></p><ol start="2"><li>接着安装<code>react-loadable: npm install -S react-loadable</code>, 然后在<code>src/containers/shared</code>中新建<code>App</code>组件</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f956605e8a3" alt=""></p><blockquote><p>之后在里面的<code>index.tsx</code>中引用<code>react-router</code>和<code>react-loadable</code>进行组件按需加载: 当然不要忘了使用<code>react-hot-loader</code></p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f957819d10f" alt=""></p><blockquote><p>这一步需要注意的是，<code>Loadable</code>这个函数中的<code>loading</code>参数是必须有的，至于如何使用可以自行参考<code>react-loadable</code>的<code>github</code>链接</p></blockquote><ol start="3"><li>这个时候去到页面看一下：在<code>/</code>路径下，没有加载<code>page.js</code>这个文件，而切换到<code>/page</code>路径则会加载<code>page.js</code>文件，这个时候按需加载就完成了:</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f95831e4bd4" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f958db827e0" alt=""></p><ol start="4"><li>最后我们观察一下打包后的<code>js</code>文件可以发现已经进行了分离</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f9592077596" alt=""></p><h2 id="4-5-添加optimization"><a href="#4-5-添加optimization" class="headerlink" title="4.5 添加optimization"></a>4.5 添加<code>optimization</code></h2><blockquote><p><code>optimization</code>是<code>webpack4+</code>版本中新出的配置项，这个配置项的功能主要是进行代码压缩，优化。在本节中，我们需要将用到的处于<code>node_modules</code>中的第三方代码进行分离，在这里主要用到的是两个配置项<code>optimization.runtimeChunk</code>和<code>optimization.splitChunks</code>，其中<code>runtimeChunk</code>用于生成维系各各代码块关系的代码，<code>splitChunks</code>则用于指定需要进行分块的代码，和分块后文件名</p></blockquote><ol><li>我们去到<code>build</code>目录下，新建<code>optimization.js</code>，并添加如下代码</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f95b234dd4b" alt=""></p><blockquote><p>然后在<code>webpack.config.js</code>中引入这个配置</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f95bd023c85" alt=""></p><ol start="2"><li>最后我们打包试试看可以发现第三方代码都被打包进<code>vendor.js</code>文件中了</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f95bd4ac283" alt=""></p><blockquote><p>你可以通过比对在添加<code>optimization</code>之前和之后打包出来的<code>app.js</code>文件来看出效果</p></blockquote><h2 id="4-6-代码压缩"><a href="#4-6-代码压缩" class="headerlink" title="4.6 代码压缩"></a>4.6 代码压缩</h2><blockquote><p>我们主要是做<code>js</code>和<code>css</code>的代码压缩和优化</p></blockquote><ol><li>在上面阶段中，我们打包出来的<code>js</code>代码是已经经过压缩的</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f95dad8cc4a" alt=""></p><blockquote><p>所以在这个阶段我们可以利用<code>uglifyjs-webpack-plugin</code>进行一些压缩优化:<br>首先我们需要安装<code>npm install -D uglifyjs-webpack-plugin</code>，然后去到<code>build/optimization.js</code>中添加如下代码即可，具体的优化见代码</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f95e8adf639" alt=""></p><blockquote><p>PS: 这里有一个点需要注意，在<code>uglifyjs-webpack-plugin</code>这个插件中，如果是<code>2.x</code>版本的话是不支持<code>es6</code>规范的，所以建议安装<code>1.x</code>版本，而我这里的版本是:</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f95f0555484" alt=""></p><ol start="2"><li>然后我们进行<code>css</code>代码的压缩，这里需要使用到<code>optimize-css-assets-webpack-plugin</code>插件:<code>npm install -D optimize-css-assets-webpack-plugin</code>。<br>我们先去<code>Home</code>组件中随意添加一个样式并使用它</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f960309fb62" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f961b48fbd1" alt=""></p><blockquote><p>然后再去到<code>build/optimization.js</code>添加如下代码:</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f96298993ed" alt=""></p><blockquote><p>具体的插件使用方式可以自行上<code>github</code>查看该插件。 最后查看打包出来后的<code>css</code>代码:</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f962dc1fe47" alt=""></p><blockquote><p>到现在压缩代码步骤也做完了，最后将介绍一下<code>webpack.externals</code>这个选项</p></blockquote><h2 id="4-7-关于externals"><a href="#4-7-关于externals" class="headerlink" title="4.7 关于externals"></a>4.7 关于<code>externals</code></h2><blockquote><p><code>webpack.externals</code>配置项用于在构建过程中忽略一些常用包的集成，从而降低构建时间和打包后的包大小，它的配置也很简单，在本章中只做简单介绍:在本项目中，我们可以将<code>react</code>和<code>react-dom</code>添加进<code>externals</code>中，然后在<code>html</code>模板中引入它们的外部链接:</p></blockquote><ol><li>我们先去到<code>webpack.config.js</code>中，添加<code>externals</code>选项，并且把<code>react</code>和<code>react-dom</code>添加进去</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f9644d33821" alt=""></p><blockquote><p>这个配置项接收的是一个对象(其他形式请自行查阅<code>webpack</code>文档)，对象的键是指<code>webapck</code>在获取这个模块时候<code>require</code>时候的参数，而对应的值则是标明你打算将这个模块挂载的变量名，这里是挂载在<code>window</code>对象中的</p></blockquote><ol start="2"><li>去到<code>build/tpl/index.html</code>中，引入<code>cdn</code>中<code>react</code>和<code>react-dom</code>的链接</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f9658bd182f" alt=""></p><ol start="3"><li>重启项目，可以发现在<code>npm run dev</code>中能够正常使用，并且也已经引入了两者的外部资源</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f9661413f04" alt=""></p><ol start="4"><li>最后我们来对比一下打包后模块占用情况</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f966474b96f" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f9686f0e243" alt=""></p><blockquote><p>再来对比一下两者打包出来的包体积大小</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f969e86d5c4" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f96a92a2402" alt=""></p><h1 id="五、团队规范"><a href="#五、团队规范" class="headerlink" title="五、团队规范"></a>五、团队规范</h1><blockquote><p>这篇文章的每一步都基于<code>vscode</code>这款编辑器，如果你使用的不是<code>vscode</code>，那么就需要自行集成相关插件及其配置。该文章只是简单介绍各各代码检测的流程，至于配置项则需要读者自行前往对应的<code>lint</code>官网自己查看、配置需要的。</p></blockquote><p><strong>在这块中我们需要做的如下</strong>:</p><ul><li>使用<code>tslint</code>做代码检测</li><li>使用<code>stylelint</code>做代码检测</li><li>添加<code>npm script</code>进行检测</li><li>使用<code>prettier</code>进行代码格式化</li><li>使用<code>pre-commit</code></li></ul><h2 id="5-1-使用tslint进行代码检测"><a href="#5-1-使用tslint进行代码检测" class="headerlink" title="5.1 使用tslint进行代码检测"></a>5.1 使用tslint进行代码检测</h2><blockquote><p>我们的项目因为大量使用<code>typescript</code>，所以使用的是<code>tslint</code>检测工具，如果在你的项目中没有用到<code>typescript</code>，那么请使用<code>eslint</code></p></blockquote><ol><li>首先我们需要在<code>vscode</code>中安装插件:</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f9dff505830" alt=""></p><blockquote><p>然后在项目中安装<code>npm install -D tslint</code>。此外，因为我们有大量的<code>.tsx</code>文件，所以还需要<code>npm install -D tslint-react</code>来指定针对<code>.tsx</code>语法的限制</p></blockquote><ol start="2"><li>接着在根目录下新建<code>tsling.json</code>文件，该文件用于写<code>tslint</code>配置文件:</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f9dffb7feb2" alt=""></p><ol start="3"><li>在<code>tslint.json</code>中写入配置，配置项参考请<a href="https://palantir.github.io/tslint/rules/" target="_blank" rel="noopener">点击这里</a></li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f9dffa72149" alt=""></p><blockquote><p>这份配置项中，上面的<code>extends</code>是指<code>tslint</code>的扩展，第一个扩展是稳定且常规的<code>tsling</code>检测标准，第二个则是针对<code>.tsx</code>文件做的检测</p></blockquote><ol start="4"><li>测试一下是否生效: 我们将<code>no-console</code>改为<code>true</code>测试一下</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f9dff914b71" alt=""></p><blockquote><p>然后在组件中写一个<code>console.log</code>就可以知道这份配置表已经生效</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f9e0040ce6a" alt=""></p><h2 id="5-2-使用stylelint做代码检测"><a href="#5-2-使用stylelint做代码检测" class="headerlink" title="5.2 使用stylelint做代码检测"></a>5.2 使用<code>stylelint</code>做代码检测</h2><ol><li>首先，在<code>vscode</code>安装<code>stylelint</code>这个插件，该插件可以对<code>css</code>、<code>less</code>、<code>scss</code>等类型的样式表代码进行格式和样式书写顺序上的检测:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D stylelint</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f9e005118f4" alt=""></p><ol start="2"><li>我们在根目录下创建<code>.stylelintrc.js</code>文件，然后安装官方推荐的配置<code>stylelint-config-standard</code>以及针对<code>scss</code>代码类型检测的插件<code>stylelint-scss</code>:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D stylelint-config-standard stylelint-scss</span><br></pre></td></tr></table></figure><ol start="3"><li>然后在<code>.stylelintrc.js</code>文件中写入配置项</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f9e37e5534d" alt=""></p><ol start="4"><li>但是这时候针对<code>scss</code>代码的检测还是有问题的，它不能识别<code>scss</code>中例如<code>@mixin</code>、<code>@include</code>之类的语法:</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f9e37d61834" alt=""></p><p>所以还需要手动写一些规则覆盖掉针对这类语法的检测使其不报错:</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f9e3eaf28fa" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f9e4c7fee18" alt=""></p><h2 id="5-3-添加npm-script进行检测"><a href="#5-3-添加npm-script进行检测" class="headerlink" title="5.3 添加npm script进行检测"></a>5.3 添加<code>npm script</code>进行检测</h2><blockquote><p>这一步主要利用<code>tslint</code>和<code>stylelint</code>附带的命令行命令检测项目中存在的代码规范问题，然后输出到终端查看</p></blockquote><ol><li>去到<code>package.json</code>中，在<code>scripts</code>中添加如下命令</li></ol><blockquote><p>这条命令既检查<code>.tsx</code>文件也检查<code>.scss</code>文件</p></blockquote><ol start="2"><li>然后再终端中输入一次，就能看到报错如下</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f9e60035ebb" alt=""></p><p>然后定位到文件中去修改即可</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f9e61e4d27e" alt=""></p><h2 id="5-4-使用prettier进行代码格式化"><a href="#5-4-使用prettier进行代码格式化" class="headerlink" title="5.4 使用prettier进行代码格式化"></a>5.4 使用<code>prettier</code>进行代码格式化</h2><blockquote><p>除了上一节中手动定位并修改不规范的代码外，我们还可以依赖于<code>vscode</code>的插件来进行符合我们规范的代码格式化，这个插件推荐使用<code>prettier</code></p></blockquote><ol><li>首先在<code>vscode</code>中安装这个插件</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f9e6ad151e7" alt=""></p><ol start="2"><li>然后去到用户设置表中,进到工作区设置进行配置，下图是该模板的配置，当然你也可以自行配置需要的设置</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f9e6eae3e6f" alt=""></p><ol start="3"><li>回到刚才错误的地方，只要我们一保存就会自动格式化成正确的</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f9e7581ebae" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f9e8cf71d5d" alt=""></p><h2 id="5-5-使用pre-commit"><a href="#5-5-使用pre-commit" class="headerlink" title="5.5 使用pre-commit"></a>5.5 使用<code>pre-commit</code></h2><blockquote><p>在前面的篇幅中，我们有将<code>lint</code>命令添加进<code>npm script</code>中，但是这个命令如果要自己去运行我想很多人都会忘记，结果就会导致可能有不符合规范的代码被上传到远端代码仓库中。这种情况下我们可以做<code>pre-commit</code>进行代码强制检测，也就是在<code>git commit</code>之前进行一次代码检测，不符合规范不让<code>commit</code>。<br>实现这个功能我们可以安装<code>husky</code>这个插件<code>npm install -D husky</code>，然后在<code>npm script</code>中添加命令就好了</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619f9e9472379a" alt=""></p><h1 id="六、代码"><a href="#六、代码" class="headerlink" title="六、代码"></a>六、代码</h1><blockquote><p>完整代码示例  <a href="https://github.com/poetries/ts-react-tpl" target="_blank" rel="noopener">https://github.com/poetries/ts-react-tpl</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;整理于网络&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、项目初始化&quot;&gt;&lt;a href=&quot;#一、项目初始化&quot; class=&quot;headerlink&quot; title=&quot;一、项目初始化&quot;&gt;&lt;/a&gt;一、项目初始化&lt;/h1&gt;&lt;h2 id=&quot;1-1-创
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="React" scheme="http://blog.poetries.top/tags/React/"/>
    
      <category term="Typescript" scheme="http://blog.poetries.top/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>Typescript总结篇（二）</title>
    <link href="http://blog.poetries.top/2018/12/30/ts-summary/"/>
    <id>http://blog.poetries.top/2018/12/30/ts-summary/</id>
    <published>2018-12-30T04:30:14.000Z</published>
    <updated>2019-01-07T08:48:58.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1-1-什么是-TypeScript"><a href="#1-1-什么是-TypeScript" class="headerlink" title="1.1 什么是 TypeScript"></a>1.1 什么是 TypeScript</h2><ul><li><code>TypeScript</code> 是 <code>JavaScript</code> 的一个超集，主要提供了类型系统和对 <code>ES6</code>的支持</li><li><code>TypeScript</code> 是由微软开发的一款开源的编程语言</li><li><code>TypeScript</code> 是 <code>Javascript</code> 的超级，遵循最新的 <code>ES6</code>、<code>Es5</code> 规范。<code>TypeScript</code> 扩展了 <code>JavaScript</code> 的语法</li><li><code>TypeScript</code> 更像后端 <code>java</code>、<code>C#</code>这样的面向对象语言可以让 <code>js</code> 开发大型企业项目</li></ul><h2 id="1-2-为什么选择-TypeScript"><a href="#1-2-为什么选择-TypeScript" class="headerlink" title="1.2 为什么选择 TypeScript"></a>1.2 为什么选择 TypeScript</h2><blockquote><p><code>Typescript</code>和<code>es6</code>、<code>es5</code>关系</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-167f327f2876c608.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>TypeScript 增加了代码的可读性和可维护性</strong></p><ul><li>类型系统实际上是最好的文档，大部分的函数看看类型的定义就可以知道如何使用了</li><li>可以在编译阶段就发现大部分错误，这总比在运行时候出错好</li><li>增强了编辑器和 <code>IDE</code> 的功能，包括代码补全、接口提示、跳转到定义、重构等</li></ul><p><strong>TypeScript 非常包容</strong></p><ul><li><code>TypeScript</code> 是 <code>JavaScript</code> 的超集，<code>.js</code> 文件可以直接重命名为 <code>.ts</code> 即可</li><li>即使不显式的定义类型，也能够自动做出类型推论</li><li>可以定义从简单到复杂的几乎一切类型</li><li>即使 <code>TypeScript</code> 编译报错，也可以生成 <code>JavaScript</code> 文件</li><li>兼容第三方库，即使第三方库不是用 <code>TypeScript</code> 写的，也可以编写单独的类型文件供 <code>TypeScript</code> 读取</li></ul><p><strong>TypeScript 拥有活跃的社区</strong></p><ul><li>大部分第三方库都有提供给 <code>TypeScript</code> 的类型定义文件</li><li><code>Google</code> 开发的<code>Angular2</code> 就是使用 <code>TypeScript</code> 编写的</li><li><code>TypeScript</code> 拥抱了 <code>ES6</code> 规范，也支持部分 <code>ESNext</code> 草案的规范</li><li>最新的 <code>Vue</code> 、<code>React</code> 也可以集成 <code>TypeScript</code></li></ul><p><strong>TypeScript 的缺点</strong></p><ul><li>有一定的学习成本，需要理解接口（<code>Interfaces</code>）、泛型（<code>Generics</code>）、类（<code>Classes</code>）、枚举类型（<code>Enums</code>）等前端工程师可能不是很熟悉的概念</li><li>短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，<code>TypeScript</code> 能够减少其维护成本</li><li>集成到构建流程需要一些工作量</li><li>可能和一些库结合的不是很完美</li></ul><h2 id="1-3-安装-TypeScript"><a href="#1-3-安装-TypeScript" class="headerlink" title="1.3 安装 TypeScript"></a>1.3 安装 TypeScript</h2><p><strong>typescript 安装</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i typescript -g</span><br></pre></td></tr></table></figure><blockquote><p>全局安装完成后，我们新建一个<code>hello.ts</code>的<code>ts</code>文件</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.ts内容</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">"poet"</span></span><br></pre></td></tr></table></figure><blockquote><p>接下来我们在命令行输入<code>tsc hello.ts</code>来编译这个<code>ts</code>文件，然后会在同级目录生成一个编译好了的<code>hello.js</code>文件</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.js内容</span></span><br><span class="line"><span class="keyword">var</span> = <span class="string">"poet"</span></span><br></pre></td></tr></table></figure><blockquote><p>那么我们每次都要输<code>tsc hello.ts</code>命令来编译，这样很麻烦，能否让它自动编译？答案是可以的，使用<code>vscode</code>来开发，需要配置一下<code>vscode</code>就可以。</p></blockquote><blockquote><p>首先我们在命令行执行<code>tsc --init</code>来生成配置文件，然后我们在目录下看到生成了一个<code>tsconfig.json</code>文件</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-064a181236aedb92.png" alt="image.png"></p><blockquote><p>这个<code>json</code>文件里有很多选项</p></blockquote><ul><li><code>target</code>是选择编译到什么语法</li><li><code>module</code>则是模块类型</li><li><code>outDir</code>则是输出目录，可以指定这个参数到指定目录</li></ul><blockquote><p>更多细节 <a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/tsconfig.json.html" target="_blank" rel="noopener">https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/tsconfig.json.html</a></p></blockquote><blockquote><p>接下来我们需要开启监控了，在<code>vscode</code>任务栏中</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-da2ea080476546f2.png" alt="image.png"></p><h2 id="1-4-Hello-TypeScript"><a href="#1-4-Hello-TypeScript" class="headerlink" title="1.4 Hello TypeScript"></a>1.4 Hello TypeScript</h2><blockquote><p>将以下代码复制到 <code>hello.ts</code> 中</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">person: string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, '</span> + person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="string">'poetries'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sayHello(user));</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc hello.ts</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这时候会生成一个编译好的文件 hello.js：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, '</span> + person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> user = <span class="string">'poetries'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sayHello(user));</span><br></pre></td></tr></table></figure><blockquote><p><code>TypeScript</code> 中，使用 <code>:</code> 指定变量的类型，<code>:</code> 的前后有没有空格都可以</p></blockquote><ul><li><code>TypeScript</code> 只会进行静态检查，如果发现有错误，编译的时候就会报错</li><li><code>TypeScript</code> 编译的时候即使报错了，还是会生成编译结果，我们仍然可以使用这个编译之后的文件</li></ul><h1 id="二、基础"><a href="#二、基础" class="headerlink" title="二、基础"></a>二、基础</h1><h2 id="2-1-原始数据类型"><a href="#2-1-原始数据类型" class="headerlink" title="2.1 原始数据类型"></a>2.1 原始数据类型</h2><blockquote><p><code>JavaScript</code> 的类型分为两种：原始数据类型（<code>Primitive data types</code>）和对象类型（<code>Object types</code>）。</p></blockquote><ul><li>原始数据类型包括：<code>布尔值</code>、<code>数值</code>、<code>字符串</code>、<code>null</code>、<code>undefined</code> 以及 <code>ES6</code>中的新类型 <code>Symbol</code>。</li></ul><blockquote><p>本节主要介绍前五种原始数据类型在 <code>TypeScript</code> 中的应用</p></blockquote><h3 id="2-1-1-布尔值"><a href="#2-1-1-布尔值" class="headerlink" title="2.1.1 布尔值"></a>2.1.1 布尔值</h3><blockquote><p>布尔值是最基础的数据类型，在 <code>TypeScript</code> 中，使用 <code>boolean</code> 定义布尔值类型</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isDone: boolean = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译通过</span></span><br><span class="line"><span class="comment">// 后面约定，未强调编译错误的代码片段，默认为编译通过</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，使用构造函数 <code>Boolean</code> 创造的对象不是布尔值</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> createdByNewBoolean: boolean = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(1,5): error TS2322: Type 'Boolean' is not assignable to type 'boolean'.</span></span><br><span class="line"><span class="comment">// 后面约定，注释中标出了编译报错的代码片段，表示编译未通过</span></span><br></pre></td></tr></table></figure><ul><li>事实上 <code>new Boolean()</code> 返回的是一个 <code>Boolean</code> 对象：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let createdByNewBoolean: Boolean = new Boolean(1);</span><br></pre></td></tr></table></figure><ul><li>直接调用 <code>Boolean</code> 也可以返回一个 <code>boolean</code> 类型：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let createdByBoolean: boolean = Boolean(1);</span><br></pre></td></tr></table></figure><ul><li>在 <code>TypeScript</code> 中，<code>boolean</code>是 <code>JavaScript</code> 中的基本类型，而 <code>Boolean</code> 是 <code>JavaScript</code>中的构造函数。其他基本类型（除了 <code>null</code> 和 <code>undefined</code>）一样</li></ul><h3 id="2-1-2-数值"><a href="#2-1-2-数值" class="headerlink" title="2.1.2 数值"></a>2.1.2 数值</h3><blockquote><p>使用 <code>number</code> 定义数值类型</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decLiteral: number = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> hexLiteral: number = <span class="number">0xf00d</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 中的二进制表示法</span></span><br><span class="line"><span class="keyword">let</span> binaryLiteral: number = <span class="number">0b1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 中的八进制表示法</span></span><br><span class="line"><span class="keyword">let</span> octalLiteral: number = <span class="number">0o744</span>;</span><br><span class="line"><span class="keyword">let</span> notANumber: number = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> infinityNumber: number = <span class="literal">Infinity</span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译结果：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> decLiteral = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">var</span> hexLiteral = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="comment">// ES6 中的二进制表示法</span></span><br><span class="line"><span class="keyword">var</span> binaryLiteral = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// ES6 中的八进制表示法</span></span><br><span class="line"><span class="keyword">var</span> octalLiteral = <span class="number">484</span>;</span><br><span class="line"><span class="keyword">var</span> notANumber = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">var</span> infinityNumber = <span class="literal">Infinity</span>;</span><br></pre></td></tr></table></figure><blockquote><p>其中 <code>0b101</code>0 和 <code>0o744</code>是 <code>ES6</code> 中的二进制和八进制表示法，它们会被编译为十进制数字</p></blockquote><h3 id="2-1-3-字符串"><a href="#2-1-3-字符串" class="headerlink" title="2.1.3 字符串"></a>2.1.3 字符串</h3><blockquote><p>使用 <code>string</code> 定义字符串类型：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myName: string = <span class="string">'Tom'</span>;</span><br><span class="line"><span class="keyword">let</span> myAge: number = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板字符串</span></span><br><span class="line"><span class="keyword">let</span> sentence: string = <span class="string">`Hello, my name is <span class="subst">$&#123;myName&#125;</span>.</span></span><br><span class="line"><span class="string">I'll be <span class="subst">$&#123;myAge + <span class="number">1</span>&#125;</span> years old next month.`</span>;</span><br></pre></td></tr></table></figure><h3 id="2-1-4-空值"><a href="#2-1-4-空值" class="headerlink" title="2.1.4 空值"></a>2.1.4 空值</h3><blockquote><p><code>JavaScript</code> 没有空值（<code>Void</code>）的概念，在 <code>TypeScript</code> 中，可以用 <code>void</code> 表示没有任何返回值的函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alertName</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    alert(<span class="string">'My name is Tom'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>声明一个 <code>void</code> 类型的变量没有什么用，因为你只能将它赋值为 <code>undefined</code>和 <code>null</code>：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let unusable: void = undefined;</span><br></pre></td></tr></table></figure><h3 id="2-1-5-Null-和-Undefined"><a href="#2-1-5-Null-和-Undefined" class="headerlink" title="2.1.5 Null 和 Undefined"></a>2.1.5 Null 和 Undefined</h3><blockquote><p>在 <code>TypeScript</code> 中，可以使用 <code>null</code> 和 <code>undefined</code>来定义这两个原始数据类型：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><blockquote><p><code>undefined</code> 类型的变量只能被赋值为 <code>undefined</code>，<code>null</code> 类型的变量只能被赋值为 <code>null</code></p></blockquote><ul><li>与 <code>void</code> 的区别是，<code>undefined</code>和 <code>null</code> 是所有类型的子类型。也就是说 <code>undefined</code> 类型的变量，可以赋值给 <code>number</code> 类型的变量</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样不会报错</span></span><br><span class="line"><span class="keyword">let</span> num: number = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样也不会报错</span></span><br><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> num: number = u;</span><br></pre></td></tr></table></figure><blockquote><p>而 <code>void</code> 类型的变量不能赋值给 <code>number</code> 类型的变量：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="keyword">void</span>;</span><br><span class="line"><span class="keyword">let</span> num: number = u;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,5): error TS2322: Type 'void' is not assignable to type 'number'.</span></span><br></pre></td></tr></table></figure><h2 id="2-2-任意值Any"><a href="#2-2-任意值Any" class="headerlink" title="2.2 任意值Any"></a>2.2 任意值Any</h2><blockquote><p>如果是一个普通类型，在赋值过程中改变类型是不被允许的</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: string = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.</span></span><br></pre></td></tr></table></figure><blockquote><p>但如果是 <code>any</code> 类型，则允许被赋值为任意类型。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: any = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p><strong>任意值的属性和方法</strong></p><p>在任意值上访问任何属性都是允许的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anyThing: any = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(anyThing.myName);</span><br><span class="line"><span class="built_in">console</span>.log(anyThing.myName.firstName);</span><br></pre></td></tr></table></figure><p><strong>也允许调用任何方法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anyThing: any = <span class="string">'Tom'</span>;</span><br><span class="line"></span><br><span class="line">anyThing.setName(<span class="string">'Jerry'</span>);</span><br><span class="line">anyThing.setName(<span class="string">'Jerry'</span>).sayHello();</span><br><span class="line">anyThing.myName.setFirstName(<span class="string">'Cat'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值</p></blockquote><p><strong>未声明类型的变量</strong></p><blockquote><p>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> something;</span><br><span class="line">something = <span class="string">'seven'</span>;</span><br><span class="line">something = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">something.setName(<span class="string">'Tom'</span>);</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> something: any;</span><br><span class="line">something = <span class="string">'seven'</span>;</span><br><span class="line">something = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">something.setName(<span class="string">'Tom'</span>);</span><br></pre></td></tr></table></figure><h2 id="2-3-类型推论"><a href="#2-3-类型推论" class="headerlink" title="2.3 类型推论"></a>2.3 类型推论</h2><blockquote><p>如果没有明确的指定类型，那么 <code>TypeScript</code> 会依照类型推论（<code>Type Inference</code>）的规则推断出一个类型</p></blockquote><p><strong>什么是类型推论</strong></p><p>以下代码虽然没有指定类型，但是会在编译的时候报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let myFavoriteNumber = &apos;seven&apos;;</span><br><span class="line">myFavoriteNumber = 7;</span><br><span class="line"></span><br><span class="line">// index.ts(2,1): error TS2322: Type &apos;number&apos; is not assignable to type &apos;string&apos;.</span><br></pre></td></tr></table></figure><p>事实上，它等价于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let myFavoriteNumber: string = &apos;seven&apos;;</span><br><span class="line">myFavoriteNumber = 7;</span><br><span class="line"></span><br><span class="line">// index.ts(2,1): error TS2322: Type &apos;number&apos; is not assignable to type &apos;string&apos;.</span><br></pre></td></tr></table></figure><p><code>TypeScript</code> 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论</p><p><strong>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber;</span><br><span class="line"></span><br><span class="line">myFavoriteNumber = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><h2 id="2-4-联合类型"><a href="#2-4-联合类型" class="headerlink" title="2.4 联合类型"></a>2.4 联合类型</h2><blockquote><p>联合类型（<code>Union Types</code>）表示取值可以为多种类型中的一种</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单例子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myFavoriteNumber: string | number;</span><br><span class="line">myFavoriteNumber = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: string | number;</span><br><span class="line">myFavoriteNumber = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,1): error TS2322: Type 'boolean' is not assignable to type 'string | number'.</span></span><br><span class="line"><span class="comment">//   Type 'boolean' is not assignable to type 'number'.</span></span><br></pre></td></tr></table></figure><ul><li>联合类型使用 <code>|</code> 分隔每个类型。</li><li>这里的 <code>let myFavoriteNumber: string | number</code> 的含义是，允许 <code>myFavoriteNumber</code> 的类型是 <code>string</code> 或者 <code>number</code>，但是不能是其他类型</li></ul><p><strong>访问联合类型的属性或方法</strong></p><blockquote><p>当 <code>TypeScript</code> 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">something: string | number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> something.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// length 不是 string 和 number 的共有属性，所以会报错</span></span><br><span class="line"><span class="comment">// index.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'.</span></span><br><span class="line"><span class="comment">//   Property 'length' does not exist on type 'number'.</span></span><br></pre></td></tr></table></figure><blockquote><p>访问 <code>string</code> 和 <code>number</code> 的共有属性是没问题的</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getString</span>(<span class="params">something: string | number</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> something.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: string | number;</span><br><span class="line">myFavoriteNumber = <span class="string">'seven'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myFavoriteNumber.length); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myFavoriteNumber.length); <span class="comment">// 编译时报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(5,30): error TS2339: Property 'length' does not exist on type 'number'.</span></span><br></pre></td></tr></table></figure><ul><li>上例中，第二行的 <code>myFavoriteNumber</code> 被推断成了 <code>string</code>，访问它的 <code>length</code> 属性不会报错。</li><li>而第四行的 <code>myFavoriteNumber</code> 被推断成了 <code>number</code>，访问它的 <code>length</code> 属性时就报错了</li></ul><h2 id="2-5-对象的类型——接口"><a href="#2-5-对象的类型——接口" class="headerlink" title="2.5 对象的类型——接口"></a>2.5 对象的类型——接口</h2><h3 id="2-5-1-简单例子"><a href="#2-5-1-简单例子" class="headerlink" title="2.5.1 简单例子"></a>2.5.1 简单例子</h3><blockquote><p>在 <code>TypeScript</code> 中，我们使用接口（<code>Interfaces</code>）来定义对象的类型</p></blockquote><p><strong>什么是接口</strong></p><ul><li>在面向对象语言中，接口（<code>Interfaces</code>）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（<code>classes</code>）去实现（<code>implements</code>）。</li><li><code>TypeScript</code> 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（<code>Shape</code>）」进行描述。</li></ul><p>接口一般首字母大写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    age: <span class="number">25</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>上面的例子中，我们定义了一个接口 <code>Person</code>，接着定义了一个变量 <code>tom</code>，它的类型是 <code>Person</code>。这样，我们就约束了 <code>tom</code> 的形状必须和接口 <code>Person</code> 一致</p></blockquote><p><strong>定义的变量比接口少了一些属性是不允许的</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(6,5): error TS2322: Type '&#123; name: string; &#125;' is not assignable to type 'Person'.</span></span><br><span class="line"><span class="comment">//   Property 'age' is missing in type '&#123; name: string; &#125;'.</span></span><br></pre></td></tr></table></figure><p><strong>多一些属性也是不允许的</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    age: <span class="number">25</span>,</span><br><span class="line">    gender: <span class="string">'male'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(9,5): error TS2322: Type '&#123; name: string; age: number; gender: string; &#125;' is not assignable to type 'Person'.</span></span><br><span class="line"><span class="comment">//   Object literal may only specify known properties, and 'gender' does not exist in type 'Person'.</span></span><br></pre></td></tr></table></figure><blockquote><p>可见，赋值的时候，变量的形状必须和接口的形状保持一致。</p></blockquote><h3 id="2-5-2-可选属性"><a href="#2-5-2-可选属性" class="headerlink" title="2.5.2 可选属性"></a>2.5.2 可选属性</h3><blockquote><p>有时我们希望不要完全匹配一个形状，那么可以用可选属性</p></blockquote><p>可选属性的含义是该属性可以不存在</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    age: <span class="number">25</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-5-3-任意属性"><a href="#2-5-3-任意属性" class="headerlink" title="2.5.3 任意属性"></a>2.5.3 任意属性</h3><blockquote><p>有时候我们希望一个接口允许有任意的属性，可以使用如下方式</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    gender: <span class="string">'male'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>使用 <code>[propName: string]</code> 定义了任意属性取 <code>string</code> 类型的值</li><li>需要注意的是，<strong>一旦定义了任意属性，那么确定属性和可选属性都必须是它的子属性</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    age: <span class="number">25</span>,</span><br><span class="line">    gender: <span class="string">'male'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(3,5): error TS2411: Property 'age' of type 'number' is not assignable to string index type 'string'.</span></span><br><span class="line"><span class="comment">// index.ts(7,5): error TS2322: Type '&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;' is not assignable to type 'Person'.</span></span><br><span class="line"><span class="comment">//   Index signatures are incompatible.</span></span><br><span class="line"><span class="comment">//     Type 'string | number' is not assignable to type 'string'.</span></span><br><span class="line"><span class="comment">//       Type 'number' is not assignable to type 'string'.</span></span><br></pre></td></tr></table></figure><ul><li>上例中，任意属性的值允许是 <code>string</code>，但是可选属性 <code>age</code> 的值却是 <code>number</code>，<code>number</code>不是 <code>string</code> 的子属性，所以报错了。</li><li>另外，在报错信息中可以看出，此时 <code>{ name: &#39;Tom&#39;, age: 25, gender: &#39;male&#39; }</code>的类型被推断成了 <code>{ [x: string]: string | number; name: string; age: number; gender: string; }</code>，这是联合类型和接口的结合</li></ul><h3 id="2-5-4-只读属性"><a href="#2-5-4-只读属性" class="headerlink" title="2.5.4 只读属性"></a>2.5.4 只读属性</h3><blockquote><p>有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 <code>readonly</code>定义只读属性</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    readonly id: number;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    id: <span class="number">89757</span>,</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    gender: <span class="string">'male'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">tom.id = <span class="number">9527</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(14,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property.</span></span><br></pre></td></tr></table></figure><blockquote><p>上例中，使用 <code>readonly</code> 定义的属性 <code>id</code> 初始化后，又被赋值了，所以报错了</p></blockquote><p><strong>注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    readonly id: number;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    gender: <span class="string">'male'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">tom.id = <span class="number">89757</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(8,5): error TS2322: Type '&#123; name: string; gender: string; &#125;' is not assignable to type 'Person'.</span></span><br><span class="line"><span class="comment">//   Property 'id' is missing in type '&#123; name: string; gender: string; &#125;'.</span></span><br><span class="line"><span class="comment">// index.ts(13,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property.</span></span><br></pre></td></tr></table></figure><ul><li>上例中，报错信息有两处，第一处是在对 <code>tom</code> 进行赋值的时候，没有给 <code>id</code> 赋值。</li><li>第二处是在给 <code>tom.id</code> 赋值的时候，由于它是只读属性，所以报错了</li></ul><h2 id="2-6-数组的类型"><a href="#2-6-数组的类型" class="headerlink" title="2.6 数组的类型"></a>2.6 数组的类型</h2><blockquote><p>在 <code>TypeScript</code> 中，数组类型有多种定义方式，比较灵活。</p></blockquote><h3 id="2-6-1「类型-方括号」表示法"><a href="#2-6-1「类型-方括号」表示法" class="headerlink" title="2.6.1「类型 + 方括号」表示法"></a>2.6.1「类型 + 方括号」表示法</h3><blockquote><p>最简单的方法是使用「类型 + 方括号」来表示数组：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fibonacci: number[] = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure><blockquote><p>数组的项中不允许出现其他的类型</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fibonacci: number[] = [<span class="number">1</span>, <span class="string">'1'</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(1,5): error TS2322: Type '(number | string)[]' is not assignable to type 'number[]'.</span></span><br><span class="line"><span class="comment">//   Type 'number | string' is not assignable to type 'number'.</span></span><br><span class="line"><span class="comment">//     Type 'string' is not assignable to type 'number'.</span></span><br></pre></td></tr></table></figure><ul><li>上例中，<code>[1, &#39;1&#39;, 2, 3, 5]</code> 的类型被推断为 <code>(number | string)[]</code>，这是联合类型和数组的结合。</li><li>数组的一些方法的参数也会根据数组在定义时约定的类型进行限制</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fibonacci: number[] = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line">fibonacci.push(<span class="string">'8'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,16): error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.</span></span><br></pre></td></tr></table></figure><blockquote><p>上例中，<code>push</code> 方法只允许传入 <code>number</code> 类型的参数，但是却传了一个 <code>string</code> 类型的参数，所以报错了</p></blockquote><h3 id="2-6-2-数组泛型"><a href="#2-6-2-数组泛型" class="headerlink" title="2.6.2 数组泛型"></a>2.6.2 数组泛型</h3><blockquote><p>也可以使用数组泛型（<code>Array Generic</code>）<code>Array&lt;elemType&gt;</code>来表示数组</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fibonacci: <span class="built_in">Array</span>&lt;number&gt; = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure><h3 id="2-6-3-用接口表示数组"><a href="#2-6-3-用接口表示数组" class="headerlink" title="2.6.3 用接口表示数组"></a>2.6.3 用接口表示数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface NumberArray &#123;</span><br><span class="line">    [index: number]: number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fibonacci: NumberArray = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure><blockquote><p><code>NumberArray</code> 表示：只要 <code>index</code> 的类型是 <code>number</code>，那么值的类型必须是 <code>number</code></p></blockquote><h3 id="2-6-4-any-在数组中的应用"><a href="#2-6-4-any-在数组中的应用" class="headerlink" title="2.6.4 any 在数组中的应用"></a>2.6.4 any 在数组中的应用</h3><blockquote><p>一个比较常见的做法是，用 <code>any</code> 表示数组中允许出现任意类型：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: any[] = [<span class="string">'poetries'</span>, <span class="number">22</span>, &#123; <span class="attr">website</span>: <span class="string">'http://blog.poetries.top'</span> &#125;];</span><br></pre></td></tr></table></figure><h3 id="2-6-5-类数组"><a href="#2-6-5-类数组" class="headerlink" title="2.6.5 类数组"></a>2.6.5 类数组</h3><blockquote><p>类数组（<code>Array-like Object</code>）不是数组类型，比如 <code>arguments</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args: number[] = <span class="built_in">arguments</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,7): error TS2322: Type 'IArguments' is not assignable to type 'number[]'.</span></span><br><span class="line"><span class="comment">//   Property 'push' is missing in type 'IArguments'.</span></span><br></pre></td></tr></table></figure><blockquote><p>事实上常见的类数组都有自己的接口定义，如 <code>IArguments</code>, <code>NodeList</code>, <code>HTMLCollection</code> 等：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args: IArguments = <span class="built_in">arguments</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-7-函数的类型"><a href="#2-7-函数的类型" class="headerlink" title="2.7 函数的类型"></a>2.7 函数的类型</h2><h3 id="2-7-1-函数声明"><a href="#2-7-1-函数声明" class="headerlink" title="2.7.1 函数声明"></a>2.7.1 函数声明</h3><blockquote><p>在 <code>JavaScript</code> 中，有两种常见的定义函数的方式——函数声明（<code>Function Declaration</code>）和函数表达式（<code>Function Expression</code>）</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明（Function Declaration）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式（Function Expression）</span></span><br><span class="line"><span class="keyword">let</span> mySum = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>一个函数有输入和输出，要在 <code>TypeScript</code> 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x: number, y: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，输入多余的（或者少于要求的）参数，是不被允许的：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x: number, y: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x: number, y: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.</span></span><br></pre></td></tr></table></figure><h3 id="2-7-2-函数表达式"><a href="#2-7-2-函数表达式" class="headerlink" title="2.7.2 函数表达式"></a>2.7.2 函数表达式</h3><blockquote><p>如果要我们现在写一个对函数表达式（<code>Function Expression</code>）的定义，可能会写成这样</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySum = <span class="function"><span class="keyword">function</span> (<span class="params">x: number, y: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 <code>mySum</code>，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 <code>mySum</code> 添加类型，则应该是这样</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// =&gt;左边 (x: number, y: number) 是输入类型 </span></span><br><span class="line"><span class="comment">// =&gt;右边number是输出类型</span></span><br><span class="line"><span class="keyword">let</span> mySum: <span class="function">(<span class="params">x: number, y: number</span>) =&gt;</span> number = <span class="function"><span class="keyword">function</span> (<span class="params">x: number, y: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意不要混淆了 TypeScript 中的 =&gt; 和 ES6 中的 =&gt;</strong></p><blockquote><p>在 <code>TypeScript</code> 的类型定义中，<code>=&gt;</code> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</p></blockquote><h3 id="2-7-3-用接口定义函数的形状"><a href="#2-7-3-用接口定义函数的形状" class="headerlink" title="2.7.3 用接口定义函数的形状"></a>2.7.3 用接口定义函数的形状</h3><blockquote><p>我们也可以使用接口的方式来定义一个函数需要符合的形状</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface SearchFunc &#123;</span><br><span class="line">    (source: string, <span class="attr">subString</span>: string): boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">source: string, subString: string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> source.search(subString) !== <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意的是，可选参数必须接在必需参数后面。换句话说，可选参数后面不允许再出现必须参数了</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName?: string, lastName: string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (firstName) &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tomcat = buildName(<span class="string">'Tom'</span>, <span class="string">'Cat'</span>);</span><br><span class="line"><span class="keyword">let</span> tom = buildName(<span class="literal">undefined</span>, <span class="string">'Tom'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(1,40): error TS1016: A required parameter cannot follow an optional parameter.</span></span><br></pre></td></tr></table></figure><h3 id="2-7-4-参数默认值"><a href="#2-7-4-参数默认值" class="headerlink" title="2.7.4 参数默认值"></a>2.7.4 参数默认值</h3><blockquote><p>在 <code>ES6</code>中，我们允许给函数的参数添加默认值，<code>TypeScript</code> 会将添加了默认值的参数识别为可选参数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: string, lastName: string = <span class="string">'Cat'</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tomcat = buildName(<span class="string">'Tom'</span>, <span class="string">'Cat'</span>);</span><br><span class="line"><span class="keyword">let</span> tom = buildName(<span class="string">'Tom'</span>);</span><br></pre></td></tr></table></figure><p><strong>此时就不受「可选参数必须接在必需参数后面」的限制了</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: string = <span class="string">'Tom'</span>, lastName: string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tomcat = buildName(<span class="string">'Tom'</span>, <span class="string">'Cat'</span>);</span><br><span class="line"><span class="keyword">let</span> cat = buildName(<span class="literal">undefined</span>, <span class="string">'Cat'</span>);</span><br></pre></td></tr></table></figure><h3 id="2-7-5-剩余参数"><a href="#2-7-5-剩余参数" class="headerlink" title="2.7.5 剩余参数"></a>2.7.5 剩余参数</h3><blockquote><p>ES6 中，可以使用 <code>...rest</code> 的方式获取函数中的剩余参数（<code>rest</code> 参数）</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;</span><br><span class="line">    items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        array.push(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [];</span><br><span class="line">push(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><blockquote><p>事实上，items 是一个数组。所以我们可以用数组的类型来定义它</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array: any[], ...items: any[]</span>) </span>&#123;</span><br><span class="line">    items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        array.push(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [];</span><br><span class="line">push(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><blockquote><p>注意，rest 参数只能是最后一个参数</p></blockquote><h3 id="2-7-6-函数重载"><a href="#2-7-6-函数重载" class="headerlink" title="2.7.6 函数重载"></a>2.7.6 函数重载</h3><ul><li>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。</li></ul><blockquote><p>比如，我们需要实现一个函数 <code>reverse</code>，输入数字 <code>123</code> 的时候，输出反转的数字 <code>321</code>，输入字符串 <code>&#39;hello&#39;</code> 的时候，输出反转的字符串 <code>&#39;olleh&#39;</code></p></blockquote><p><strong>利用联合类型，我们可以这么实现</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: number | string</span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(x.toString().split(<span class="string">''</span>).reverse().join(<span class="string">''</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串</p></blockquote><p><strong>这时，我们可以使用重载定义多个 reverse 的函数类型</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: number</span>): <span class="title">number</span>;</span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">reverse</span>(<span class="params">x: string</span>): <span class="title">string</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">reverse</span>(<span class="params">x: number | string</span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(x.toString().split(<span class="string">''</span>).reverse().join(<span class="string">''</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上例中，我们重复定义了多次函数 <code>reverse</code>，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。</li></ul><blockquote><p><strong>注意</strong>，<code>TypeScript</code> 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面</p></blockquote><h2 id="2-8-类型断言"><a href="#2-8-类型断言" class="headerlink" title="2.8 类型断言"></a>2.8 类型断言</h2><blockquote><p>类型断言（<code>Type Assertion</code>）可以用来手动指定一个值的类型。</p></blockquote><p><strong>语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;类型&gt;值</span><br><span class="line"></span><br><span class="line">// 或</span><br><span class="line"></span><br><span class="line">值 as 类型</span><br></pre></td></tr></table></figure><blockquote><p>在 <code>tsx</code> 语法（<code>React</code> 的 <code>jsx</code> 语法的 <code>ts</code> 版）中必须用后一种</p></blockquote><p><strong>例子：将一个联合类型的变量指定为一个更加具体的类型</strong></p><blockquote><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">something: string | number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> something.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'.</span></span><br><span class="line"><span class="comment">//   Property 'length' does not exist on type 'number'.</span></span><br></pre></td></tr></table></figure><blockquote><p>而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型的属性或方法，比如</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">something: string | number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (something.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> something.length;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> something.toString().length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,19): error TS2339: Property 'length' does not exist on type 'string | number'.</span></span><br><span class="line"><span class="comment">//   Property 'length' does not exist on type 'number'.</span></span><br><span class="line"><span class="comment">// index.ts(3,26): error TS2339: Property 'length' does not exist on type 'string | number'.</span></span><br><span class="line"><span class="comment">//   Property 'length' does not exist on type 'number'.</span></span><br></pre></td></tr></table></figure><blockquote><p>上例中，获取 <code>something.length</code>的时候会报错</p></blockquote><p><strong>此时可以使用类型断言，将 something 断言成 string</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">something: string | number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="xml"><span class="tag">&lt;<span class="name">string</span>&gt;</span>something).length) &#123;</span></span><br><span class="line">        return (&lt;string&gt;something).length;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return something.toString().length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>类型断言的用法如上，在需要断言的变量前加上 <code>&lt;Type&gt;</code> 即可</p></blockquote><p><strong>类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toBoolean</span>(<span class="params">something: string | number</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">boolean</span>&gt;</span>something;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// index.ts(2,10): error TS2352: Type 'string | number' cannot be converted to type 'boolean'.</span></span><br><span class="line"><span class="xml">//   Type 'number' is not comparable to type 'boolean'.</span></span><br></pre></td></tr></table></figure><h2 id="2-9-声明文件"><a href="#2-9-声明文件" class="headerlink" title="2.9 声明文件"></a>2.9 声明文件</h2><blockquote><p>当使用第三方库时，我们需要引用它的声明文件</p></blockquote><h3 id="2-9-1-声明-declare-语句"><a href="#2-9-1-声明-declare-语句" class="headerlink" title="2.9.1 声明(declare)语句"></a>2.9.1 声明(declare)语句</h3><blockquote><p>假如我们想使用第三方库，比如 <code>jQuery</code>，我们通常这样获取一个 <code>id</code> 是 <code>foo</code> 的元素</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#foo'</span>);</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">jQuery(<span class="string">'#foo'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>但是在 <code>TypeScript</code> 中，我们并不知道 <code>$</code> 或 <code>jQuery</code>是什么东西</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jQuery(<span class="string">'#foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(1,1): error TS2304: Cannot find name 'jQuery'.</span></span><br></pre></td></tr></table></figure><blockquote><p>这时，我们需要使用 <code>declare</code> 关键字来定义它的类型，帮助<code>TypeScript</code> 判断我们传入的参数类型对不对</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="keyword">var</span> jQuery: <span class="function">(<span class="params">selector: string</span>) =&gt;</span> any;</span><br><span class="line"></span><br><span class="line">jQuery(<span class="string">'#foo'</span>);</span><br></pre></td></tr></table></figure><blockquote><p><code>declare</code> 定义的类型只会用于编译时的检查，编译结果中会被删除</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上例的编译结果是：</span></span><br><span class="line"></span><br><span class="line">jQuery(<span class="string">'#foo'</span>);</span><br></pre></td></tr></table></figure><h3 id="2-9-2-声明文件-约定-d-ts后缀"><a href="#2-9-2-声明文件-约定-d-ts后缀" class="headerlink" title="2.9.2 声明文件(约定.d.ts后缀)"></a>2.9.2 声明文件(约定.d.ts后缀)</h3><blockquote><p>通常我们会把类型声明放到一个单独的文件中，这就是声明文件</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery.d.ts</span></span><br><span class="line"></span><br><span class="line">declare <span class="keyword">var</span> jQuery: <span class="function">(<span class="params">string</span>) =&gt;</span> any;</span><br></pre></td></tr></table></figure><ul><li>我们约定声明文件以 <code>.d.ts</code> 为后缀。</li><li>然后在使用到的文件的开头，用<code>「三斜线指令」///</code>表示引用了声明文件</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path="./jQuery.d.ts" /&gt;</span></span><br><span class="line"></span><br><span class="line">jQuery(<span class="string">'#foo'</span>);</span><br></pre></td></tr></table></figure><h3 id="2-9-3-第三方声明文件"><a href="#2-9-3-第三方声明文件" class="headerlink" title="2.9.3 第三方声明文件"></a>2.9.3 第三方声明文件</h3><blockquote><p>当然，<code>jQuery</code> 的声明文件不需要我们定义了，已经有人帮我们定义好了：<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/jquery/index.d.ts" target="_blank" rel="noopener">jQuery in DefinitelyTyped</a></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/jquery/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Type definitions for jquery 3.3</span></span><br><span class="line"><span class="comment">// Project: https://jquery.com</span></span><br><span class="line"><span class="comment">// Definitions by: Leonard Thieu &lt;https://github.com/leonard-thieu&gt;</span></span><br><span class="line"><span class="comment">//                 Boris Yankov &lt;https://github.com/borisyankov&gt;</span></span><br><span class="line"><span class="comment">//                 Christian Hoffmeister &lt;https://github.com/choffmeister&gt;</span></span><br><span class="line"><span class="comment">//                 Steve Fenton &lt;https://github.com/Steve-Fenton&gt;</span></span><br><span class="line"><span class="comment">//                 Diullei Gomes &lt;https://github.com/Diullei&gt;</span></span><br><span class="line"><span class="comment">//                 Tass Iliopoulos &lt;https://github.com/tasoili&gt;</span></span><br><span class="line"><span class="comment">//                 Jason Swearingen &lt;https://github.com/jasons-novaleaf&gt;</span></span><br><span class="line"><span class="comment">//                 Sean Hill &lt;https://github.com/seanski&gt;</span></span><br><span class="line"><span class="comment">//                 Guus Goossens &lt;https://github.com/Guuz&gt;</span></span><br><span class="line"><span class="comment">//                 Kelly Summerlin &lt;https://github.com/ksummerlin&gt;</span></span><br><span class="line"><span class="comment">//                 Basarat Ali Syed &lt;https://github.com/basarat&gt;</span></span><br><span class="line"><span class="comment">//                 Nicholas Wolverson &lt;https://github.com/nwolverson&gt;</span></span><br><span class="line"><span class="comment">//                 Derek Cicerone &lt;https://github.com/derekcicerone&gt;</span></span><br><span class="line"><span class="comment">//                 Andrew Gaspar &lt;https://github.com/AndrewGaspar&gt;</span></span><br><span class="line"><span class="comment">//                 Seikichi Kondo &lt;https://github.com/seikichi&gt;</span></span><br><span class="line"><span class="comment">//                 Benjamin Jackman &lt;https://github.com/benjaminjackman&gt;</span></span><br><span class="line"><span class="comment">//                 Poul Sorensen &lt;https://github.com/s093294&gt;</span></span><br><span class="line"><span class="comment">//                 Josh Strobl &lt;https://github.com/JoshStrobl&gt;</span></span><br><span class="line"><span class="comment">//                 John Reilly &lt;https://github.com/johnnyreilly&gt;</span></span><br><span class="line"><span class="comment">//                 Dick van den Brink &lt;https://github.com/DickvdBrink&gt;</span></span><br><span class="line"><span class="comment">//                 Thomas Schulz &lt;https://github.com/King2500&gt;</span></span><br><span class="line"><span class="comment">//                 Terry Mun &lt;https://github.com/terrymun&gt;</span></span><br><span class="line"><span class="comment">// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped</span></span><br><span class="line"><span class="comment">// TypeScript Version: 2.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入声明文件</span></span><br><span class="line"><span class="comment">/// &lt;reference types="sizzle" /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path="JQueryStatic.d.ts" /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path="JQuery.d.ts" /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path="misc.d.ts" /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path="legacy.d.ts" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> = jQuery;</span><br></pre></td></tr></table></figure><ul><li>我们可以直接下载下来使用，但是更推荐的是使用工具统一管理第三方库的声明文件- 社区已经有多种方式引入声明文件，不过 <code>TypeScript 2.0</code>推荐使用 <code>@types</code> 来管理。</li><li><code>@types</code> 的使用方式很简单，直接用 <code>npm</code> 安装对应的声明模块即可，以 <code>jQuery</code> 举例</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @types/jquery --save-dev</span><br></pre></td></tr></table></figure><p><strong>可以在这个页面搜索你需要的声明文件</strong></p><blockquote><p><a href="http://microsoft.github.io/TypeSearch/" target="_blank" rel="noopener">http://microsoft.github.io/TypeSearch/</a></p></blockquote><h2 id="2-10-内置对象"><a href="#2-10-内置对象" class="headerlink" title="2.10 内置对象"></a>2.10 内置对象</h2><blockquote><p><code>JavaScript</code> 中有很多内置对象，它们可以直接在 <code>TypeScript</code> 中当做定义好了的类型</p></blockquote><blockquote><p>内置对象是指根据标准在全局作用域（<code>Global</code>）上存在的对象。这里的标准是指 <code>ECMAScript</code> 和其他环境（比如 <code>DOM</code>）的标准</p></blockquote><h3 id="2-10-1-ECMAScript-的内置对象"><a href="#2-10-1-ECMAScript-的内置对象" class="headerlink" title="2.10.1 ECMAScript 的内置对象"></a>2.10.1 ECMAScript 的内置对象</h3><p><strong>ECMAScript 标准提供的内置对象有</strong></p><blockquote><p><code>Boolean</code>、<code>Error</code>、<code>Date</code>、<code>RegExp</code> 等</p></blockquote><p>我们可以在 <code>TypeScript</code> 中将变量定义为这些类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b: <span class="built_in">Boolean</span> = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> e: <span class="built_in">Error</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error occurred'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d: <span class="built_in">Date</span> = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r: <span class="built_in">RegExp</span> = <span class="regexp">/[a-z]/</span>;</span><br></pre></td></tr></table></figure><blockquote><p>更多的内置对象，可以查看 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener">MDN 的文档</a></p></blockquote><blockquote><p>而他们的定义文件，则在 <a href="https://github.com/Microsoft/TypeScript/tree/master/src/lib" target="_blank" rel="noopener">TypeScript 核心库的定义文件中</a></p></blockquote><h3 id="2-10-2-DOM-和-BOM-的内置对象"><a href="#2-10-2-DOM-和-BOM-的内置对象" class="headerlink" title="2.10.2 DOM 和 BOM 的内置对象"></a>2.10.2 DOM 和 BOM 的内置对象</h3><p><strong>DOM 和 BOM 提供的内置对象有</strong></p><blockquote><p><code>Document</code>、<code>HTMLElement</code>、<code>Event</code>、<code>NodeList</code> 等。</p></blockquote><blockquote><p>TypeScript 中会经常用到这些类型</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> body: HTMLElement = <span class="built_in">document</span>.body;</span><br><span class="line"><span class="keyword">let</span> allDiv: NodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e: MouseEvent</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>它们的定义文件同样在 <a href="https://github.com/Microsoft/TypeScript/tree/master/src/lib" target="_blank" rel="noopener">TypeScript 核心库的定义文件中</a></p></blockquote><h3 id="2-10-3-TypeScript-核心库的定义文件"><a href="#2-10-3-TypeScript-核心库的定义文件" class="headerlink" title="2.10.3 TypeScript 核心库的定义文件"></a>2.10.3 TypeScript 核心库的定义文件</h3><blockquote><p><a href="https://github.com/Microsoft/TypeScript/tree/master/src/lib" target="_blank" rel="noopener">TypeScript 核心库</a>的定义文件中定义了所有浏览器环境需要用到的类型，并且是预置在 TypeScript 中的</p></blockquote><blockquote><p>当你在使用一些常用的方法的时候，<code>TypeScript</code> 实际上已经帮你做了很多类型判断的工作了，比如</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">10</span>, <span class="string">'2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(1,14): error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的例子中，<code>Math.pow</code> 必须接受两个 <code>number</code> 类型的参数。事实上 <code>Math.pow</code>的类型定义如下</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="built_in">Math</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value of a base expression taken to a specified power.</span></span><br><span class="line"><span class="comment">     * @param x The base value of the expression.</span></span><br><span class="line"><span class="comment">     * @param y The exponent value of the expression.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    pow(x: number, <span class="attr">y</span>: number): number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>再举一个 <code>DOM</code> 中的例子</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.targetCurrent);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,17): error TS2339: Property 'targetCurrent' does not exist on type 'MouseEvent'.</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的例子中，<code>addEventListener</code> 方法是在 <code>TypeScript</code> 核心库中定义的</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Document extends Node, GlobalEventHandlers, NodeSelector, DocumentEvent &#123;</span><br><span class="line">    addEventListener(type: string, <span class="attr">listener</span>: <span class="function">(<span class="params">ev: MouseEvent</span>) =&gt;</span> any, useCapture?: boolean): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>所以 <code>e</code> 被推断成了 <code>MouseEvent</code>，而 <code>MouseEvent</code> 是没有 <code>targetCurrent</code> 属性的，所以报错了</p></blockquote><p><strong>注意，TypeScript 核心库的定义中不包含 Node.js 部分</strong></p><h3 id="2-10-4-用-TypeScript-写-Node-js"><a href="#2-10-4-用-TypeScript-写-Node-js" class="headerlink" title="2.10.4 用 TypeScript 写 Node.js"></a>2.10.4 用 TypeScript 写 Node.js</h3><blockquote><p><code>Node.js</code> 不是内置对象的一部分，如果想用 <code>TypeScript</code> 写 <code>Node.js</code>，则需要引入第三方声明文件</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @types/node --save-dev</span><br></pre></td></tr></table></figure><h1 id="三、进阶"><a href="#三、进阶" class="headerlink" title="三、进阶"></a>三、进阶</h1><h2 id="3-1-类型别名"><a href="#3-1-类型别名" class="headerlink" title="3.1 类型别名"></a>3.1 类型别名</h2><blockquote><p>类型别名用来给一个类型起个新名字</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type Name = string;</span><br><span class="line"></span><br><span class="line">type NameResolver = <span class="function"><span class="params">()</span> =&gt;</span> string;</span><br><span class="line"></span><br><span class="line">type NameOrResolver = Name | NameResolver; <span class="comment">// 联合类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">n: NameOrResolver</span>): <span class="title">Name</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> n === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中，我们使用 <code>type</code> 创建类型别名。</p><blockquote><p>类型别名常用于联合类型</p></blockquote><h2 id="3-2-字符串字面量类型"><a href="#3-2-字符串字面量类型" class="headerlink" title="3.2 字符串字面量类型"></a>3.2 字符串字面量类型</h2><blockquote><p>字符串字面量类型用来约束取值只能是某几个字符串中的一个</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type EventNames = <span class="string">'click'</span> | <span class="string">'scroll'</span> | <span class="string">'mousemove'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleEvent</span>(<span class="params">ele: Element, event: EventNames</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleEvent(<span class="built_in">document</span>.getElementById(<span class="string">'hello'</span>), <span class="string">'scroll'</span>);  <span class="comment">// 没问题</span></span><br><span class="line">handleEvent(<span class="built_in">document</span>.getElementById(<span class="string">'world'</span>), <span class="string">'dbclick'</span>); <span class="comment">// 报错，event 不能为 'dbclick'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(7,47): error TS2345: Argument of type '"dbclick"' is not assignable to parameter of type 'EventNames'.</span></span><br></pre></td></tr></table></figure><ul><li>上例中，我们使用 <code>type</code> 定了一个字符串字面量类型 <code>EventNames</code>，它只能取三种字符串中的一种。</li></ul><p><strong>注意，类型别名与字符串字面量类型都是使用 type 进行定</strong></p><h2 id="3-3-元组"><a href="#3-3-元组" class="headerlink" title="3.3 元组"></a>3.3 元组</h2><ul><li>数组合并了相同类型的对象，而元组（<code>Tuple</code>）合并了不同类型的对象。</li><li>元组起源于函数编程语言,在这些语言中频繁使用元组。</li></ul><h3 id="3-3-1-简单的例子"><a href="#3-3-1-简单的例子" class="headerlink" title="3.3.1 简单的例子"></a>3.3.1 简单的例子</h3><blockquote><p>定义一对值分别为 <code>string</code> 和 <code>number</code>的元组</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let user: [string, number] = [&apos;poetries&apos;, 22];</span><br></pre></td></tr></table></figure><blockquote><p>当赋值或访问一个已知索引的元素时，会得到正确的类型</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user: [string, number];</span><br><span class="line">user[<span class="number">0</span>] = <span class="string">'poetries'</span>;</span><br><span class="line">user[<span class="number">1</span>] = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">user[<span class="number">0</span>].slice(<span class="number">1</span>);</span><br><span class="line">user[<span class="number">1</span>].toFixed(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><blockquote><p>也可以只赋值其中一项</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user: [string, number];</span><br><span class="line">user[<span class="number">0</span>] = <span class="string">'poetries'</span>;</span><br></pre></td></tr></table></figure><h3 id="3-3-2-越界的元素"><a href="#3-3-2-越界的元素" class="headerlink" title="3.3.2 越界的元素"></a>3.3.2 越界的元素</h3><blockquote><p>当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user: [string, number];</span><br><span class="line">user = [<span class="string">'poetries'</span>, <span class="number">22</span>];</span><br><span class="line">user.push(<span class="string">'http://blog.poetries.top'</span>);</span><br><span class="line">user.push(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(4,14): error TS2345: Argument of type 'boolean' is not assignable to parameter of type 'string | number'.</span></span><br><span class="line"><span class="comment">//   Type 'boolean' is not assignable to type 'number'.</span></span><br></pre></td></tr></table></figure><h2 id="3-4-枚举"><a href="#3-4-枚举" class="headerlink" title="3.4 枚举"></a>3.4 枚举</h2><blockquote><p>枚举（<code>Enum</code>）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等</p></blockquote><h3 id="3-4-1-简单的例子"><a href="#3-4-1-简单的例子" class="headerlink" title="3.4.1 简单的例子"></a>3.4.1 简单的例子</h3><blockquote><p>枚举使用 <code>enum</code> 关键字来定义：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>枚举成员会被赋值为从 <code>0</code> 开始递增的数字，同时也会对枚举值到枚举名进行反向映射</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">"Sun"</span>] === <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">"Mon"</span>] === <span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">"Tue"</span>] === <span class="number">2</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">"Sat"</span>] === <span class="number">6</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="number">0</span>] === <span class="string">"Sun"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="number">1</span>] === <span class="string">"Mon"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="number">2</span>] === <span class="string">"Tue"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="number">6</span>] === <span class="string">"Sat"</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>事实上，上面的例子会被编译为</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Days;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Days</span>) </span>&#123;</span><br><span class="line">    Days[Days[<span class="string">"Sun"</span>] = <span class="number">0</span>] = <span class="string">"Sun"</span>;</span><br><span class="line">    Days[Days[<span class="string">"Mon"</span>] = <span class="number">1</span>] = <span class="string">"Mon"</span>;</span><br><span class="line">    Days[Days[<span class="string">"Tue"</span>] = <span class="number">2</span>] = <span class="string">"Tue"</span>;</span><br><span class="line">    Days[Days[<span class="string">"Wed"</span>] = <span class="number">3</span>] = <span class="string">"Wed"</span>;</span><br><span class="line">    Days[Days[<span class="string">"Thu"</span>] = <span class="number">4</span>] = <span class="string">"Thu"</span>;</span><br><span class="line">    Days[Days[<span class="string">"Fri"</span>] = <span class="number">5</span>] = <span class="string">"Fri"</span>;</span><br><span class="line">    Days[Days[<span class="string">"Sat"</span>] = <span class="number">6</span>] = <span class="string">"Sat"</span>;</span><br><span class="line">&#125;)(Days || (Days = &#123;&#125;));</span><br></pre></td></tr></table></figure><h3 id="3-4-2-手动赋值"><a href="#3-4-2-手动赋值" class="headerlink" title="3.4.2 手动赋值"></a>3.4.2 手动赋值</h3><blockquote><p>我们也可以给枚举项手动赋值</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Days &#123;Sun = <span class="number">7</span>, Mon = <span class="number">1</span>, Tue, Wed, Thu, Fri, Sat&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">"Sun"</span>] === <span class="number">7</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">"Mon"</span>] === <span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">"Tue"</span>] === <span class="number">2</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">"Sat"</span>] === <span class="number">6</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的例子中，未手动赋值的枚举项会接着上一个枚举项递增</p></blockquote><p>如果未手动赋值的枚举项与手动赋值的重复了，<code>TypeScript</code> 是不会察觉到这一点的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Days &#123;Sun = <span class="number">3</span>, Mon = <span class="number">1</span>, Tue, Wed, Thu, Fri, Sat&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">"Sun"</span>] === <span class="number">3</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">"Wed"</span>] === <span class="number">3</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="number">3</span>] === <span class="string">"Sun"</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="number">3</span>] === <span class="string">"Wed"</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的例子中，递增到 <code>3</code> 的时候与前面的 <code>Sun</code> 的取值重复了，但是 <code>TypeScript</code> 并没有报错，导致 <code>Days[3]</code>的值先是 <code>&quot;Sun&quot;</code>，而后又被 <code>&quot;Wed&quot;</code> 覆盖了。编译的结果是</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Days;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Days</span>) </span>&#123;</span><br><span class="line">    Days[Days[<span class="string">"Sun"</span>] = <span class="number">3</span>] = <span class="string">"Sun"</span>;</span><br><span class="line">    Days[Days[<span class="string">"Mon"</span>] = <span class="number">1</span>] = <span class="string">"Mon"</span>;</span><br><span class="line">    Days[Days[<span class="string">"Tue"</span>] = <span class="number">2</span>] = <span class="string">"Tue"</span>;</span><br><span class="line">    Days[Days[<span class="string">"Wed"</span>] = <span class="number">3</span>] = <span class="string">"Wed"</span>;</span><br><span class="line">    Days[Days[<span class="string">"Thu"</span>] = <span class="number">4</span>] = <span class="string">"Thu"</span>;</span><br><span class="line">    Days[Days[<span class="string">"Fri"</span>] = <span class="number">5</span>] = <span class="string">"Fri"</span>;</span><br><span class="line">    Days[Days[<span class="string">"Sat"</span>] = <span class="number">6</span>] = <span class="string">"Sat"</span>;</span><br><span class="line">&#125;)(Days || (Days = &#123;&#125;));</span><br></pre></td></tr></table></figure><p>所以使用的时候需要注意，最好不要出现这种覆盖的情况。</p><blockquote><p>手动赋值的枚举项可以不是数字，此时需要使用类型断言来让 <code>tsc</code> 无视类型检查 (编译出的 <code>js</code> 仍然是可用的)：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum Days &#123;Sun = <span class="number">7</span>, Mon, Tue, Wed, Thu, Fri, Sat = <span class="xml"><span class="tag">&lt;<span class="name">any</span>&gt;</span>"S"&#125;;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Days;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Days</span>) </span>&#123;</span><br><span class="line">    Days[Days[<span class="string">"Sun"</span>] = <span class="number">7</span>] = <span class="string">"Sun"</span>;</span><br><span class="line">    Days[Days[<span class="string">"Mon"</span>] = <span class="number">8</span>] = <span class="string">"Mon"</span>;</span><br><span class="line">    Days[Days[<span class="string">"Tue"</span>] = <span class="number">9</span>] = <span class="string">"Tue"</span>;</span><br><span class="line">    Days[Days[<span class="string">"Wed"</span>] = <span class="number">10</span>] = <span class="string">"Wed"</span>;</span><br><span class="line">    Days[Days[<span class="string">"Thu"</span>] = <span class="number">11</span>] = <span class="string">"Thu"</span>;</span><br><span class="line">    Days[Days[<span class="string">"Fri"</span>] = <span class="number">12</span>] = <span class="string">"Fri"</span>;</span><br><span class="line">    Days[Days[<span class="string">"Sat"</span>] = <span class="string">"S"</span>] = <span class="string">"Sat"</span>;</span><br><span class="line">&#125;)(Days || (Days = &#123;&#125;));</span><br></pre></td></tr></table></figure><blockquote><p>当然，手动赋值的枚举项也可以为小数或负数，此时后续未手动赋值的项的递增步长仍为 <code>1</code>：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Days &#123;Sun = <span class="number">7</span>, Mon = <span class="number">1.5</span>, Tue, Wed, Thu, Fri, Sat&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">"Sun"</span>] === <span class="number">7</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">"Mon"</span>] === <span class="number">1.5</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">"Tue"</span>] === <span class="number">2.5</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">"Sat"</span>] === <span class="number">6.5</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="3-4-3-常数项和计算所得项"><a href="#3-4-3-常数项和计算所得项" class="headerlink" title="3.4.3 常数项和计算所得项"></a>3.4.3 常数项和计算所得项</h3><blockquote><p>枚举项有两种类型：常数项（<code>constant member</code>）和计算所得项（<code>computed member</code>）</p></blockquote><p>前面我们所举的例子都是常数项，一个典型的计算所得项的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;Red, Green, Blue = <span class="string">"blue"</span>.length&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>上面的例子中，<code>&quot;blue&quot;.length</code> 就是一个计算所得项。</p></blockquote><p>上面的例子不会报错，但是如果紧接在计算所得项后面的是未手动赋值的项，那么它就会因为无法获得初始值而报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;Red = <span class="string">"red"</span>.length, Green, Blue&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(1,33): error TS1061: Enum member must have initializer.</span></span><br><span class="line"><span class="comment">// index.ts(1,40): error TS1061: Enum member must have initializer.</span></span><br></pre></td></tr></table></figure><h3 id="3-4-4-常数枚举"><a href="#3-4-4-常数枚举" class="headerlink" title="3.4.4 常数枚举"></a>3.4.4 常数枚举</h3><blockquote><p>常数枚举是使用 <code>const enum</code> 定义的枚举类型</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> enum Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</span><br></pre></td></tr></table></figure><blockquote><p>常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上例的编译结果是：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> directions = [<span class="number">0</span> <span class="comment">/* Up */</span>, <span class="number">1</span> <span class="comment">/* Down */</span>, <span class="number">2</span> <span class="comment">/* Left */</span>, <span class="number">3</span> <span class="comment">/* Right */</span>];</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假如包含了计算成员，则会在编译阶段报错：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> enum Color &#123;Red, Green, Blue = <span class="string">"blue"</span>.length&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(1,38): error TS2474: In 'const' enum declarations member initializer must be constant expression.</span></span><br></pre></td></tr></table></figure><h3 id="3-4-5-外部枚举"><a href="#3-4-5-外部枚举" class="headerlink" title="3.4.5 外部枚举"></a>3.4.5 外部枚举</h3><blockquote><p>外部枚举（<code>Ambient Enums</code>）是使用 <code>declare enum</code> 定义的枚举类型</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">declare enum Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</span><br></pre></td></tr></table></figure><ul><li>之前提到过，<code>declare</code> 定义的类型只会用于编译时的检查，编译结果中会被删除。</li></ul><p>上例的编译结果是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</span><br></pre></td></tr></table></figure><ul><li>外部枚举与声明语句一样，常出现在声明文件中。</li><li>同时使用 <code>declare</code> 和 <code>const</code> 也是可以的：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="keyword">const</span> enum Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译结果：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> directions = [<span class="number">0</span> <span class="comment">/* Up */</span>, <span class="number">1</span> <span class="comment">/* Down */</span>, <span class="number">2</span> <span class="comment">/* Left */</span>, <span class="number">3</span> <span class="comment">/* Right */</span>];</span><br></pre></td></tr></table></figure><h2 id="3-5-类"><a href="#3-5-类" class="headerlink" title="3.5 类"></a>3.5 类</h2><h3 id="3-5-1-类的概念"><a href="#3-5-1-类的概念" class="headerlink" title="3.5.1 类的概念"></a>3.5.1 类的概念</h3><blockquote><p>类相关的概念做一个简单的介绍</p></blockquote><ul><li>类(<code>Class</code>)：定义了一件事物的抽象特点，包含它的属性和方法</li><li>对象（<code>Object</code>）：类的实例，通过 <code>new</code> 生成</li><li>面向对象（<code>OOP</code>）的三大特性：封装、继承、多态</li><li>封装（<code>Encapsulation</code>）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据</li><li>继承（<code>Inheritance</code>）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性</li><li>多态（<code>Polymorphism</code>）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 <code>Cat</code> 和 <code>Dog</code> 都继承自 <code>Animal</code>，但是分别实现了自己的 <code>eat</code> 方法。此时针对某一个实例，我们无需了解它是 <code>Cat</code>还是 <code>Dog</code>，就可以直接调用 <code>eat</code>方法，程序会自动判断出来应该如何执行 <code>eat</code></li><li>存取器（<code>getter &amp; setter</code>）：用以改变属性的读取和赋值行为</li><li>修饰符（<code>Modifiers</code>）：修饰符是一些关键字，用于限定成员或类型的性质。比如 <code>public</code> 表示公有属性或方法</li><li>抽象类（<code>Abstract Class</code>）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现</li><li>接口（<code>Interfaces</code>）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（<code>implements</code>）。一个类只能继承自另一个类，但是可以实现多个接口</li></ul><h3 id="3-5-2-public-private-和-protected"><a href="#3-5-2-public-private-和-protected" class="headerlink" title="3.5.2 public private 和 protected"></a>3.5.2 public private 和 protected</h3><blockquote><p><code>TypeScript</code> 可以使用三种访问修饰符（<code>Access Modifiers</code>），分别是 <code>public</code>、<code>private</code> 和 <code>protected</code></p></blockquote><ul><li><code>public</code> 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 <code>public</code> 的</li><li><code>private</code> 修饰的属性或方法是私有的，不能在声明它的类的外部访问</li><li><code>protected</code> 修饰的属性或方法是受保护的，它和 <code>private</code> 类似，区别是它在子类中也是允许被访问的</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    public name;</span><br><span class="line">    public <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">'Jack'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// Jack</span></span><br><span class="line">a.name = <span class="string">'Tom'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// Tom</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的例子中，<code>name</code> 被设置为了 <code>public</code>，所以直接访问实例的 <code>name</code> 属性是允许的。</p></blockquote><p>很多时候，我们希望有的属性是无法直接存取的，这时候就可以用 <code>private</code> 了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lass Animal &#123;</span><br><span class="line">    private name;</span><br><span class="line">    public <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">'Jack'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// Jack</span></span><br><span class="line">a.name = <span class="string">'Tom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(9,13): error TS2341: Property 'name' is private and only accessible within class 'Animal'.</span></span><br><span class="line"><span class="comment">// index.ts(10,1): error TS2341: Property 'name' is private and only accessible within class 'Animal'.</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的例子编译后的代码是：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Animal = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Animal;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Animal(<span class="string">'Jack'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.name);</span><br><span class="line">a.name = <span class="string">'Tom'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>使用 <code>private</code> 修饰的属性或方法，在子类中也是不允许访问的：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    private name;</span><br><span class="line">    public <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(11,17): error TS2341: Property 'name' is private and only accessible within class 'Animal'.</span></span><br></pre></td></tr></table></figure><blockquote><p>而如果是用 <code>protected</code> 修饰，则允许在子类中访问</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    protected name;</span><br><span class="line">    public <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-3-抽象类"><a href="#3-5-3-抽象类" class="headerlink" title="3.5.3 抽象类"></a>3.5.3 抽象类</h3><blockquote><p><code>abstract</code> 用于定义抽象类和其中的抽象方法。</p></blockquote><p><strong>什么是抽象类？</strong></p><blockquote><p>首先，抽象类是不允许被实例化的</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    public name;</span><br><span class="line">    public <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract sayHi();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">'Jack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(9,11): error TS2511: Cannot create an instance of the abstract class 'Animal'.</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的例子中，我们定义了一个抽象类 <code>Animal</code>，并且定义了一个抽象方法 <code>sayHi</code>。在实例化抽象类的时候报错了。</p></blockquote><p>其次，抽象类中的抽象方法必须被子类实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    public name;</span><br><span class="line">    public <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract sayHi();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    public eat() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> is eating.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Cat(<span class="string">'Tom'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(9,7): error TS2515: Non-abstract class 'Cat' does not implement inherited abstract member 'sayHi' from class 'Animal'.</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的例子中，我们定义了一个类 <code>Cat</code> 继承了抽象类 <code>Animal</code>，但是没有实现抽象方法 <code>sayHi</code>，所以编译报错了。</p></blockquote><p>下面是一个正确使用抽象类的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    public name;</span><br><span class="line">    public <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract sayHi();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    public sayHi() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Meow, My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Cat(<span class="string">'Tom'</span>);</span><br></pre></td></tr></table></figure><p>上面的例子中，我们实现了抽象方法 <code>sayHi</code>，编译通过了。</p><blockquote><p>需要注意的是，即使是抽象方法，<code>TypeScript</code> 的编译结果中，仍然会存在这个类，上面的代码的编译结果是：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> __extends = (<span class="keyword">this</span> &amp;&amp; <span class="keyword">this</span>.__extends) || <span class="function"><span class="keyword">function</span> (<span class="params">d, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> b) <span class="keyword">if</span> (b.hasOwnProperty(p)) d[p] = b[p];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__</span>(<span class="params"></span>) </span>&#123; <span class="keyword">this</span>.constructor = d; &#125;</span><br><span class="line">    d.prototype = b === <span class="literal">null</span> ? <span class="built_in">Object</span>.create(b) : (__.prototype = b.prototype, <span class="keyword">new</span> __());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Animal = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Animal;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="keyword">var</span> Cat = (<span class="function"><span class="keyword">function</span> (<span class="params">_super</span>) </span>&#123;</span><br><span class="line">    __extends(Cat, _super);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        _super.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Cat.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Meow, My name is '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> Cat;</span><br><span class="line">&#125;(Animal));</span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat(<span class="string">'Tom'</span>);</span><br></pre></td></tr></table></figure><h3 id="3-5-4-类的类型"><a href="#3-5-4-类的类型" class="headerlink" title="3.5.4 类的类型"></a>3.5.4 类的类型</h3><blockquote><p>给类加上 <code>TypeScript</code> 的类型很简单，与接口类似：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    <span class="keyword">constructor</span>(name: string) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    sayHi(): string &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: Animal = <span class="keyword">new</span> Animal(<span class="string">'Jack'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.sayHi()); <span class="comment">// My name is Jack</span></span><br></pre></td></tr></table></figure><h2 id="3-6-类与接口"><a href="#3-6-类与接口" class="headerlink" title="3.6 类与接口"></a>3.6 类与接口</h2><h3 id="3-6-1-类实现接口"><a href="#3-6-1-类实现接口" class="headerlink" title="3.6.1 类实现接口"></a>3.6.1 类实现接口</h3><blockquote><p>实现（<code>implements</code>）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（<code>interfaces</code>），用 <code>implements</code> 关键字来实现。这个特性大大提高了面向对象的灵活性</p></blockquote><p>举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    alert();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecurityDoor</span> <span class="keyword">extends</span> <span class="title">Door</span> <span class="title">implements</span> <span class="title">Alarm</span> </span>&#123;</span><br><span class="line">    alert() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'SecurityDoor alert'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="title">implements</span> <span class="title">Alarm</span> </span>&#123;</span><br><span class="line">    alert() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Car alert'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一个类可以实现多个接口</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    alert();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Light &#123;</span><br><span class="line">    lightOn();</span><br><span class="line">    lightOff();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="title">implements</span> <span class="title">Alarm</span>, <span class="title">Light</span> </span>&#123;</span><br><span class="line">    alert() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Car alert'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    lightOn() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Car light on'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    lightOff() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Car light off'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上例中，<code>Car</code> 实现了 <code>Alarm</code> 和 <code>Light</code>接口，既能报警，也能开关车灯</p></blockquote><h3 id="3-6-2-接口继承接口"><a href="#3-6-2-接口继承接口" class="headerlink" title="3.6.2 接口继承接口"></a>3.6.2 接口继承接口</h3><blockquote><p>接口与接口之间可以是继承关系</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    alert();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface LightableAlarm extends Alarm &#123;</span><br><span class="line">    lightOn();</span><br><span class="line">    lightOff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上例中，我们使用 <code>extends</code> 使 <code>LightableAlarm</code> 继承 <code>Alarm</code></p></blockquote><h3 id="3-6-3-接口继承类"><a href="#3-6-3-接口继承类" class="headerlink" title="3.6.3 接口继承类"></a>3.6.3 接口继承类</h3><blockquote><p>接口也可以继承类：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    x: number;</span><br><span class="line">    y: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Point3d extends Point &#123;</span><br><span class="line">    z: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point3d: Point3d = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-6-4-混合类型"><a href="#3-6-4-混合类型" class="headerlink" title="3.6.4 混合类型"></a>3.6.4 混合类型</h3><blockquote><p>可以使用接口的方式来定义一个函数需要符合的形状</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface SearchFunc &#123;</span><br><span class="line">    (source: string, <span class="attr">subString</span>: string): boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">source: string, subString: string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> source.search(subString) !== <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有时候，一个函数还可以有自己的属性和方法</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Counter &#123;</span><br><span class="line">    (start: number): string;</span><br><span class="line">    interval: number;</span><br><span class="line">    reset(): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>): <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> counter = <span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span>function (start: number) &#123; &#125;;</span></span><br><span class="line"><span class="xml">    counter.interval = 123;</span></span><br><span class="line"><span class="xml">    counter.reset = function () &#123; &#125;;</span></span><br><span class="line"><span class="xml">    return counter;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">let c = getCounter();</span></span><br><span class="line"><span class="xml">c(10);</span></span><br><span class="line"><span class="xml">c.reset();</span></span><br><span class="line"><span class="xml">c.interval = 5.0;</span></span><br></pre></td></tr></table></figure><h2 id="3-7-泛型"><a href="#3-7-泛型" class="headerlink" title="3.7 泛型"></a>3.7 泛型</h2><blockquote><p>泛型（<code>Generics</code>）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性</p></blockquote><h3 id="3-7-1-简单的例子"><a href="#3-7-1-简单的例子" class="headerlink" title="3.7.1 简单的例子"></a>3.7.1 简单的例子</h3><blockquote><p>首先，我们来实现一个函数 <code>createArray</code>，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>(<span class="params">length: number, value: any</span>): <span class="title">Array</span>&lt;<span class="title">any</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray(<span class="number">3</span>, <span class="string">'x'</span>); <span class="comment">// ['x', 'x', 'x']</span></span><br></pre></td></tr></table></figure><ul><li>上例中，我们使用了之前提到过的数组泛型来定义返回值的类型。</li><li>这段代码编译不会报错，但是一个显而易见的缺陷是，它并没有准确的定义返回值的类型：<code>Array&lt;any&gt;</code> 允许数组的每一项都为任意类型。但是我们预期的是，数组中每一项都应该是输入的<code>value</code> 的类型。</li></ul><blockquote><p>这时候，泛型就派上用场了：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>&lt;<span class="title">T</span>&gt;(<span class="params">length: number, value: T</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result: T[] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray&lt;string&gt;(<span class="number">3</span>, <span class="string">'x'</span>); <span class="comment">// ['x', 'x', 'x']</span></span><br></pre></td></tr></table></figure><blockquote><p>上例中，我们在函数名后添加了 <code>&lt;T&gt;</code>，其中 <code>T</code> 用来指代任意输入的类型，在后面的输入 <code>value: T</code> 和输出 <code>Array&lt;T&gt;</code>中即可使用了</p></blockquote><p>接着在调用的时候，可以指定它具体的类型为 <code>string</code>。当然，也可以不手动指定，而让类型推论自动推算出来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>&lt;<span class="title">T</span>&gt;(<span class="params">length: number, value: T</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result: T[] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray(<span class="number">3</span>, <span class="string">'x'</span>); <span class="comment">// ['x', 'x', 'x']</span></span><br></pre></td></tr></table></figure><h3 id="3-7-2-多个类型参数"><a href="#3-7-2-多个类型参数" class="headerlink" title="3.7.2 多个类型参数"></a>3.7.2 多个类型参数</h3><blockquote><p>定义泛型的时候，可以一次定义多个类型参数：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] &#123;</span><br><span class="line">    <span class="keyword">return</span> [tuple[<span class="number">1</span>], tuple[<span class="number">0</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">swap([<span class="number">7</span>, <span class="string">'seven'</span>]); <span class="comment">// ['seven', 7]</span></span><br></pre></td></tr></table></figure><blockquote><p>上例中，我们定义了一个 <code>swap</code> 函数，用来交换输入的元组</p></blockquote><h3 id="3-7-3-泛型约束"><a href="#3-7-3-泛型约束" class="headerlink" title="3.7.3 泛型约束"></a>3.7.3 泛型约束</h3><blockquote><p>在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,19): error TS2339: Property 'length' does not exist on type 'T'.</span></span><br></pre></td></tr></table></figure><blockquote><p>上例中，泛型 <code>T</code> 不一定包含属性 <code>length</code>，所以编译的时候报错了。</p></blockquote><blockquote><p>这时，我们可以对泛型进行约束，只允许这个函数传入那些包含<code>length</code> 属性的变量。这就是泛型约束</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Lengthwise &#123;</span><br><span class="line">    length: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上例中，我们使用了 <code>extends</code>约束了泛型 <code>T</code> 必须符合接口 <code>Lengthwise</code> 的形状，也就是必须包含 <code>length</code> 属性。</p></blockquote><blockquote><p>此时如果调用 <code>loggingIdentity</code> 的时候，传入的 <code>arg</code>不包含 <code>length</code>，那么在编译阶段就会报错了</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface Lengthwise &#123;</span><br><span class="line">    length: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loggingIdentity(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(10,17): error TS2345: Argument of type '7' is not assignable to parameter of type 'Lengthwise'.</span></span><br></pre></td></tr></table></figure><p><strong>多个类型参数之间也可以互相约束：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyFields</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">U</span>, <span class="title">U</span>&gt;(<span class="params">target: T, source: U</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> source) &#123;</span><br><span class="line">        target[id] = (<span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span>source)[id];</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    return target;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">copyFields(x, &#123; b: 10, d: 20 &#125;);</span></span><br></pre></td></tr></table></figure><blockquote><p>上例中，我们使用了两个类型参数，其中要求 <code>T</code> 继承 <code>U</code>，这样就保证了<code>U</code> 上不会出现 <code>T</code> 中不存在的字段</p></blockquote><h3 id="3-7-4-泛型接口"><a href="#3-7-4-泛型接口" class="headerlink" title="3.7.4 泛型接口"></a>3.7.4 泛型接口</h3><blockquote><p>可以使用接口的方式来定义一个函数需要符合的形状</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface SearchFunc &#123;</span><br><span class="line">  (source: string, <span class="attr">subString</span>: string): boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">source: string, subString: string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> source.search(subString) !== <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当然也可以使用含有泛型的接口来定义函数的形状</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface CreateArrayFunc &#123;</span><br><span class="line">    &lt;T&gt;(length: number, <span class="attr">value</span>: T): <span class="built_in">Array</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> createArray: CreateArrayFunc;</span><br><span class="line">createArray = <span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt;(<span class="params">length: number, value: T</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result: T[] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray(<span class="number">3</span>, <span class="string">'x'</span>); <span class="comment">// ['x', 'x', 'x']</span></span><br></pre></td></tr></table></figure><blockquote><p>进一步，我们可以把泛型参数提前到接口名上</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface CreateArrayFunc&lt;T&gt; &#123;</span><br><span class="line">    (length: number, <span class="attr">value</span>: T): <span class="built_in">Array</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> createArray: CreateArrayFunc&lt;any&gt;;</span><br><span class="line">createArray = <span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt;(<span class="params">length: number, value: T</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result: T[] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray(<span class="number">3</span>, <span class="string">'x'</span>); <span class="comment">// ['x', 'x', 'x']</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，此时在使用泛型接口的时候，需要定义泛型的类型</p></blockquote><h3 id="3-7-5-泛型类"><a href="#3-7-5-泛型类" class="headerlink" title="3.7.5 泛型类"></a>3.7.5 泛型类</h3><blockquote><p>与泛型接口类似，泛型也可以用于类的类型定义中</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericNumber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    zeroValue: T;</span><br><span class="line">    add: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> GenericNumber&lt;number&gt;();</span><br><span class="line"></span><br><span class="line">myGenericNumber.zeroValue = <span class="number">0</span>;</span><br><span class="line">myGenericNumber.add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br></pre></td></tr></table></figure><h3 id="3-7-6-泛型参数的默认类型"><a href="#3-7-6-泛型参数的默认类型" class="headerlink" title="3.7.6 泛型参数的默认类型"></a>3.7.6 泛型参数的默认类型</h3><blockquote><p>在 <code>TypeScript 2.3</code>以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>&lt;<span class="title">T</span> = <span class="title">string</span>&gt;(<span class="params">length: number, value: T</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result: T[] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-8-声明合并"><a href="#3-8-声明合并" class="headerlink" title="3.8 声明合并"></a>3.8 声明合并</h2><blockquote><p>如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型</p></blockquote><h3 id="3-8-1-函数的合并"><a href="#3-8-1-函数的合并" class="headerlink" title="3.8.1 函数的合并"></a>3.8.1 函数的合并</h3><blockquote><p>我们可以使用重载定义多个函数类型</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: number</span>): <span class="title">number</span>;</span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">reverse</span>(<span class="params">x: string</span>): <span class="title">string</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">reverse</span>(<span class="params">x: number | string</span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(x.toString().split(<span class="string">''</span>).reverse().join(<span class="string">''</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-8-2-接口的合并"><a href="#3-8-2-接口的合并" class="headerlink" title="3.8.2 接口的合并"></a>3.8.2 接口的合并</h3><blockquote><p>接口中的属性在合并时会简单的合并到一个接口中</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    price: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Alarm &#123;</span><br><span class="line">    weight: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>相当于：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    price: number;</span><br><span class="line">    weight: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，合并的属性的类型必须是唯一的</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    price: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Alarm &#123;</span><br><span class="line">    price: number;  <span class="comment">// 虽然重复了，但是类型都是 `number`，所以不会报错</span></span><br><span class="line">    weight: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    price: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Alarm &#123;</span><br><span class="line">    price: string;  <span class="comment">// 类型不一致，会报错</span></span><br><span class="line">    weight: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(5,3): error TS2403: Subsequent variable declarations must have the same type.  Variable 'price' must be of type 'number', but here has type 'string'.</span></span><br></pre></td></tr></table></figure><p><strong>接口中方法的合并，与函数的合并一样</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    price: number;</span><br><span class="line">    alert(s: string): string;</span><br><span class="line">&#125;</span><br><span class="line">interface Alarm &#123;</span><br><span class="line">    weight: number;</span><br><span class="line">    alert(s: string, <span class="attr">n</span>: number): string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    price: number;</span><br><span class="line">    weight: number;</span><br><span class="line">    alert(s: string): string;</span><br><span class="line">    alert(s: string, <span class="attr">n</span>: number): string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-8-3-类的合并"><a href="#3-8-3-类的合并" class="headerlink" title="3.8.3 类的合并"></a>3.8.3 类的合并</h3><blockquote><p>类的合并与接口的合并规则一致</p></blockquote><h1 id="四、工程"><a href="#四、工程" class="headerlink" title="四、工程"></a>四、工程</h1><h2 id="4-1-tsconfig-json"><a href="#4-1-tsconfig-json" class="headerlink" title="4.1 tsconfig.json"></a>4.1 tsconfig.json</h2><p><strong>编译选项</strong></p><blockquote><p>你可以通过 <code>compilerOptions</code> 来定制你的编译选项</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 基本选项 */</span></span><br><span class="line">    <span class="string">"target"</span>: <span class="string">"es5"</span>,                       <span class="comment">// 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'</span></span><br><span class="line">    <span class="string">"module"</span>: <span class="string">"commonjs"</span>,                  <span class="comment">// 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015'</span></span><br><span class="line">    <span class="string">"lib"</span>: [],                             <span class="comment">// 指定要包含在编译中的库文件</span></span><br><span class="line">    <span class="string">"allowJs"</span>: <span class="literal">true</span>,                       <span class="comment">// 允许编译 javascript 文件</span></span><br><span class="line">    <span class="string">"checkJs"</span>: <span class="literal">true</span>,                       <span class="comment">// 报告 javascript 文件中的错误</span></span><br><span class="line">    <span class="string">"jsx"</span>: <span class="string">"preserve"</span>,                     <span class="comment">// 指定 jsx 代码的生成: 'preserve', 'react-native', or 'react'</span></span><br><span class="line">    <span class="string">"declaration"</span>: <span class="literal">true</span>,                   <span class="comment">// 生成相应的 '.d.ts' 文件</span></span><br><span class="line">    <span class="string">"sourceMap"</span>: <span class="literal">true</span>,                     <span class="comment">// 生成相应的 '.map' 文件</span></span><br><span class="line">    <span class="string">"outFile"</span>: <span class="string">"./"</span>,                       <span class="comment">// 将输出文件合并为一个文件</span></span><br><span class="line">    <span class="string">"outDir"</span>: <span class="string">"./"</span>,                        <span class="comment">// 指定输出目录</span></span><br><span class="line">    <span class="string">"rootDir"</span>: <span class="string">"./"</span>,                       <span class="comment">// 用来控制输出目录结构 --outDir.</span></span><br><span class="line">    <span class="string">"removeComments"</span>: <span class="literal">true</span>,                <span class="comment">// 删除编译后的所有的注释</span></span><br><span class="line">    <span class="string">"noEmit"</span>: <span class="literal">true</span>,                        <span class="comment">// 不生成输出文件</span></span><br><span class="line">    <span class="string">"importHelpers"</span>: <span class="literal">true</span>,                 <span class="comment">// 从 tslib 导入辅助工具函数</span></span><br><span class="line">    <span class="string">"isolatedModules"</span>: <span class="literal">true</span>,               <span class="comment">// 将每个文件做为单独的模块 （与 'ts.transpileModule' 类似）.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 严格的类型检查选项 */</span></span><br><span class="line">    <span class="string">"strict"</span>: <span class="literal">true</span>,                        <span class="comment">// 启用所有严格类型检查选项</span></span><br><span class="line">    <span class="string">"noImplicitAny"</span>: <span class="literal">true</span>,                 <span class="comment">// 在表达式和声明上有隐含的 any类型时报错</span></span><br><span class="line">    <span class="string">"strictNullChecks"</span>: <span class="literal">true</span>,              <span class="comment">// 启用严格的 null 检查</span></span><br><span class="line">    <span class="string">"noImplicitThis"</span>: <span class="literal">true</span>,                <span class="comment">// 当 this 表达式值为 any 类型的时候，生成一个错误</span></span><br><span class="line">    <span class="string">"alwaysStrict"</span>: <span class="literal">true</span>,                  <span class="comment">// 以严格模式检查每个模块，并在每个文件里加入 'use strict'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 额外的检查 */</span></span><br><span class="line">    <span class="string">"noUnusedLocals"</span>: <span class="literal">true</span>,                <span class="comment">// 有未使用的变量时，抛出错误</span></span><br><span class="line">    <span class="string">"noUnusedParameters"</span>: <span class="literal">true</span>,            <span class="comment">// 有未使用的参数时，抛出错误</span></span><br><span class="line">    <span class="string">"noImplicitReturns"</span>: <span class="literal">true</span>,             <span class="comment">// 并不是所有函数里的代码都有返回值时，抛出错误</span></span><br><span class="line">    <span class="string">"noFallthroughCasesInSwitch"</span>: <span class="literal">true</span>,    <span class="comment">// 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 模块解析选项 */</span></span><br><span class="line">    <span class="string">"moduleResolution"</span>: <span class="string">"node"</span>,            <span class="comment">// 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6)</span></span><br><span class="line">    <span class="string">"baseUrl"</span>: <span class="string">"./"</span>,                       <span class="comment">// 用于解析非相对模块名称的基目录</span></span><br><span class="line">    <span class="string">"paths"</span>: &#123;&#125;,                           <span class="comment">// 模块名到基于 baseUrl 的路径映射的列表</span></span><br><span class="line">    <span class="string">"rootDirs"</span>: [],                        <span class="comment">// 根文件夹列表，其组合内容表示项目运行时的结构内容</span></span><br><span class="line">    <span class="string">"typeRoots"</span>: [],                       <span class="comment">// 包含类型声明的文件列表</span></span><br><span class="line">    <span class="string">"types"</span>: [],                           <span class="comment">// 需要包含的类型声明文件名列表</span></span><br><span class="line">    <span class="string">"allowSyntheticDefaultImports"</span>: <span class="literal">true</span>,  <span class="comment">// 允许从没有设置默认导出的模块中默认导入。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Source Map Options */</span></span><br><span class="line">    <span class="string">"sourceRoot"</span>: <span class="string">"./"</span>,                    <span class="comment">// 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span></span><br><span class="line">    <span class="string">"mapRoot"</span>: <span class="string">"./"</span>,                       <span class="comment">// 指定调试器应该找到映射文件而不是生成文件的位置</span></span><br><span class="line">    <span class="string">"inlineSourceMap"</span>: <span class="literal">true</span>,               <span class="comment">// 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</span></span><br><span class="line">    <span class="string">"inlineSources"</span>: <span class="literal">true</span>,                 <span class="comment">// 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 其他选项 */</span></span><br><span class="line">    <span class="string">"experimentalDecorators"</span>: <span class="literal">true</span>,        <span class="comment">// 启用装饰器</span></span><br><span class="line">    <span class="string">"emitDecoratorMetadata"</span>: <span class="literal">true</span>          <span class="comment">// 为装饰器提供元数据的支持</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-TypeScript-编译"><a href="#4-2-TypeScript-编译" class="headerlink" title="4.2 TypeScript 编译"></a>4.2 TypeScript 编译</h2><blockquote><p>运行 <code>tsc -p ./path-to-project-directory</code> 。<code>tsc -w</code>来启用 <code>TypeScript</code>编译器的观测模式，在检测到文件改动之后，它将重新编译</p></blockquote><p><strong>指定需要编译的文件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"files"</span>: [</span><br><span class="line">    <span class="string">"./some/file.ts"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 include 和 exclude 选项来指定需要包含的文件，和排除的文件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"include"</span>: [</span><br><span class="line">    <span class="string">"./folder"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"exclude"</span>: [</span><br><span class="line">    <span class="string">"./folder/**/*.spec.ts"</span>,</span><br><span class="line">    <span class="string">"./folder/someSubFolder"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、一些例子演示"><a href="#五、一些例子演示" class="headerlink" title="五、一些例子演示"></a>五、一些例子演示</h1><h2 id="5-1-定义ajax请求数据接口"><a href="#5-1-定义ajax请求数据接口" class="headerlink" title="5.1 定义ajax请求数据接口"></a>5.1 定义ajax请求数据接口</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">interface Config&#123;</span><br><span class="line">    type:string;</span><br><span class="line">    url:string;</span><br><span class="line">    data?:string;</span><br><span class="line">    dataType:string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原生js封装的ajax </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">config:Config</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> xhr=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">   xhr.open(config.type,config.url,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">   xhr.send(config.data);</span><br><span class="line"></span><br><span class="line">   xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(xhr.readyState==<span class="number">4</span> &amp;&amp; xhr.status==<span class="number">200</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'chengong'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(config.dataType==<span class="string">'json'</span>)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(xhr.responseText));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(xhr.responseText)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ajax(&#123;</span><br><span class="line">    type:<span class="string">'get'</span>,</span><br><span class="line">    data:<span class="string">'name=zhangsan'</span>,</span><br><span class="line">    url:<span class="string">'http://a.itying.com/api/productlist'</span>, <span class="comment">//api</span></span><br><span class="line">    dataType:<span class="string">'json'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="5-2-函数类型接口-对方法约束"><a href="#5-2-函数类型接口-对方法约束" class="headerlink" title="5.2 函数类型接口-对方法约束"></a>5.2 函数类型接口-对方法约束</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数类型接口:对方法传入的参数 以及返回值进行约束   批量约束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密的函数类型接口</span></span><br><span class="line"></span><br><span class="line">interface encrypt&#123;</span><br><span class="line">    (key:string,<span class="attr">value</span>:string):string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> md5:encrypt=<span class="function"><span class="keyword">function</span>(<span class="params">key:string,value:string</span>):<span class="title">string</span></span>&#123;</span><br><span class="line">        <span class="comment">//模拟操作</span></span><br><span class="line">        <span class="keyword">return</span> key+value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(md5(<span class="string">'name'</span>,<span class="string">'zhangsan'</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sha1:encrypt=<span class="function"><span class="keyword">function</span>(<span class="params">key:string,value:string</span>):<span class="title">string</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟操作</span></span><br><span class="line">    <span class="keyword">return</span> key+<span class="string">'----'</span>+value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sha1(<span class="string">'name'</span>,<span class="string">'lisi'</span>));</span><br></pre></td></tr></table></figure><h2 id="5-3-可索引接口：数组、对象的约束（不常用）"><a href="#5-3-可索引接口：数组、对象的约束（不常用）" class="headerlink" title="5.3 可索引接口：数组、对象的约束（不常用）"></a>5.3 可索引接口：数组、对象的约束（不常用）</h2><h3 id="5-3-1-可索引接口-对数组的约束"><a href="#5-3-1-可索引接口-对数组的约束" class="headerlink" title="5.3.1 可索引接口-对数组的约束"></a>5.3.1 可索引接口-对数组的约束</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface UserArr&#123;</span><br><span class="line">    [index:number]:string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr:UserArr=[<span class="string">'aaa'</span>,<span class="string">'bbb'</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><h3 id="5-3-2-可索引接口-对对象的约束"><a href="#5-3-2-可索引接口-对对象的约束" class="headerlink" title="5.3.2 可索引接口-对对象的约束"></a>5.3.2 可索引接口-对对象的约束</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface UserObj&#123;</span><br><span class="line">    [index:string]:string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr:UserObj=&#123;<span class="attr">name</span>:<span class="string">'张三'</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-3-3-类类型接口-对类的约束"><a href="#5-3-3-类类型接口-对类的约束" class="headerlink" title="5.3.3 类类型接口:对类的约束"></a>5.3.3 类类型接口:对类的约束</h3><ul><li>抽象类抽象有点相似    </li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">interface Animal&#123;</span><br><span class="line">    name:string;</span><br><span class="line">    eat(str:string):<span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="title">implements</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    name:string;</span><br><span class="line">    <span class="keyword">constructor</span>(name:string)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    eat()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">'吃粮食'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d=<span class="keyword">new</span> Dog(<span class="string">'小黑'</span>);</span><br><span class="line">d.eat();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="title">implements</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    name:string;</span><br><span class="line">    <span class="keyword">constructor</span>(name:string)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    eat(food:string)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">'吃'</span>+food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c=<span class="keyword">new</span> Cat(<span class="string">'小花'</span>);</span><br><span class="line">c.eat(<span class="string">'老鼠'</span>);</span><br></pre></td></tr></table></figure><h2 id="5-4-接口的扩展"><a href="#5-4-接口的扩展" class="headerlink" title="5.4 接口的扩展"></a>5.4 接口的扩展</h2><blockquote><p>接口继承接口 类实现接口</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">interface Animal&#123;</span><br><span class="line">    eat():<span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Person extends Animal&#123;</span><br><span class="line"></span><br><span class="line">    work():<span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    public name:string;</span><br><span class="line">    <span class="keyword">constructor</span>(name:string)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    coding(code:string)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name+code)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Web</span> <span class="keyword">extends</span> <span class="title">Programmer</span> <span class="title">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>(name:string)&#123;</span><br><span class="line">       <span class="keyword">super</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line">    eat()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">'喜欢吃馒头'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    work()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">'写代码'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w=<span class="keyword">new</span> Web(<span class="string">'小李'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// w.eat();</span></span><br><span class="line"></span><br><span class="line">w.coding(<span class="string">'写ts代码'</span>);</span><br></pre></td></tr></table></figure><h2 id="5-5-泛型类接口"><a href="#5-5-泛型类接口" class="headerlink" title="5.5 泛型类接口"></a>5.5 泛型类接口</h2><h3 id="5-5-1-泛型类-泛型方法"><a href="#5-5-1-泛型类-泛型方法" class="headerlink" title="5.5.1 泛型类 泛型方法"></a>5.5.1 泛型类 泛型方法</h3><ul><li>泛型：软件工程中，我们不仅要创建一致的定义良好的<code>API</code>，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</li><li>在像<code>C#</code>和<code>Java</code>这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</li><li>通俗理解：泛型就是解决类接口方法的复用性、以及对不特定数据类型的支持(类型校验)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只能返回string类型的数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">value:string</span>):<span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时返回 string类型 和number类型  （代码冗余）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData1</span>(<span class="params">value:string</span>):<span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData2</span>(<span class="params">value:number</span>):<span class="title">number</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同时返回 string类型 和number类型  any可以解决这个问题</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">value:any</span>):<span class="title">any</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'哈哈哈'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getData(<span class="number">123</span>);</span><br><span class="line">getData(<span class="string">'str'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//any放弃了类型检查,传入什么 返回什么。比如:传入number 类型必须返回number类型  传入 string类型必须返回string类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//传入的参数类型和返回的参数类型可以不一致</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">value:any</span>):<span class="title">any</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'哈哈哈'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>T</code>表示泛型，具体什么类型是调用这个方法的时候决定的</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T表示泛型，具体什么类型是调用这个方法的时候决定的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>&lt;<span class="title">T</span>&gt;(<span class="params">value:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line">getData&lt;number&gt;(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">getData&lt;string&gt;(<span class="string">'1214231'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getData&lt;number&gt;(<span class="string">'2112'</span>);       <span class="comment">/*错误的写法*/</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>&lt;<span class="title">T</span>&gt;(<span class="params">value:T</span>):<span class="title">any</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">'2145214214'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getData&lt;number&gt;(<span class="number">123</span>);  <span class="comment">//参数必须是number</span></span><br><span class="line"></span><br><span class="line">getData&lt;string&gt;(<span class="string">'这是一个泛型'</span>);</span><br></pre></td></tr></table></figure><p><strong>泛型类</strong></p><blockquote><p>泛型类：比如有个最小堆算法，需要同时支持返回数字和字符串 <code>a  -  z</code>两种类型。  通过类的泛型来实现</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本写法 但是不能传入字符串</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinClass</span></span>&#123;</span><br><span class="line">    public list:number[]=[];</span><br><span class="line">    add(num:number)&#123;</span><br><span class="line">        <span class="keyword">this</span>.list.push(num)</span><br><span class="line">    &#125;</span><br><span class="line">    min():number&#123;</span><br><span class="line">        <span class="keyword">var</span> minNum=<span class="keyword">this</span>.list[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.list.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(minNum&gt;<span class="keyword">this</span>.list[i])&#123;</span><br><span class="line">                minNum=<span class="keyword">this</span>.list[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m=<span class="keyword">new</span> MinClass();</span><br><span class="line"></span><br><span class="line">m.add(<span class="number">3</span>);</span><br><span class="line">m.add(<span class="number">22</span>);</span><br><span class="line">m.add(<span class="number">23</span>);</span><br><span class="line">m.add(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">m.add(<span class="number">7</span>);</span><br><span class="line">alert(m.min());</span><br></pre></td></tr></table></figure><p><strong>类的泛型</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过泛型改写 可以同时传入number 字符串等</span></span><br><span class="line"><span class="comment">//类的泛型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinClas</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    public list:T[]=[];</span><br><span class="line"></span><br><span class="line">    add(value:T):<span class="keyword">void</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.list.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    min():T&#123;        </span><br><span class="line">        <span class="keyword">var</span> minNum=<span class="keyword">this</span>.list[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.list.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(minNum&gt;<span class="keyword">this</span>.list[i])&#123;</span><br><span class="line">                minNum=<span class="keyword">this</span>.list[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m1=<span class="keyword">new</span> MinClas&lt;number&gt;();   <span class="comment">/*实例化类 并且制定了类的T代表的类型是number*/</span></span><br><span class="line">m1.add(<span class="number">11</span>);</span><br><span class="line">m1.add(<span class="number">3</span>);</span><br><span class="line">m1.add(<span class="number">2</span>);</span><br><span class="line">alert(m1.min())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m2=<span class="keyword">new</span> MinClas&lt;string&gt;();   <span class="comment">/*实例化类 并且制定了类的T代表的类型是string*/</span></span><br><span class="line"></span><br><span class="line">m2.add(<span class="string">'c'</span>);</span><br><span class="line">m2.add(<span class="string">'a'</span>);</span><br><span class="line">m2.add(<span class="string">'v'</span>);</span><br><span class="line">alert(m2.min())</span><br></pre></td></tr></table></figure><h3 id="5-5-2-泛型接口"><a href="#5-5-2-泛型接口" class="headerlink" title="5.5.2 泛型接口"></a>5.5.2 泛型接口</h3><p><strong>1. 方式1</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface ConfigFn&#123;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt;(value:T):T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getData:ConfigFn=<span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt;(<span class="params">value:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getData&lt;string&gt;(<span class="string">'张三'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// getData&lt;string&gt;(1243);  //错误</span></span><br></pre></td></tr></table></figure><p><strong>2. 方式2</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">interface ConfigFn&lt;T&gt;&#123;</span><br><span class="line">    (value:T):T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>&lt;<span class="title">T</span>&gt;(<span class="params">value:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myGetData:ConfigFn&lt;string&gt;=getData;     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myGetData(<span class="string">'20'</span>);  <span class="comment">/*正确*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// myGetData(20)  //错误</span></span><br></pre></td></tr></table></figure><h1 id="六、更多参考"><a href="#六、更多参考" class="headerlink" title="六、更多参考"></a>六、更多参考</h1><ul><li><a href="https://www.tslang.cn/docs/handbook/typescript-in-5-minutes.html" target="_blank" rel="noopener">Typescript中文网</a></li><li><a href="http://jspang.com/post/typescript.html#toc-a39" target="_blank" rel="noopener">技术胖Typescript视频学习入门</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h1&gt;&lt;h2 id=&quot;1-1-什么是-TypeScript&quot;&gt;&lt;a href=&quot;#1-1-什么是-TypeScript&quot; class=&quot;
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="Javascript" scheme="http://blog.poetries.top/tags/Javascript/"/>
    
      <category term="Typescript" scheme="http://blog.poetries.top/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>Typescript基础及结合React实践(一)</title>
    <link href="http://blog.poetries.top/2018/12/29/ts-intro-and-use-in-react/"/>
    <id>http://blog.poetries.top/2018/12/29/ts-intro-and-use-in-react/</id>
    <published>2018-12-29T08:30:24.000Z</published>
    <updated>2019-01-07T08:48:58.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分-Typescript基础"><a href="#第一部分-Typescript基础" class="headerlink" title="第一部分 Typescript基础"></a>第一部分 Typescript基础</h1><h2 id="一、typescript-安装"><a href="#一、typescript-安装" class="headerlink" title="一、typescript 安装"></a>一、typescript 安装</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i typescript -g</span><br></pre></td></tr></table></figure><blockquote><p>全局安装完成后，我们新建一个<code>hello.ts</code>的<code>ts</code>文件</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.ts内容</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">"poet"</span></span><br></pre></td></tr></table></figure><blockquote><p>接下来我们在命令行输入<code>tsc hello.ts</code>来编译这个<code>ts</code>文件，然后会在同级目录生成一个编译好了的<code>hello.js</code>文件</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.js内容</span></span><br><span class="line"><span class="keyword">var</span> = <span class="string">"poet"</span></span><br></pre></td></tr></table></figure><blockquote><p>那么我们每次都要输<code>tsc hello.ts</code>命令来编译，这样很麻烦，能否让它自动编译？答案是可以的，使用<code>vscode</code>来开发，需要配置一下<code>vscode</code>就可以。</p></blockquote><blockquote><p>首先我们在命令行执行<code>tsc --init</code>来生成配置文件，然后我们在目录下看到生成了一个<code>tsconfig.json</code>文件</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-064a181236aedb92.png" alt="image.png"></p><blockquote><p>这个<code>json</code>文件里有很多选项</p></blockquote><ul><li><code>target</code>是选择编译到什么语法</li><li><code>module</code>则是模块类型</li><li><code>outDir</code>则是输出目录，可以指定这个参数到指定目录</li></ul><blockquote><p>更多细节 <a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/tsconfig.json.html" target="_blank" rel="noopener">https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/tsconfig.json.html</a></p></blockquote><blockquote><p>接下来我们需要开启监控了，在<code>vscode</code>任务栏中</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-da2ea080476546f2.png" alt="image.png"></p><p><strong>Typescript在线编辑器</strong></p><blockquote><p>建议使用在线编辑器练习 <a href="http://www.typescriptlang.org/play/index.html" target="_blank" rel="noopener">http://www.typescriptlang.org/play/index.html</a></p></blockquote><h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><blockquote><p><code>js</code>是弱类型语言，强弱类语言有什么区别呢？<code>typescript</code>最大的优点就是类型检查，可以帮你检查你定义的类型和赋值的类型。</p></blockquote><h3 id="2-1-布尔类型boolean"><a href="#2-1-布尔类型boolean" class="headerlink" title="2.1 布尔类型boolean"></a>2.1 布尔类型boolean</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在js中，定义isFlag为true，为布尔类型boolean</span></span><br><span class="line"><span class="keyword">let</span> isFlag = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 但是我们也可以重新给它赋值为字符串</span></span><br><span class="line">isFlag = <span class="string">"hello swr"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在ts中，定义isFlag为true，为布尔类型boolean</span></span><br><span class="line"><span class="comment">// 在变量名后加冒号和类型，如  :boolean</span></span><br><span class="line"><span class="keyword">let</span> isFlag:boolean = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 重新赋值到字符串类型会报错</span></span><br><span class="line">isFlag = <span class="string">"hello swr"</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在java中，一般是这样定义，要写变量名也要写类型名</span></span><br><span class="line"><span class="comment">// int a = 10; </span></span><br><span class="line"><span class="comment">// string name = "poetries"</span></span><br></pre></td></tr></table></figure><h3 id="2-2-数字类型number"><a href="#2-2-数字类型number" class="headerlink" title="2.2 数字类型number"></a>2.2 数字类型number</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age:number = <span class="number">28</span>;</span><br><span class="line">age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure><h3 id="2-3-字符串类型string"><a href="#2-3-字符串类型string" class="headerlink" title="2.3 字符串类型string"></a>2.3 字符串类型string</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name:string = <span class="string">"poetries"</span></span><br><span class="line">name = <span class="string">"iamswr"</span></span><br></pre></td></tr></table></figure><blockquote><p>以上<code>boolean</code>、<code>number</code>、<code>string</code>类型有个共性，就是可以通过<code>typeof</code>来获取到是什么类型，是基本数据类型</p></blockquote><p>那么复杂的数据类型是怎么处理的呢？</p><h3 id="2-4-数组-Array"><a href="#2-4-数组-Array" class="headerlink" title="2.4 数组 Array"></a>2.4 数组 Array</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="comment">// 这是一个字符串数组，只能往里面放字符串，写别的类型会报错</span></span><br><span class="line"><span class="keyword">let</span> persion:string[] = [<span class="string">'poetries'</span>, <span class="string">'jing'</span>]</span><br><span class="line"><span class="comment">// 另一个写法 </span></span><br><span class="line"><span class="keyword">let</span> persions:<span class="built_in">Array</span>&lt;string&gt; = [<span class="string">'poetries'</span>, <span class="string">'jing'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果数组里放对象呢</span></span><br><span class="line"><span class="keyword">let</span> persionObject:<span class="built_in">Array</span>&lt;object&gt; = [&#123;<span class="attr">name</span>:<span class="string">'poetries'</span>,<span class="attr">age</span>:<span class="number">22</span>&#125;]</span><br><span class="line"><span class="keyword">let</span> persionObjects:object[] = [&#123;<span class="attr">name</span>:<span class="string">'poetries'</span>,<span class="attr">age</span>:<span class="number">22</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在数组中放string、number、boolean、object</span></span><br><span class="line"><span class="keyword">let</span> arr:<span class="built_in">Array</span>&lt;number|object|string|boolean&gt; = [<span class="number">22</span>, <span class="string">'test'</span>, <span class="literal">true</span>, &#123;<span class="attr">name</span>:<span class="string">'poetries'</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组中放什么都可以</span></span><br><span class="line"><span class="keyword">let</span> arrAny:<span class="built_in">Array</span>&lt;any&gt; = [<span class="string">'test'</span>,<span class="number">12</span>,<span class="literal">false</span>]</span><br></pre></td></tr></table></figure><h3 id="2-5-元组类型tuple"><a href="#2-5-元组类型tuple" class="headerlink" title="2.5 元组类型tuple"></a>2.5 元组类型tuple</h3><ul><li>什么是元组类型？其实元组是数组的一种。</li><li>有点类似解构赋值，但是又不完全是解构赋值，比如元组类型必须一一对应上</li><li>元组类型是一个不可变的数组，长度、类型是不可变的</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元组类型tuple</span></span><br><span class="line"><span class="comment">// 什么是元组类型？其实元组是数组的一种</span></span><br><span class="line"><span class="keyword">let</span> per :[string,number,object] = [<span class="string">'poetries'</span>,<span class="number">22</span>,&#123;<span class="attr">love</span>: <span class="string">'coding'</span>&#125;]</span><br></pre></td></tr></table></figure><h3 id="2-6-枚举类型enum"><a href="#2-6-枚举类型enum" class="headerlink" title="2.6 枚举类型enum"></a>2.6 枚举类型enum</h3><blockquote><p>什么是枚举？枚举有点类似一一列举，一个一个数出来。一般用于值是某几个固定的值</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举类型enum</span></span><br><span class="line"></span><br><span class="line">enum sex &#123;</span><br><span class="line">    BOY=<span class="string">'男孩'</span>,</span><br><span class="line">    GIRL=<span class="string">'女孩'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sex)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转化为es5语法</span></span><br><span class="line"><span class="comment">// 我们顺便看看实现的原理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sex;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">sex</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 首先这里是一个自执行函数</span></span><br><span class="line"><span class="comment">// 并且把sex定义为对象，传参进给自执行函数</span></span><br><span class="line"><span class="comment">// 然后给sex对象添加属性并且赋值</span></span><br><span class="line">    sex[<span class="string">"BOY"</span>] = <span class="string">"\u7537\u5B69"</span>;</span><br><span class="line">    sex[<span class="string">"GIRL"</span>] = <span class="string">"\u5973\u5B69"</span>;</span><br><span class="line">&#125;)(sex || (sex = &#123;&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(sex);</span><br></pre></td></tr></table></figure><blockquote><p>比如我们实际项目中，特别是商城类，订单会存在很多状态流转，那么非常适合用枚举</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum orderStatus &#123;</span><br><span class="line">    WAIT_FOR_PAY = <span class="string">"待支付"</span>,</span><br><span class="line">    UNDELIVERED = <span class="string">"完成支付，待发货"</span>,</span><br><span class="line">    DELIVERED = <span class="string">"已发货"</span>,</span><br><span class="line">    COMPLETED = <span class="string">"已确认收货"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>到这里，我们会有一个疑虑，为什么我们不这样写呢？</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> orderStatus2 = &#123;</span><br><span class="line">    WAIT_FOR_PAY : <span class="string">"待支付"</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果我们直接写对象的键值对方式，是可以在外部修改这个值的，而我们通过<code>enum</code>则不能修改定义好的值了</p></blockquote><h3 id="2-7-任意类型-any"><a href="#2-7-任意类型-any" class="headerlink" title="2.7 任意类型 any"></a>2.7 任意类型 any</h3><blockquote><p><code>any</code>有好处也有坏处，特别是前端，很多时候写类型的时候，几乎分不清楚类型，任意去写，写起来很爽，但是对于后续的重构、迭代等是非常不友好的，会暴露出很多问题，某种程度来说，<code>any</code>类型就是放弃了类型检查了</p></blockquote><p>比如我们有这样一个场景，就是需要获取某一个dom节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line">btn.style.color = <span class="string">"blue"</span>;</span><br></pre></td></tr></table></figure><blockquote><p>此时我们发现在<code>ts</code>中会报错</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-f87a912f9aa9eb0a.png" alt="image.png"></p><ul><li>因为我们取这个<code>dom</code>节点，有可能取到，也有可能没取到，当没取到的时候，相当于是<code>null</code>，是没有<code>style</code>这个属性的。</li><li>那么我们可以给它添加一个类型为<code>any</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加一个any类型，此时就不会报错了，但是也相当于放弃了类型检查了</span></span><br><span class="line"><span class="keyword">let</span> btn:any = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line">btn.style.color = <span class="string">"blue"</span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以赋值任何类型的值</span></span><br><span class="line"><span class="comment">// 跟以前我们var let声明的一模一样的</span></span><br><span class="line"><span class="keyword">let</span> person:any = <span class="string">"poetries"</span></span><br><span class="line">person = <span class="number">22</span></span><br></pre></td></tr></table></figure><h3 id="2-8-null-undefined类型"><a href="#2-8-null-undefined类型" class="headerlink" title="2.8 null undefined类型"></a>2.8 null undefined类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (string | number | null | undefined) 相当于这几种类型</span></span><br><span class="line"><span class="comment">// 是 string 或 number 或 null 或 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str:(string | number | <span class="literal">null</span> | <span class="literal">undefined</span>)</span><br><span class="line"></span><br><span class="line">str = <span class="string">'poetries'</span></span><br><span class="line">str = <span class="number">28</span></span><br><span class="line">str = <span class="literal">null</span> </span><br><span class="line">str = <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><h3 id="2-9-void类型"><a href="#2-9-void类型" class="headerlink" title="2.9 void类型"></a>2.9 void类型</h3><blockquote><p><code>void</code>表示没有任何类型，一般是定义函数没有返回值</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void 不能再函数里写return</span></span><br><span class="line"><span class="comment">// 怎么理解叫没有返回值呢？此时我们给函数return一个值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">name:string</span>):<span class="title">void</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello:'</span>, name)</span><br><span class="line">    <span class="comment">// return "ok" 会报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">//不会报错</span></span><br><span class="line">&#125;</span><br><span class="line">say(<span class="string">'poetries'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个字符串类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say1</span>(<span class="params">name:string</span>):<span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'ok'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-10-never类型"><a href="#2-10-never类型" class="headerlink" title="2.10 never类型"></a>2.10 never类型</h3><blockquote><p>这个用得很少，一般是用于抛出异常</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message:string</span>):<span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message)</span><br><span class="line">&#125;</span><br><span class="line">error(<span class="string">'errorMsg'</span>)</span><br></pre></td></tr></table></figure><h3 id="2-11-我们要搞明白any、never、void"><a href="#2-11-我们要搞明白any、never、void" class="headerlink" title="2.11 我们要搞明白any、never、void"></a>2.11 我们要搞明白any、never、void</h3><ul><li><code>any</code>是任意的值</li><li><code>void</code>是不能有任何值</li><li><code>never</code>永远不会有返回值</li></ul><blockquote><p><code>any</code>比较好理解，就是任何值都可以</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str:any = <span class="string">"hello poetries"</span></span><br><span class="line">str = <span class="number">28</span></span><br><span class="line">str = <span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p><code>void</code>不能有任何值(返回值)</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>):<span class="title">void</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>never</code>则不好理解，什么叫永远不会有返回值？</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 除了上面举例的抛出异常以外，我们看一下这个例子</span></span><br><span class="line"><span class="comment">// 这个loop函数，一旦开始执行，就永远不会结束</span></span><br><span class="line"><span class="comment">// 可以看出在while中，是死循环，永远都不会有返回值，包括undefined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>):<span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"陷入死循环啦"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loop()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包括比如JSON.parse也是使用这种 never | any</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">str:string</span>):(<span class="params">never | any</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(str)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 首先在正常情况下，我们传一个JSON格式的字符串，是可以正常得到一个JSON对象的</span></span><br><span class="line"><span class="keyword">let</span> json = parse(<span class="string">'&#123;"name":"poetries"&#125;'</span>)</span><br><span class="line"><span class="comment">// 但是有时候，传进去的不一定是JSON格式的字符串，那么就会抛出异常</span></span><br><span class="line"><span class="comment">// 此时就需要never了</span></span><br><span class="line"><span class="keyword">let</span> json = parse(<span class="string">"iamswr"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>也就是说，当一个函数执行的时候，被抛出异常打断了，导致没有返回值或者该函数是一个死循环，永远没有返回值，这样叫做永远不会有返回值。</p></blockquote><p>实际开发中，是<code>never</code>和联合类型来一起用，比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>):(<span class="params">never | string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"ok"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、函数"><a href="#三、函数" class="headerlink" title="三、函数"></a>三、函数</h2><h3 id="3-1-函数定义"><a href="#3-1-函数定义" class="headerlink" title="3.1 函数定义"></a>3.1 函数定义</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name:string</span>):<span class="title">void</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-函数参数处理"><a href="#3-2-函数参数处理" class="headerlink" title="3.2 函数参数处理"></a>3.2 函数参数处理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数是这样定义的</span></span><br><span class="line"><span class="comment">// 形参和实参一一对应，完全一样</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name:string,age:number</span>):<span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>, name, age)</span><br><span class="line">&#125;</span><br><span class="line">sayHello(<span class="string">'poetries'</span>,<span class="number">22</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 形参和实参要完全一样，如想不一样，则需要配置可选参数，可选参数放在后面</span></span><br><span class="line"><span class="comment">// 可选参数，用 ？ 处理，只能放在后面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHelloToYou</span>(<span class="params">name:string,age?:number</span>):<span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>, name, age)</span><br><span class="line">&#125;</span><br><span class="line">sayHelloToYou(<span class="string">'poetries'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 那么如何设置默认参数呢？</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url:string,method:string = <span class="string">'GET'</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(url, method)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 那么如何设置剩余参数呢？可以利用扩展运算符</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...args:Array&lt;number&gt;</span>):<span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(args.join(<span class="string">"+"</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> total:number = sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(total)</span><br></pre></td></tr></table></figure><h3 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 那么如何实现函数重载呢？函数重载是java中非常有名的，在java中函数的重载，是指两个或者两个以上的同名函数，参数的个数和类型不一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比如我们现在有两个同名函数</span></span><br><span class="line"><span class="comment">// function eating(name:string) &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// function eating(name:string,age:number) &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 那么我想达到一个效果</span></span><br><span class="line"><span class="comment">// 当我传参数name时，执行name:string这个函数</span></span><br><span class="line"><span class="comment">// 当我传参数name和age时，执行name:string,age:number这个函数</span></span><br><span class="line"><span class="comment">// 此时该怎么办？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来看一下typescript中的函数重载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先声明两个函数名一样的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eating</span>(<span class="params">name: string</span>):<span class="title">void</span>;</span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">eating</span>(<span class="params">name: number</span>):<span class="title">void</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">eating</span>(<span class="params">name:any</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eating(<span class="string">"hello poetries"</span>)</span><br><span class="line">eating(<span class="number">22</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在typescript中主要体现是同一个同名函数提供多个函数类型定义，函数实际上就只有一个，就是拥有函数体那个，如果想根据传入值类型的不一样执行不同逻辑，则需要在这个函数里面进行一个类型判断。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 那么这个函数重载有什么作用呢？其实在ts中，函数重载只是用来限制参数的个数和类型，用来检查类型的，而且重载不能拆开几个函数，这一点和java的处理是不一样的，需要注意。</span></span><br></pre></td></tr></table></figure><h2 id="四、类"><a href="#四、类" class="headerlink" title="四、类"></a>四、类</h2><h3 id="4-1-定义一个类"><a href="#4-1-定义一个类" class="headerlink" title="4.1 定义一个类"></a>4.1 定义一个类</h3><blockquote><p>如何定义一个类？</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ts 写法</span></span><br><span class="line"><span class="comment">// 跟es6非常像 没有太大区别</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Persion</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里声明的变量 是实例上的属性</span></span><br><span class="line">    name: string;</span><br><span class="line">    age:number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(name: string, age: number)&#123;</span><br><span class="line">        <span class="comment">// this.name和this.age 必须先在前面声明好类型</span></span><br><span class="line">        <span class="comment">// name: string</span></span><br><span class="line">        <span class="comment">// age: number</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 原型方法</span></span><br><span class="line">    say():string &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello poetries'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Persion(<span class="string">'poetries'</span>, <span class="number">22</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 那么转为es5呢？</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Persion = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Persion</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// this.name和this.age 必须先在前面声明好类型</span></span><br><span class="line">        <span class="comment">// name: string</span></span><br><span class="line">        <span class="comment">// age: number</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 原型方法</span></span><br><span class="line">    Persion.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello poetries'</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> Persion;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Persion(<span class="string">'poetries'</span>, <span class="number">22</span>);</span><br></pre></td></tr></table></figure><h3 id="4-2-类的继承"><a href="#4-2-类的继承" class="headerlink" title="4.2 类的继承"></a>4.2 类的继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 和es6也是差不多</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">    <span class="keyword">constructor</span>(name:string, age: number)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    say():string&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello poetries'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    childName: string;</span><br><span class="line">    <span class="keyword">constructor</span>(name: string,age:number,childName:string) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name,age)</span><br><span class="line">        <span class="keyword">this</span>.childName = childName</span><br><span class="line">    &#125;</span><br><span class="line">    childSay():string &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.childName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child(<span class="string">'poetries'</span>, <span class="number">22</span>, <span class="string">'静观流叶'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(child)</span><br></pre></td></tr></table></figure><h3 id="4-3-类的修饰符"><a href="#4-3-类的修饰符" class="headerlink" title="4.3 类的修饰符"></a>4.3 类的修饰符</h3><ul><li><code>public</code>公开的，可以供自己、子类以及其它类访问</li><li><code>protected</code>受保护的，可以供自己、子类访问，但是其他就访问不了</li><li><code>private</code>私有的，只有自己访问，而子类、其他都访问不了</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parents</span> </span>&#123;</span><br><span class="line">    public name:string;</span><br><span class="line">    protected age:number;</span><br><span class="line">    private money:number;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 简写</span></span><br><span class="line">   <span class="comment">// constructor(public name:string,protected age:number,private money:number)</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">constructor</span>(name: string, age:number,money:number) &#123;</span><br><span class="line">       <span class="keyword">this</span>.name = name;</span><br><span class="line">       <span class="keyword">this</span>.age = age;</span><br><span class="line">       <span class="keyword">this</span>.money = money;</span><br><span class="line">   &#125;</span><br><span class="line">   getName():string &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">   &#125;</span><br><span class="line">   getAge():number&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.age</span><br><span class="line">   &#125;</span><br><span class="line">   getMoney():number&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.money</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> pare = <span class="keyword">new</span> Parents(<span class="string">'poetries'</span>, <span class="number">22</span>, <span class="number">3000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(pare.name)</span><br><span class="line"><span class="comment">// console.log(pare.age)  报错</span></span><br><span class="line"><span class="comment">// console.log(pare.money) 报错</span></span><br></pre></td></tr></table></figure><h3 id="4-4-静态属性、静态方法"><a href="#4-4-静态属性、静态方法" class="headerlink" title="4.4 静态属性、静态方法"></a>4.4 静态属性、静态方法</h3><p>跟<code>es6</code>差不多</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 类的静态属性</span></span><br><span class="line">    <span class="keyword">static</span> name1 = <span class="string">'poetries'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类的静态方法</span></span><br><span class="line">    <span class="keyword">static</span> say() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello poetries'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> per2 = <span class="keyword">new</span> Person2()</span><br><span class="line">Person2.say() <span class="comment">// hello poetries</span></span><br><span class="line"><span class="comment">// per2.say() 报错</span></span><br></pre></td></tr></table></figure><h3 id="4-5-抽象类"><a href="#4-5-抽象类" class="headerlink" title="4.5 抽象类"></a>4.5 抽象类</h3><ul><li>抽象类和方法，有点类似抽取共性出来，但是又不是具体化，比如说，世界上的动物都需要吃东西，那么会把吃东西这个行为，抽象出来</li><li>如果子类继承的是一个抽象类，子类必须实现父类里的抽象方法，不然的话不能实例化，会报错</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/ 关键字 abstract抽象</span><br><span class="line"><span class="comment">// 定义抽象类</span></span><br><span class="line"></span><br><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实际上是使用了public修饰符</span></span><br><span class="line">    <span class="comment">// 如果添加private修饰符会报错</span></span><br><span class="line">    abstract eat():<span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要注意的是这个Animal是不能实例化的</span></span><br><span class="line"><span class="comment">// let animal = new Animal() // 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// // 抽象类的抽象方法，意思就是，需要在继承这个抽象类的子类中</span></span><br><span class="line"><span class="comment">// 实现这个抽象方法，不然会报错</span></span><br><span class="line"><span class="comment">// 报错，因为在子类中没有实现eat抽象方法</span></span><br><span class="line"><span class="comment">// class Person4 extends Animal&#123;</span></span><br><span class="line"><span class="comment">//     test()&#123;</span></span><br><span class="line"><span class="comment">//         console.log("吃米饭")</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dog类继承Animal类后并且实现了抽象方法eat，所以不会报错</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    eat()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"吃骨头"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、接口"><a href="#五、接口" class="headerlink" title="五、接口"></a>五、接口</h2><blockquote><p>这里的接口，主要是一种规范，规范某些类必须遵守规范，和抽象类有点类似，但是不局限于类，还有属性、函数等</p></blockquote><h3 id="5-1-接口规范对象"><a href="#5-1-接口规范对象" class="headerlink" title="5.1 接口规范对象"></a>5.1 接口规范对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//假设我们需要获取用户信息</span></span><br><span class="line"><span class="comment">// 我们通过这样的方式 规范必须传name和age的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInfo</span>(<span class="params">user:&#123;name:string,age:number&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(user.name,user.age)</span><br><span class="line">&#125;</span><br><span class="line">getUserInfo(&#123;<span class="attr">name</span>: <span class="string">'poetries'</span>, <span class="attr">age</span>: <span class="number">22</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样看挺完美的， 那么问题就出现了，如果我另外还有一个方法，也是需要这个规范呢？</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInfo1</span>(<span class="params">user:&#123;name:string,age:number&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;user.name&#125;</span> <span class="subst">$&#123;user.age&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">user:&#123;name:string,age:number&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;user.name&#125;</span> <span class="subst">$&#123;user.age&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">getUserInfo1(&#123;<span class="attr">name</span>:<span class="string">"poetries"</span>,<span class="attr">age</span>:<span class="number">22</span>&#125;)</span><br><span class="line">getInfo(&#123;<span class="attr">name</span>:<span class="string">"poetries"</span>,<span class="attr">age</span>:<span class="number">22</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以看出，函数getUserInfo和getInfo都遵循同一个规范，那么我们有办法对这个规范复用吗？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先把需要复用的规范，写到接口 关键字interface</span></span><br><span class="line">interface infoInterface &#123;</span><br><span class="line">    name: string,</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 然后把这个接口 替换到我们需要复用的地方</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInfo2</span>(<span class="params">user:infoInterface</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(user.name,user.age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo2</span>(<span class="params">user:infoInterface</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(user.name,user.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getUserInfo2(&#123;<span class="attr">name</span>:<span class="string">"poetries"</span>,<span class="attr">age</span>:<span class="number">22</span>&#125;)</span><br><span class="line">getInfo2(&#123;<span class="attr">name</span>:<span class="string">"poetries"</span>,<span class="attr">age</span>:<span class="number">22</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 那么有些参数可传可不传，该怎么处理呢？</span></span><br><span class="line"></span><br><span class="line">interface infoInterface2&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">    city?:string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInfo3</span>(<span class="params">user:infoInterface2</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;user.name&#125;</span> <span class="subst">$&#123;user.age&#125;</span> <span class="subst">$&#123;user.city&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo3</span>(<span class="params">user:infoInterface</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;user.name&#125;</span> <span class="subst">$&#123;user.age&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">getUserInfo3(&#123;<span class="attr">name</span>:<span class="string">"poetries"</span>,<span class="attr">age</span>:<span class="number">22</span>,<span class="attr">city</span>:<span class="string">"深圳"</span>&#125;)</span><br><span class="line">getInfo3(&#123;<span class="attr">name</span>:<span class="string">"iamswr"</span>,<span class="attr">age</span>:<span class="number">22</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="5-2-接口规范函数"><a href="#5-2-接口规范函数" class="headerlink" title="5.2 接口规范函数"></a>5.2 接口规范函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对一个函数的参数和返回值进行规范</span></span><br><span class="line">interface mytotal &#123;</span><br><span class="line">    <span class="comment">// 左侧是函数的参数，右侧是函数的返回类型</span></span><br><span class="line">    (a:number,<span class="attr">b</span>:number):number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> totalSum:mytotal = <span class="function"><span class="keyword">function</span>(<span class="params">a:number,b:number</span>):<span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(totalSum(<span class="number">10</span>, <span class="number">20</span>))</span><br></pre></td></tr></table></figure><h3 id="5-3-接口规范数组"><a href="#5-3-接口规范数组" class="headerlink" title="5.3 接口规范数组"></a>5.3 接口规范数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface userInterface &#123;</span><br><span class="line">    <span class="comment">// index为数组索引 类型是number</span></span><br><span class="line">    <span class="comment">// 右边是数组里为字符串的数组成员</span></span><br><span class="line">    [index: number]: string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arrTest: userInterface = [<span class="string">'poetries'</span>, <span class="string">'静观流叶'</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arrTest)</span><br></pre></td></tr></table></figure><h3 id="5-4-接口规范类"><a href="#5-4-接口规范类" class="headerlink" title="5.4 接口规范类"></a>5.4 接口规范类</h3><blockquote><p>这个比较重要，因为写<code>react</code>的时候会经常使用到类</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先实现一个接口</span></span><br><span class="line">interface Animal2 &#123;</span><br><span class="line">    <span class="comment">// 这个类必须有name</span></span><br><span class="line">    name:string;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个类必须有eat方法</span></span><br><span class="line">    eat(any:string):<span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键字implements实现</span></span><br><span class="line"><span class="comment">// 因为接口是抽象的，需要通过子类是实现它</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person6</span> <span class="title">implements</span> <span class="title">Animal2</span> </span>&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    <span class="keyword">constructor</span>(name: string) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    eat(any:string):<span class="keyword">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`吃`</span>+any)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果想遵循多个接口</span></span><br><span class="line"></span><br><span class="line">interface Animal3 &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    eat(any: string):<span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新增一个接口</span></span><br><span class="line">interface Animal4 &#123;</span><br><span class="line">    sleep():<span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以在implements后面通过逗号添加和java一样</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person7</span> <span class="title">implements</span> <span class="title">Animal3</span>,<span class="title">Animal4</span> </span>&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    <span class="keyword">constructor</span>(name:string)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    eat(any:string) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`吃`</span>+any)</span><br><span class="line">    &#125;</span><br><span class="line">    sleep() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'睡觉'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-接口继承接口"><a href="#5-5-接口继承接口" class="headerlink" title="5.5 接口继承接口"></a>5.5 接口继承接口</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">interface Animal5&#123;</span><br><span class="line">    name:string;</span><br><span class="line">    eat(any:string):<span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 像类一样 通过extends继承</span></span><br><span class="line">interface Animal6 extends Animal5 &#123;</span><br><span class="line">    sleep():<span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为Animal6类继承了Animal5</span></span><br><span class="line"><span class="comment">// 所以这里遵循Animal6就相当于把Animal5也继承了</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person8</span> <span class="title">implements</span> <span class="title">Animal2</span> </span>&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    <span class="keyword">constructor</span>(name:string) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    eat(any:string):<span class="keyword">void</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`吃<span class="subst">$&#123;any&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    sleep()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'睡觉'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、泛型"><a href="#六、泛型" class="headerlink" title="六、泛型"></a>六、泛型</h2><h3 id="6-1-函数的泛型"><a href="#6-1-函数的泛型" class="headerlink" title="6.1 函数的泛型"></a>6.1 函数的泛型</h3><blockquote><p>泛型可以支持不特定的数据类型，什么叫不特定呢？比如我们有一个方法，里面接收参数，但是参数类型我们是不知道，但是这个类型在方法里面很多地方会用到，参数和返回值要保持一致性</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们有一个需求，我们不知道函数接收什么类型的参数，也不知道返回值的类型</span></span><br><span class="line"><span class="comment">// 而我们又需要传进去的参数类型和返回值的类型保持一致，那么我们就需要用到泛型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;T&gt;的意思是泛型，即generic type</span></span><br><span class="line"><span class="comment">// 可以看出value的类型也为T，返回值的类型也为T</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deal</span>&lt;<span class="title">T</span>&gt;(<span class="params">value:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下面的&lt;string&gt;、&lt;number&gt;实际上用的时候再传给上面的&lt;T&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(deal&lt;string&gt;(<span class="string">"poetries"</span>))</span><br><span class="line"><span class="built_in">console</span>.log(deal&lt;number&gt;(<span class="number">22</span>))</span><br></pre></td></tr></table></figure><blockquote><p>实际上，泛型用得还是比较少，主要是看类的泛型是如何使用的</p></blockquote><h3 id="6-2-类的泛型"><a href="#6-2-类的泛型" class="headerlink" title="6.2 类的泛型"></a>6.2 类的泛型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMath</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个私有属性</span></span><br><span class="line"></span><br><span class="line">    private arr: T[] = []</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规定传参类型</span></span><br><span class="line">    add(value: T) &#123;</span><br><span class="line">        <span class="keyword">this</span>.arr.push(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里规定了类型为number</span></span><br><span class="line"><span class="comment">// 相当于把T替换为number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mymath = <span class="keyword">new</span> MyMath&lt;number&gt;()</span><br><span class="line">mymath.add(<span class="number">1</span>)</span><br><span class="line">mymath.add(<span class="number">2</span>)</span><br><span class="line">mymath.add(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><strong>有了接口为什么还需要抽象类？</strong></p><blockquote><p>接口里面只能放定义，抽象类里面可以放普通类、普通类的方法、定义抽象的东西。</p></blockquote><h1 id="第二部分-结合React实践"><a href="#第二部分-结合React实践" class="headerlink" title="第二部分 结合React实践"></a>第二部分 结合React实践</h1><h2 id="一、环境配置"><a href="#一、环境配置" class="headerlink" title="一、环境配置"></a>一、环境配置</h2><h3 id="1-1-初始化项目"><a href="#1-1-初始化项目" class="headerlink" title="1.1 初始化项目"></a>1.1 初始化项目</h3><ul><li>生成一个目录<code>ts_react_demo</code>，输入<code>npm init -y</code>初始化项目</li><li>然后在项目里我们需要一个<code>.gitignore</code>来忽略指定目录不传到<code>git</code>上</li><li>进入<code>.gitignore</code>输入我们需要忽略的目录，一般是<code>node_modules</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// .gitignore</span><br><span class="line">node_modules</span><br></pre></td></tr></table></figure><h3 id="1-2-安装依赖"><a href="#1-2-安装依赖" class="headerlink" title="1.2 安装依赖"></a>1.2 安装依赖</h3><blockquote><p>接下来我们准备下载相应的依赖包，这里需要了解一个概念，就是类型定义文件</p></blockquote><h4 id="1-2-1-类型定义文件"><a href="#1-2-1-类型定义文件" class="headerlink" title="1.2.1 类型定义文件"></a>1.2.1 类型定义文件</h4><blockquote><p>因为目前主流的第三方库都是以<code>javascript</code>编写的，如果用<code>typescript</code>开发，会导致在编译的时候会出现很多找不到类型的提示，那么如果让这些库也能在<code>ts</code>中使用呢？</p></blockquote><ul><li>类型定义文件(<code>*.d.ts</code>)就是能够让编辑器或者插件来检测到第三方库中<code>js</code>的静态类型，这个文件是以<code>.d.ts</code>结尾- 比如说<code>react</code>的类型定义文件：<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react" target="_blank" rel="noopener">https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react</a></li><li>在<code>typescript2.0</code>中，是使用<code>@type</code>来进行类型定义，当我们使用<code>@type</code>进行类型定义，<code>typescript</code>会默认查看<code>./node_modules/@types</code>文件夹，可以通过这样来安装这个库的定义库<code>npm install @types/react --save</code></li></ul><h4 id="1-2-2-相关依赖包"><a href="#1-2-2-相关依赖包" class="headerlink" title="1.2.2 相关依赖包"></a>1.2.2 相关依赖包</h4><p><strong>React相关</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- react // react的核心文件</span><br><span class="line">- @types/react // 声明文件</span><br><span class="line">- react-dom // react dom的操作包</span><br><span class="line">- @types/react-dom </span><br><span class="line">- react-router-dom // react路由包</span><br><span class="line">- @types/react-router-dom</span><br><span class="line">- react-redux</span><br><span class="line">- @types/react-redux</span><br><span class="line">- redux-thunk  // 中间件</span><br><span class="line">- @types/redux-logger</span><br><span class="line">- redux-logger // 中间件</span><br><span class="line">- connected-react-router</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 执行安装依赖包</span></span><br><span class="line"></span><br><span class="line">npm i react react-dom @types/react @types/react-dom react-router-dom @types/react-router-dom react-redux @types/react-redux redux-thunk redux-logger @types/redux-logger connected-react-router -S</span><br></pre></td></tr></table></figure><p><strong>webpack相关</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- webpack // webpack的核心包</span><br><span class="line">- webpack-cli // webapck的工具包</span><br><span class="line">- webpack-dev-server // webpack的开发服务</span><br><span class="line">- html-webpack-plugin // webpack的插件，可以生成index.html文件</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack webpack-cli webpack-dev-server html-webpack-plugin -D</span><br></pre></td></tr></table></figure><blockquote><p>这里的<code>-D</code>相当于<code>--save-dev</code>的缩写，下载开发环境的依赖包</p></blockquote><p><strong>typescript相关</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- typescript // ts的核心包</span><br><span class="line">- ts-loader // 把ts编译成指定语法比如es5 es6等的工具，有了它，基本不需要babel了，因为它会把我们的代码编译成es5</span><br><span class="line">- source-map-loader // 用于开发环境中调试ts代码</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i typescript ts-loader source-map-loader -D</span><br></pre></td></tr></table></figure><ul><li>从上面可以看出，基本都是模块和声明文件都是一对对出现的，有一些不是一对对出现，就是因为都集成到一起去了</li><li>声明文件可以在<code>node_modules/@types/xx/xx</code>中找到</li></ul><h3 id="1-3-Typescript-config配置"><a href="#1-3-Typescript-config配置" class="headerlink" title="1.3 Typescript config配置"></a>1.3 Typescript config配置</h3><blockquote><p>首先我们要生成一个<code>tsconfig.json</code>来告诉<code>ts-loader</code>怎样去编译这个<code>ts</code>代码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></table></figure><blockquote><p>会在项目中生成了一个<code>tsconfig.json</code>文件，接下来进入这个文件，来修改相关配置</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tsconfig.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 编译选项</span></span><br><span class="line">  <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="string">"target"</span>: <span class="string">"es5"</span>, <span class="comment">// 编译成es5语法</span></span><br><span class="line">    <span class="string">"module"</span>: <span class="string">"commonjs"</span>, <span class="comment">// 模块的类型</span></span><br><span class="line">    <span class="string">"outDir"</span>: <span class="string">"./dist"</span>, <span class="comment">// 编译后的文件目录</span></span><br><span class="line">    <span class="string">"sourceMap"</span>: <span class="literal">true</span>, <span class="comment">// 生成sourceMap方便我们在开发过程中调试</span></span><br><span class="line">    <span class="string">"noImplicitAny"</span>: <span class="literal">true</span>, <span class="comment">// 每个变量都要标明类型</span></span><br><span class="line">    <span class="string">"jsx"</span>: <span class="string">"react"</span>, <span class="comment">// jsx的版本,使用这个就不需要额外使用babel了，会编译成React.createElement</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 为了加快整个编译过程，我们指定相应的路径</span></span><br><span class="line">  <span class="string">"include"</span>: [</span><br><span class="line">    <span class="string">"./src/**/*"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-webpack配置"><a href="#1-4-webpack配置" class="headerlink" title="1.4 webpack配置"></a>1.4 webpack配置</h3><blockquote><p>在<code>./src/</code>下创建一个<code>index.html</code>文件，并且添加<code>&lt;div id=&#39;app&#39;&gt;&lt;/div&gt;</code>标签</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在<code>./</code>下创建一个<code>webpack</code>配置文件<code>webpack.config.js</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./webpack.config.js</span></span><br><span class="line"><span class="comment">// 引入webpack</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"><span class="comment">// 引入webpack插件 生成index.html文件</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">"html-webpack-plugin"</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把模块导出</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 以前是jsx，因为我们用typescript写，所以这里后缀是tsx</span></span><br><span class="line">  entry:<span class="string">"./src/index.tsx"</span>,</span><br><span class="line">  <span class="comment">// 指定模式为开发模式</span></span><br><span class="line">  mode:<span class="string">"development"</span>,</span><br><span class="line">  <span class="comment">// 输出配置</span></span><br><span class="line">  output:&#123;</span><br><span class="line">    <span class="comment">// 输出目录为当前目录下的dist目录</span></span><br><span class="line">    path:path.resolve(__dirname,<span class="string">'dist'</span>),</span><br><span class="line">    <span class="comment">// 输出文件名</span></span><br><span class="line">    filename:<span class="string">"index.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 为了方便调试，还要配置一下调试工具</span></span><br><span class="line">  devtool:<span class="string">"source-map"</span>,</span><br><span class="line">  <span class="comment">// 解析路径，查找模块的时候使用</span></span><br><span class="line">  resolve:&#123;</span><br><span class="line">    <span class="comment">// 一般写模块不会写后缀，在这里配置好相应的后缀，那么当我们不写后缀时，会按照这个后缀优先查找</span></span><br><span class="line">    extensions:[<span class="string">".ts"</span>,<span class="string">'.tsx'</span>,<span class="string">'.js'</span>,<span class="string">'.json'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 解析处理模块的转化</span></span><br><span class="line">  <span class="built_in">module</span>:&#123;</span><br><span class="line">    <span class="comment">// 遵循的规则</span></span><br><span class="line">    rules:[</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 如果这个模块是.ts或者.tsx，则会使用ts-loader把代码转成es5</span></span><br><span class="line">        test:<span class="regexp">/\.tsx?$/</span>,</span><br><span class="line">        loader:<span class="string">"ts-loader"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 使用sourcemap调试</span></span><br><span class="line">        <span class="comment">// enforce:pre表示这个loader要在别的loader执行前执行</span></span><br><span class="line">        enforce:<span class="string">"pre"</span>,</span><br><span class="line">        test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">        loader:<span class="string">"source-map-loader"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 插件的配置</span></span><br><span class="line">  plugins:[</span><br><span class="line">    <span class="comment">// 这个插件是生成index.html</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 以哪个文件为模板，模板路径</span></span><br><span class="line">      template:<span class="string">"./src/index.html"</span>,</span><br><span class="line">      <span class="comment">// 编译后的文件名</span></span><br><span class="line">      filename:<span class="string">"index.html"</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 开发环境服务配置</span></span><br><span class="line">  devServer:&#123;</span><br><span class="line">    <span class="comment">// 启动热更新,当模块、组件有变化，不会刷新整个页面，而是局部刷新</span></span><br><span class="line">    <span class="comment">// 需要和插件webpack.HotModuleReplacementPlugin配合使用</span></span><br><span class="line">    hot:<span class="literal">true</span>, </span><br><span class="line">    <span class="comment">// 静态资源目录</span></span><br><span class="line">    contentBase:path.resolve(__dirname,<span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>那么我们怎么运行这个<code>webpack.config.js</code>呢？这就需要我们在<code>package.json</code>配置一下脚本</p></blockquote><ul><li>在<code>package.json</code>里的<code>script</code>，添加<code>build</code>和<code>dev</code>的配置</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"ts_react_demo"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack"</span>,</span><br><span class="line">    <span class="attr">"dev"</span>:<span class="string">"webpack-dev-server"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"keywords"</span>: [],</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"@types/react"</span>: <span class="string">"^16.7.13"</span>,</span><br><span class="line">    <span class="attr">"@types/react-dom"</span>: <span class="string">"^16.0.11"</span>,</span><br><span class="line">    <span class="attr">"@types/react-redux"</span>: <span class="string">"^6.0.10"</span>,</span><br><span class="line">    <span class="attr">"@types/react-router-dom"</span>: <span class="string">"^4.3.1"</span>,</span><br><span class="line">    <span class="attr">"connected-react-router"</span>: <span class="string">"^5.0.1"</span>,</span><br><span class="line">    <span class="attr">"react"</span>: <span class="string">"^16.6.3"</span>,</span><br><span class="line">    <span class="attr">"react-dom"</span>: <span class="string">"^16.6.3"</span>,</span><br><span class="line">    <span class="attr">"react-redux"</span>: <span class="string">"^6.0.0"</span>,</span><br><span class="line">    <span class="attr">"react-router-dom"</span>: <span class="string">"^4.3.1"</span>,</span><br><span class="line">    <span class="attr">"redux-logger"</span>: <span class="string">"^3.0.6"</span>,</span><br><span class="line">    <span class="attr">"redux-thunk"</span>: <span class="string">"^2.3.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"html-webpack-plugin"</span>: <span class="string">"^3.2.0"</span>,</span><br><span class="line">    <span class="attr">"source-map-loader"</span>: <span class="string">"^0.2.4"</span>,</span><br><span class="line">    <span class="attr">"ts-loader"</span>: <span class="string">"^5.3.1"</span>,</span><br><span class="line">    <span class="attr">"typescript"</span>: <span class="string">"^3.2.1"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.27.1"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.1.2"</span>,</span><br><span class="line">    <span class="attr">"webpack-dev-server"</span>: <span class="string">"^3.1.10"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>因为入口文件是<code>index.tsx</code>，那么我们在<code>./src/</code>下创建一个<code>index.tsx</code>，并且在里面写入一段代码，看看<code>webpack</code>是否能够正常编译</li><li>因为我们在<code>webpack.config.js</code>中<code>entry</code>设置的入口文件是<code>index.tsx</code>，并且在<code>module</code>中的<code>rules</code>会识别到<code>.tsx</code>格式的文件，然后执行相应的<code>ts-loader</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// ./src/index.tsx</span><br><span class="line">console.log(&quot;hello poetries&quot;)</span><br></pre></td></tr></table></figure><ul><li>接下来我们<code>npm run build</code>一下，看看能不能正常编译</li><li>编译成功，我们可以看看<code>./dist/</code>下生成了<code>index.html index.js index.js.map</code>三个文件</li><li>那么我们在开发过程中，不会每次都<code>npm run build</code>来看修改的结果，那么我们平时开发过程中可以使用<code>npm run dev</code>。这样就启动成功了一个<code>http://localhost:8080/</code>的服务了。</li><li>接下来我们看看热更新是否配置正常，在<code>./src/index.tsx</code>中新增一个<code>console.log(&#39;hello poetries&#39;)</code>，我们发现浏览器的控制台会自动打印出这一个输出，说明配置正常了</li></ul><h2 id="二、React组件"><a href="#二、React组件" class="headerlink" title="二、React组件"></a>二、React组件</h2><h3 id="2-1-写一个计数器组件"><a href="#2-1-写一个计数器组件" class="headerlink" title="2.1 写一个计数器组件"></a>2.1 写一个计数器组件</h3><blockquote><p>首先我们在<code>./src/</code>下创建一个文件夹<code>components</code>，然后在<code>./src/components/</code>下创建文件<code>Counter.tsx</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/components/Counter.tsx</span></span><br><span class="line"><span class="comment">// import React from "react"; // 之前的写法</span></span><br><span class="line"><span class="comment">// 在ts中引入的写法</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="comment">// 状态state</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    number:<span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;<span class="keyword">this</span>.state.number&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;()=&gt;this.setState(&#123;number:this.state.number + 1&#125;)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>我们发现，其实除了引入<code>import * as React from &quot;react&quot;</code>以外，其余的和之前的写法没什么不同。</p></blockquote><ul><li>接下来我们到<code>./src/index.tsx</code>中把这个组件导进来</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/index.tsx</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ReactDom <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> CounterComponent <span class="keyword">from</span> <span class="string">"./components/Counter"</span>;</span><br><span class="line"><span class="comment">// 把我们的CounterComponent组件渲染到id为app的标签内</span></span><br><span class="line">ReactDom.render(<span class="xml"><span class="tag">&lt;<span class="name">CounterComponent</span> /&gt;</span>,document.getElementById("app"))</span></span><br></pre></td></tr></table></figure><blockquote><p>这样我们就把这个组件引进来了，接下来我们看下是否能够成功跑起来</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-86ad083c5149a72e.png" alt="image.png"></p><blockquote><p>到目前为止，感觉用<code>ts</code>写<code>react</code>还是跟以前差不多，没什么区别，要记住，<code>ts</code>最大的特点就是类型检查，可以检验属性的状态类型</p></blockquote><p>假设我们需要在<code>./src/index.tsx</code>中给<code>&lt;CounterComponent /&gt;</code>传一个属性<code>name</code>，而<code>CounterComponent</code>组件需要对这个传入的<code>name</code>进行类型校验，比如说只允许传字符串</p><ul><li><code>./src/index.tsx</code>中修改一下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDom.render(&lt;CounterComponent name=&quot;poetries&quot; /&gt;,document.getElementById(&quot;app&quot;))</span><br></pre></td></tr></table></figure><blockquote><p>然后需要在<code>./src/components/Counter.tsx</code>中写一个接口来对这个<code>name</code>进行类型校验</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import React from "react"; // 之前的写法</span></span><br><span class="line"><span class="comment">// 在ts中引入的写法</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写一个接口对name进行类型校验</span></span><br><span class="line"><span class="comment">// 如果我们不写校验的话，在外部传name进来会报错的</span></span><br><span class="line">interface IProps&#123;</span><br><span class="line">    name:string,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们还可以用接口约束state的状态</span></span><br><span class="line">interface IState&#123;</span><br><span class="line">    number: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把接口约束的规则写在这里</span></span><br><span class="line"><span class="comment">// 如果传入的name不符合类型会报错</span></span><br><span class="line"><span class="comment">// 如果state的number属性不符合类型也会报错</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>&lt;<span class="title">IProps</span>,<span class="title">IState</span>&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 状态state</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    number:<span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;<span class="keyword">this</span>.state.number&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;&#123;this.props.name&#125;&lt;/</span>p&gt;</span><br><span class="line">        &lt;button onClick=&#123;()=&gt;<span class="keyword">this</span>.setState(&#123;<span class="attr">number</span>:<span class="keyword">this</span>.state.number + <span class="number">1</span>&#125;)&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-结合Redux使用"><a href="#2-2-结合Redux使用" class="headerlink" title="2.2 结合Redux使用"></a>2.2 结合Redux使用</h3><h4 id="2-2-1-基础使用"><a href="#2-2-1-基础使用" class="headerlink" title="2.2.1 基础使用"></a>2.2.1 基础使用</h4><ul><li>上面<code>state</code>中的<code>number</code>就不放在组件里了，我们放到<code>redux</code>中，接下来我们使用<code>redux</code></li><li>首先在<code>./src/</code>创建<code>store</code>目录，然后在<code>./src/store/</code>创建一个文件<code>index.tsx</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .src/store/index.tsx</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入reducers</span></span><br><span class="line"><span class="keyword">import</span> reducers <span class="keyword">from</span> <span class="string">"./reducers"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接着创建仓库</span></span><br><span class="line"><span class="keyword">let</span> store = createStore(reducers);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出store仓库</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure><ul><li>然后我们需要创建一个<code>reducers</code>，在<code>./src/store/</code>创建一个目录<code>reducers</code>，该目录下再创建一个文件<code>index.tsx</code>。</li><li>但是我们还需要对<code>reducers</code>中的函数参数进行类型校验，而且这个类型校验很多地方需要复用，那么我们需要把这个类型校验单独抽离出一个文件。</li><li>那么我们需要在<code>./src/</code>下创建一个<code>types</code>目录，该目录下创建一个文件<code>index.tsx</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/types/index.tsx</span></span><br><span class="line"><span class="comment">// 导出一个接口</span></span><br><span class="line"><span class="keyword">export</span> interface Store&#123;</span><br><span class="line">  <span class="comment">// 我们需要约束的属性和类型</span></span><br><span class="line">  number:number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>回到<code>./src/store/reducers/index.tsx</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入类型校验的接口</span></span><br><span class="line"><span class="comment">// 用来约束state的</span></span><br><span class="line"><span class="keyword">import</span> &#123; Store &#125; <span class="keyword">from</span> <span class="string">"../../types/index"</span></span><br><span class="line"><span class="comment">// 我们需要给number赋予默认值</span></span><br><span class="line"><span class="keyword">let</span> initState:Store = &#123; <span class="attr">number</span>:<span class="number">0</span> &#125;</span><br><span class="line"><span class="comment">// 把接口写在state:Store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">state:Store=initState,action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 拿到老的状态state和新的状态action</span></span><br><span class="line">  <span class="comment">// action是一个动作行为，而这个动作行为，在计数器中是具备 加 或 减 两个功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面这段代码暂时先这样，因为需要用到<code>action</code>，我们现在去配置一下<code>action</code>相关的，首先我们在<code>./src/store</code>下创建一个<code>actions</code>目录，并且在该目录下创建文件<code>counter.tsx</code></li><li>因为配置<code>./src/store/actions/counter.tsx</code>会用到动作类型，而这个动作类型是属于常量，为了更加规范我们的代码，我们在<code>./src/store/</code>下创建一个<code>action-types.tsx</code>，里面写相应常量</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/store/action-types.tsx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD = <span class="string">"ADD"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SUBTRACT = <span class="string">"SUBTRACT"</span>;</span><br></pre></td></tr></table></figure><blockquote><p>回到<code>./src/store/actions/counter.tsx</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/store/actions/counter.tsx</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> types <span class="keyword">from</span> <span class="string">"../action-types"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  add()&#123;</span><br><span class="line">    <span class="comment">// 需要返回一个action对象</span></span><br><span class="line">    <span class="comment">// type为动作的类型</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">type</span>: types.ADD&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  subtract()&#123;</span><br><span class="line">    <span class="comment">// 需要返回一个action对象</span></span><br><span class="line">    <span class="comment">// type为动作的类型</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">type</span>: types.SUBTRACT&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们可以想一下，上面<code>return { type:types.ADD }</code>实际上是返回一个<code>action</code>对象，将来使用的时候，是会传到<code>./src/store/reducers/index.tsx</code>的<code>action</code>中，那么我们怎么定义这个<code>action</code>的结构呢？</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/store/actions/counter.tsx</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> types <span class="keyword">from</span> <span class="string">"../action-types"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义两个接口，分别约束add和subtract的type类型</span></span><br><span class="line"><span class="keyword">export</span> interface Add&#123;</span><br><span class="line">  type:<span class="keyword">typeof</span> types.ADD</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> interface Subtract&#123;</span><br><span class="line">  type:<span class="keyword">typeof</span> types.SUBTRACT</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再导出一个type</span></span><br><span class="line"><span class="comment">// type是用来给类型起别名的</span></span><br><span class="line"><span class="comment">// 这个actions里是一个对象，会有很多函数，每个函数都会返回一个action</span></span><br><span class="line"><span class="comment">// 而 ./store/reducers/index.tsx中的action会是下面某一个函数的返回值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type Action = Add | Subtract</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把上面定义好的接口作用于下面</span></span><br><span class="line"><span class="comment">// 约束返回值的类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  add():Add&#123;</span><br><span class="line">    <span class="comment">// 需要返回一个action对象</span></span><br><span class="line">    <span class="comment">// type为动作的类型</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">type</span>: types.ADD&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  subtract():Subtract&#123;</span><br><span class="line">    <span class="comment">// 需要返回一个action对象</span></span><br><span class="line">    <span class="comment">// type为动作的类型</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">type</span>: types.SUBTRACT&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接着我们回到<code>./store/reducers/index.tsx</code></p></blockquote><p>经过上面一系列的配置，我们可以给<code>action</code>使用相应的接口约束了并且根据不同的<code>action</code>动作行为来进行不同的处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./store/reducers/index.tsx</span></span><br><span class="line"><span class="comment">// 导入类型校验的接口</span></span><br><span class="line"><span class="comment">// 用来约束state的</span></span><br><span class="line"><span class="keyword">import</span> &#123; Store &#125; <span class="keyword">from</span> <span class="string">"../../types/index"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入约束action的接口</span></span><br><span class="line"><span class="keyword">import</span> &#123; Action &#125; <span class="keyword">from</span> <span class="string">"../actions/counter"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入action动作行为的常量</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> types <span class="keyword">from</span> <span class="string">"../action-types"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们需要给number赋予默认值</span></span><br><span class="line"><span class="keyword">let</span> initState:Store = &#123; <span class="attr">number</span>:<span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把接口写在state:Store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">state:Store=initState,action:Action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 拿到老的状态state和新的状态action</span></span><br><span class="line">  <span class="comment">// action是一个动作行为，而这个动作行为，在计数器中是具备 加 或 减 两个功能</span></span><br><span class="line">  <span class="comment">// 判断action的行为类型</span></span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> types.ADD:</span><br><span class="line">        <span class="comment">// 当action动作行为是ADD的时候，给number加1</span></span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">number</span>:state.number + <span class="number">1</span> &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> types.SUBTRACT:</span><br><span class="line">        <span class="comment">// 当action动作行为是SUBTRACT的时候，给number减1</span></span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">number</span>:state.number - <span class="number">1</span> &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 当没有匹配到则返回原本的state</span></span><br><span class="line">        <span class="keyword">return</span> state</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接下来，我们怎么样把组件和仓库建立起关系呢</p></blockquote><p>首先进入<code>./src/index.tsx</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/index.tsx</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ReactDom <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入redux这个库的Provider组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">"react-redux"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入仓库</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> CounterComponent <span class="keyword">from</span> <span class="string">"./components/Counter"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用Provider包裹CounterComponent组件</span></span><br><span class="line"><span class="comment">// 并且把store传给Provider</span></span><br><span class="line"><span class="comment">// 这样Provider可以向它的子组件提供store</span></span><br><span class="line">ReactDom.render((</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;CounterComponent name=<span class="string">"poetries"</span>/&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">),document.getElementById("app"))</span></span><br></pre></td></tr></table></figure><blockquote><p>我们到组件内部建立连接，<code>./src/components/Counter.tsx</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import React from "react"; // 之前的写法</span></span><br><span class="line"><span class="comment">// 在ts中引入的写法</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入connect，让组件和仓库建立连接</span></span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">"react-redux"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入actions，用于传给connect</span></span><br><span class="line"><span class="keyword">import</span> actions <span class="keyword">from</span> <span class="string">"../store/actions/counter"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入接口约束</span></span><br><span class="line"><span class="keyword">import</span> &#123; Store &#125; <span class="keyword">from</span> <span class="string">"../types"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口约束</span></span><br><span class="line">interface IProps&#123;</span><br><span class="line">  number:number,</span><br><span class="line"></span><br><span class="line">  name:string, <span class="comment">//如果我们不写校验的话，在外部传name进来会报错的</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// add是一个函数</span></span><br><span class="line">  add:any,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// subtract是一个函数</span></span><br><span class="line">  subtract:any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们还可以用接口约束state的状态</span></span><br><span class="line">interface IState&#123;</span><br><span class="line">    number: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把接口约束的规则写在这里</span></span><br><span class="line"><span class="comment">// 如果传入的name不符合类型会报错</span></span><br><span class="line"><span class="comment">// 如果state的number属性不符合类型也会报错</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>&lt;<span class="title">IProps</span>,<span class="title">IState</span>&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 状态state</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    number:<span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="comment">// 利用解构赋值取出</span></span><br><span class="line">    <span class="comment">// 这里比如和IProps保持一致，不对应则会报错，因为接口约束了必须这样</span></span><br><span class="line">    <span class="keyword">let</span> &#123; number,add,subtract &#125; = <span class="keyword">this</span>.props</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;&#123;<span class="keyword">this</span>.props.name&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;add&#125;&gt;+&lt;/</span>button&gt;<span class="xml"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;subtract&#125;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  </span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;number&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个connect需要执行两次，第二次需要我们把这个组件CounterComponent传进去</span></span><br><span class="line"><span class="comment">// connect第一次执行，需要两个参数，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要传给connect的函数</span></span><br><span class="line"><span class="keyword">let</span> mapStateToProps = <span class="function"><span class="keyword">function</span> (<span class="params">state:Store</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(</span><br><span class="line">    mapStateToProps,</span><br><span class="line">    actions</span><br><span class="line">)(CounterComponent);</span><br></pre></td></tr></table></figure><p>这时候看到成功执行了</p><p><img src="https://upload-images.jianshu.io/upload_images/1480597-32fc82d43dadb063.png" alt="image.png"></p><ul><li>其实搞来搞去，跟原来的写法差不多，主要就是<code>ts</code>会进行类型检查。</li><li>如果对<code>number</code>进行异步修改，该怎么处理？这就需要我们用到<code>redux-thunk</code></li></ul><blockquote><p>接着我们回到<code>./src/store/index.tsx</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要使用到thunk，所以引入中间件applyMiddleware</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入reducers</span></span><br><span class="line"><span class="keyword">import</span> reducers <span class="keyword">from</span> <span class="string">"./reducers"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入redux-thunk，处理异步</span></span><br><span class="line"><span class="comment">// 现在主流处理异步的是saga和thunk</span></span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">"redux-thunk"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入日志</span></span><br><span class="line"><span class="keyword">import</span> logger <span class="keyword">from</span> <span class="string">"redux-logger"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接着创建仓库和中间件</span></span><br><span class="line"><span class="keyword">let</span> store = createStore(reducers, applyMiddleware(thunk,logger));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出store仓库</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure><blockquote><p>接着我们回来<code>./src/store/actions</code>，新增一个异步的动作行为</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/store/actions/counter.tsx</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> types <span class="keyword">from</span> <span class="string">"../action-types"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义两个接口，分别约束add和subtract的type类型</span></span><br><span class="line"><span class="keyword">export</span> interface Add&#123;</span><br><span class="line">  type:<span class="keyword">typeof</span> types.ADD</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface Subtract&#123;</span><br><span class="line">  type:<span class="keyword">typeof</span> types.SUBTRACT</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 再导出一个type</span></span><br><span class="line"><span class="comment">// type是用来给类型起别名的</span></span><br><span class="line"><span class="comment">// 这个actions里是一个对象，会有很多函数，每个函数都会返回一个action</span></span><br><span class="line"><span class="comment">// 而 ./store/reducers/index.tsx中的action会是下面某一个函数的返回值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type Action = Add | Subtract</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把上面定义好的接口作用于下面</span></span><br><span class="line"><span class="comment">// 约束返回值的类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  add():Add&#123;</span><br><span class="line">    <span class="comment">// 需要返回一个action对象</span></span><br><span class="line">    <span class="comment">// type为动作的类型</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">type</span>: types.ADD&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  subtract():Subtract&#123;</span><br><span class="line">    <span class="comment">// 需要返回一个action对象</span></span><br><span class="line">    <span class="comment">// type为动作的类型</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">type</span>: types.SUBTRACT&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 一秒后才执行这个行为</span></span><br><span class="line">  <span class="comment">// ++</span></span><br><span class="line">  addAsync():any&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">dispatch:any,getState:any</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 当1秒过后，会执行dispatch，派发出去，然后改变仓库的状态</span></span><br><span class="line">        dispatch(&#123;<span class="attr">type</span>:types.ADD&#125;)</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>到<code>./src/components/Counter.tsx</code>组件内，使用这个异步</p></blockquote><h4 id="2-2-2-合并reducers"><a href="#2-2-2-合并reducers" class="headerlink" title="2.2.2 合并reducers"></a>2.2.2 合并reducers</h4><blockquote><p>假如我们的项目里面，有两个计数器，而且它俩是完全没有关系的，状态也是完全独立的，这个时候就需要用到合并<code>reducers</code>了</p></blockquote><ul><li>首先我们新增<code>action</code>的动作行为类型，在<code>./src/store/action-types.tsx</code></li><li>然后修改接口文件，<code>./src/types/index.tsx</code></li><li>然后把<code>./src/store/actions/counter.tsx</code>文件拷贝在当前目录并且修改名称为<code>counter2.tsx</code></li><li>然后把<code>./src/store/reduces/index.tsx</code>拷贝并且改名为<code>counter.tsx</code>和<code>counter2.tsx</code></li></ul><blockquote><p>我们多个<code>reducer</code>是通过<code>combineReducers</code>方法，进行合并的，因为我们一个项目当中肯定是存在非常多个<code>reducer</code>，所以统一在这里处理。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/store/reducers/index.tsc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入合并方法</span></span><br><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入需要合并的reducer</span></span><br><span class="line"><span class="keyword">import</span> counter <span class="keyword">from</span> <span class="string">"./counter"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入需要合并的reducer</span></span><br><span class="line"><span class="keyword">import</span> counter2 <span class="keyword">from</span> <span class="string">"./counter2"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line"><span class="keyword">let</span> reducers = combineReducers(&#123;</span><br><span class="line">  counter,</span><br><span class="line">  counter2,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> reducers;</span><br></pre></td></tr></table></figure><blockquote><p>最后修改组件，进入<code>./src/components/</code>,其中</p></blockquote><p>到目前为止，我们完成了<code>reducers</code>的合并了，那么我们看看效果如何，首先我们给<code>./src/index.tsc</code>添加<code>Counter2</code>组件，这样的目的是与<code>Counter</code>组件完全独立，互不影响，但是又能够最终合并到<code>readucers</code></p><p><img src="https://upload-images.jianshu.io/upload_images/1480597-b1980706114cbe84.png" alt="image.png"></p><h3 id="2-3-路由"><a href="#2-3-路由" class="headerlink" title="2.3 路由"></a>2.3 路由</h3><h4 id="2-3-1-基本用法"><a href="#2-3-1-基本用法" class="headerlink" title="2.3.1 基本用法"></a>2.3.1 基本用法</h4><blockquote><p>首先进入<code>./src/index.tsx</code>导入我们的路由所需要的依赖包</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/index.tsx</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ReactDom <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入redux这个库的Provider组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">"react-redux"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入路由</span></span><br><span class="line"><span class="comment">// 路由的容器:HashRouter as Router</span></span><br><span class="line"><span class="comment">// 路由的规格:Route</span></span><br><span class="line"><span class="comment">// Link组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter <span class="keyword">as</span> Router,Route,Link &#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入仓库</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> CounterComponent <span class="keyword">from</span> <span class="string">"./components/Counter"</span>;</span><br><span class="line"><span class="keyword">import</span> CounterComponent2 <span class="keyword">from</span> <span class="string">"./components/Counter2"</span>;</span><br><span class="line"><span class="keyword">import</span> Counter <span class="keyword">from</span> <span class="string">"./components/Counter"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>home<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用Provider包裹CounterComponent组件</span></span><br><span class="line"><span class="comment">// 并且把store传给Provider</span></span><br><span class="line"><span class="comment">// 这样Provider可以向它的子组件提供store</span></span><br><span class="line">ReactDom.render((</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &#123;<span class="comment">/* 路由组件 */</span>&#125;</span><br><span class="line">    &lt;Router&gt;</span><br><span class="line">      &#123;<span class="comment">/*  放两个路由规则需要在外层套个React.Fragment */</span>&#125;</span><br><span class="line">        &lt;React.Fragment&gt;</span><br><span class="line">            &#123;<span class="comment">/* 增加导航 */</span>&#125;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">            &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/counter"</span>&gt;</span>Counter<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">            &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/counter2"</span>&gt;</span>Counter2<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">            &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">            &#123;/</span>* 当路径为 / 时是home组件 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">            &#123;/</span>* 为了避免home组件一直渲染，我们可以添加属性exact *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">            &lt;Route exact path="/</span><span class="string">" component=&#123;Home&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/counter<span class="string">" component=&#123;CounterComponent&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/counter2<span class="string">" component=&#123;CounterComponent2&#125; /&gt;</span></span><br><span class="line"><span class="string">        &lt;/React.Fragment&gt;</span></span><br><span class="line"><span class="string">        &lt;/Router&gt;</span></span><br><span class="line"><span class="string">  &lt;/Provider&gt;</span></span><br><span class="line"><span class="string">),document.getElementById("</span>app<span class="string">"))</span></span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1480597-df85174da722a448.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>但是有个很大的问题，就是我们直接访问<code>http://localhost:8080/counter</code>会找不到路由</p></blockquote><ul><li>因为我们的是单页面应用，不管路由怎么变更，实际上都是访问<code>index.html</code>这个文件，所以当我们访问根路径的时候，能够正常访问，因为<code>index.html</code>文件就放在这个目录下，但是当我们通过非根路径的路由访问，则出错了，是因为我们在相应的路径没有这个文件，所以出错了</li><li>从这一点也可以衍生出一个实战经验，我们平时项目部署上线的时候，会出现这个问题，一般我们都是用<code>nginx</code>来把访问的路径都是指向<code>index.html</code>文件，这样就能够正常访问了。</li><li>那么针对目前我们这个情况，我们可以通过修改<code>webpack</code>配置，让路由不管怎么访问，都是指向我们制定的<code>index.html</code>文件。</li></ul><blockquote><p>进入<code>./webpack.config.js</code>，在<code>devServer</code>的配置对象下新增一些配置</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./webpack.config.js</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开发环境服务配置</span></span><br><span class="line">  devServer:&#123;</span><br><span class="line">    <span class="comment">// 启动热更新,当模块、组件有变化，不会刷新整个页面，而是局部刷新</span></span><br><span class="line">    <span class="comment">// 需要和插件webpack.HotModuleReplacementPlugin配合使用</span></span><br><span class="line">    hot:<span class="literal">true</span>, </span><br><span class="line">    <span class="comment">// 静态资源目录</span></span><br><span class="line">    contentBase:path.resolve(__dirname,<span class="string">'dist'</span>),</span><br><span class="line">    <span class="comment">// 不管访问什么路径，都重定向到index.html</span></span><br><span class="line">    historyApiFallback:&#123;</span><br><span class="line">      index:<span class="string">"./index.html"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>修改<code>webpack</code>配置需要重启服务，然后重启服务，看看浏览器能否正常访问<code>http://localhost:8080/counter</code></p></blockquote><h4 id="2-3-2-同步路由到redux"><a href="#2-3-2-同步路由到redux" class="headerlink" title="2.3.2 同步路由到redux"></a>2.3.2 同步路由到redux</h4><blockquote><p>路由的路径，如何同步到仓库当中。以前是用一个叫<code>react-router-redux</code>的库，把路由和<code>redux</code>结合到一起的，<code>react-router-redux</code>挺好用的，但是这个库不再维护了，被废弃了，所以现在推荐使用<code>connected-react-router</code>这个库，可以把路由状态映射到仓库当中</p></blockquote><blockquote><p>首先我们在<code>./src</code>下创建文件<code>history.tsx</code></p></blockquote><p>假设我有一个需求，就是我不通过<code>Link</code>跳转页面，而是通过编程式导航，触发一个动作，然后这个动作会派发出去，而且把路由信息放到<code>redux</code>中，供我以后查看。</p><blockquote><p>我们进入<code>./src/store/reducers/index.tsx</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入合并方法</span></span><br><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入需要合并的reducer</span></span><br><span class="line"><span class="keyword">import</span> counter <span class="keyword">from</span> <span class="string">"./counter"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入需要合并的reducer</span></span><br><span class="line"><span class="keyword">import</span> counter2 <span class="keyword">from</span> <span class="string">"./counter2"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入connectRouter</span></span><br><span class="line"><span class="keyword">import</span> &#123; connectRouter &#125; <span class="keyword">from</span> <span class="string">"connected-react-router"</span>;</span><br><span class="line"><span class="keyword">import</span> history <span class="keyword">from</span> <span class="string">"../../history"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line"><span class="keyword">let</span> reducers = combineReducers(&#123;</span><br><span class="line">  counter,</span><br><span class="line">  counter2,</span><br><span class="line">  <span class="comment">// 把history传到connectRouter函数中</span></span><br><span class="line">  router: connectRouter(history)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> reducers;</span><br></pre></td></tr></table></figure><blockquote><p>我们进入<code>./src/store/index.tsx</code>来添加中间件</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要使用到thunk，所以引入中间件applyMiddleware</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入reducers</span></span><br><span class="line"><span class="keyword">import</span> reducers <span class="keyword">from</span> <span class="string">"./reducers"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入redux-thunk，处理异步</span></span><br><span class="line"><span class="comment">// 现在主流处理异步的是saga和thunk</span></span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">"redux-thunk"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入日志</span></span><br><span class="line"><span class="keyword">import</span> logger <span class="keyword">from</span> <span class="string">"redux-logger"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入中间件</span></span><br><span class="line"><span class="keyword">import</span> &#123; routerMiddleware &#125; <span class="keyword">from</span> <span class="string">"connected-react-router"</span>;</span><br><span class="line"><span class="keyword">import</span> history <span class="keyword">from</span> <span class="string">"../history"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接着创建仓库和中间件</span></span><br><span class="line"><span class="keyword">let</span> store = createStore(reducers, applyMiddleware(routerMiddleware(history),thunk,logger));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出store仓库</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure><blockquote><p>我们进入<code>./src/store/actions/counter.tsx</code>加个<code>goto</code>方法用来跳转</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/store/actions/counter.tsx</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> types <span class="keyword">from</span> <span class="string">"../action-types"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入push方法</span></span><br><span class="line"><span class="keyword">import</span> &#123; push &#125; <span class="keyword">from</span> <span class="string">"connected-react-router"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义两个接口，分别约束add和subtract的type类型</span></span><br><span class="line"><span class="keyword">export</span> interface Add&#123;</span><br><span class="line">  type:<span class="keyword">typeof</span> types.ADD</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface Subtract&#123;</span><br><span class="line">  type:<span class="keyword">typeof</span> types.SUBTRACT</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 再导出一个type</span></span><br><span class="line"><span class="comment">// type是用来给类型起别名的</span></span><br><span class="line"><span class="comment">// 这个actions里是一个对象，会有很多函数，每个函数都会返回一个action</span></span><br><span class="line"><span class="comment">// 而 ./store/reducers/index.tsx中的action会是下面某一个函数的返回值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type Action = Add | Subtract</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把上面定义好的接口作用于下面</span></span><br><span class="line"><span class="comment">// 约束返回值的类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  add():Add&#123;</span><br><span class="line">    <span class="comment">// 需要返回一个action对象</span></span><br><span class="line">    <span class="comment">// type为动作的类型</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">type</span>: types.ADD&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  subtract():Subtract&#123;</span><br><span class="line">    <span class="comment">// 需要返回一个action对象</span></span><br><span class="line">    <span class="comment">// type为动作的类型</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">type</span>: types.SUBTRACT&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 一秒后才执行这个行为</span></span><br><span class="line">  addAsync():any&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">dispatch:any,getState:any</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 当1秒过后，会执行dispatch，派发出去，然后改变仓库的状态</span></span><br><span class="line">        dispatch(&#123;<span class="attr">type</span>:types.ADD&#125;)</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  goto(path:string)&#123;</span><br><span class="line">    <span class="comment">// 派发一个动作</span></span><br><span class="line">    <span class="comment">// 这个push是connected-react-router里的一个方法</span></span><br><span class="line">    <span class="comment">// 返回一个跳转路径的action</span></span><br><span class="line">    <span class="keyword">return</span> push(path)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们进入<code>./src/components/Counter.tsx</code>中加个按钮，当我点击按钮的时候，会向仓库派发<code>action</code>，仓库的<code>action</code>里有中间件，会把我们这个请求拦截到，然后跳转</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一部分-Typescript基础&quot;&gt;&lt;a href=&quot;#第一部分-Typescript基础&quot; class=&quot;headerlink&quot; title=&quot;第一部分 Typescript基础&quot;&gt;&lt;/a&gt;第一部分 Typescript基础&lt;/h1&gt;&lt;h2 id=&quot;一、typ
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="React" scheme="http://blog.poetries.top/tags/React/"/>
    
      <category term="Typescript" scheme="http://blog.poetries.top/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>shell入门</title>
    <link href="http://blog.poetries.top/2018/12/24/shell/"/>
    <id>http://blog.poetries.top/2018/12/24/shell/</id>
    <published>2018-12-24T02:32:41.000Z</published>
    <updated>2019-01-07T08:48:58.308Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近使用<code>shell</code>比较多，这里记录一下</p></blockquote><h2 id="一、初识shell"><a href="#一、初识shell" class="headerlink" title="一、初识shell"></a>一、初识shell</h2><h3 id="1-1-Shell-环境"><a href="#1-1-Shell-环境" class="headerlink" title="1.1 Shell 环境"></a>1.1 Shell 环境</h3><blockquote><p><code>Linux</code> 的 <code>Shell</code> 种类众多，常见的有</p></blockquote><ul><li><code>/usr/bin/sh</code>或<code>/bin/sh</code></li><li><code>/bin/bash</code></li><li><code>C Shell（/usr/bin/csh）</code></li><li><code>K Shell（/usr/bin/ksh）</code></li><li><code>Shell for Root（/sbin/sh）</code></li></ul><blockquote><p><code>Bash</code> 在日常工作中被广泛使用。同时，<code>Bash</code> 也是大多数<code>Linux</code> 系统默认的 <code>Shell</code></p></blockquote><ul><li>打开文本编辑器(可以使用 <code>vi/vim</code> 命令来创建文件)，新建一个文件 <code>test.sh</code>，扩展名为 <code>sh</code>（<code>sh</code>代表<code>shell</code>），扩展名并不影响脚本执行，见名知意就好</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello World !"</span></span><br></pre></td></tr></table></figure><ul><li><code>#!</code> 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 <code>Shell</code></li><li><code>echo</code> 命令用于向窗口输出文本</li></ul><h3 id="1-2-运行-Shell-脚本有两种方法"><a href="#1-2-运行-Shell-脚本有两种方法" class="headerlink" title="1.2 运行 Shell 脚本有两种方法"></a>1.2 运行 Shell 脚本有两种方法</h3><p><strong>作为可执行程序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./test.sh  #使脚本具有执行权限</span><br><span class="line">./test.sh  #执行脚本</span><br></pre></td></tr></table></figure><blockquote><p>注意，一定要写成 <code>./test.sh</code>，而不是 <code>test.sh</code>，运行其它二进制的程序也一样，直接写 <code>test.sh</code>，<code>linux</code> 系统会去 <code>PATH</code> 里寻找有没有叫 <code>test.sh</code> 的，而只有 <code>/bin</code>, <code>/sbin,</code> <code>/usr/bin</code>，<code>/usr/sbin</code> 等在 <code>PATH</code> 里，你的当前目录通常不在 <code>PATH</code> 里，所以写成 <code>test.sh</code> 是会找不到命令的，<strong>要用 ./test.sh 告诉系统说，就在当前目录找</strong></p></blockquote><p><strong>作为解释器参数</strong></p><ul><li>这种运行方式是，直接运行解释器，其参数就是 <code>shell</code> 脚本的文件名</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh test.sh</span><br><span class="line">/bin/php test.php</span><br></pre></td></tr></table></figure><ul><li>这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用</li></ul><h2 id="二、shell变量"><a href="#二、shell变量" class="headerlink" title="二、shell变量"></a>二、shell变量</h2><ul><li>定义变量时，变量名不加美元符号</li><li>注意，变量名和等号之间不能有空格</li><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头</li><li><code>中间不能有空格</code>，可以使用下划线（<code>_</code>）</li><li>不能使用标点符号</li><li>不能使用<code>bash</code>里的关键字（可用<code>help</code>命令查看保留关键字）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">your_name=<span class="string">"poetries"</span> <span class="comment">#中间不能有空格</span></span><br></pre></td></tr></table></figure><ul><li>有效的 <code>Shell</code> 变量名示例如下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RUNOOB</span><br><span class="line">LD_LIBRARY_PATH</span><br><span class="line">_var</span><br><span class="line">var2</span><br></pre></td></tr></table></figure><h3 id="2-1-使用变量"><a href="#2-1-使用变量" class="headerlink" title="2.1 使用变量"></a>2.1 使用变量</h3><ul><li>使用一个定义过的变量，只要在变量名前面加美元符号即可</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">your_name=<span class="string">"poetries"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$your_name</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;your_name&#125;</span></span><br></pre></td></tr></table></figure><ul><li>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况</li><li>如果不给<code>skill</code>变量加花括号，写成<code>echo &quot;I am good at $skillScript&quot;</code>，解释器就会把<code>$skillScript</code>当成一个变量（其值为空），代码执行结果就不是我们期望的样子了</li><li>推荐给所有变量加上花括号，这是个好的编程习惯</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for skill in Ada Coffe Action Java; do</span><br><span class="line">    echo &quot;I am good at $&#123;skill&#125;Script&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><ul><li>已定义的变量，可以被重新定义，如：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">your_name=<span class="string">"tom"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$your_name</span></span><br><span class="line">your_name=<span class="string">"alibaba"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$your_name</span></span><br></pre></td></tr></table></figure><h3 id="2-2-只读变量"><a href="#2-2-只读变量" class="headerlink" title="2.2 只读变量"></a>2.2 只读变量</h3><ul><li>使用 <code>readonly</code> 命令可以将变量定义为只读变量，只读变量的值不能被改变</li><li>下面的例子尝试更改只读变量，结果报错</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">myUrl=<span class="string">"http://www.w3cschool.cc"</span></span><br><span class="line"><span class="built_in">readonly</span> myUrl</span><br><span class="line">myUrl=<span class="string">"http://www.runoob.com"</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh: NAME: This variable is read only.</span><br></pre></td></tr></table></figure><h3 id="2-3-删除变量"><a href="#2-3-删除变量" class="headerlink" title="2.3 删除变量"></a>2.3 删除变量</h3><ul><li>使用 <code>unset</code> 命令可以删除变量。</li><li>语法 <code>unset variable_name</code></li><li>变量被删除后不能再次使用。<code>unset</code> 命令不能删除只读变量</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">myUrl=<span class="string">"http://www.runoob.com"</span></span><br><span class="line"><span class="built_in">unset</span> myUrl</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$myUrl</span></span><br></pre></td></tr></table></figure><h3 id="2-4-变量类型"><a href="#2-4-变量类型" class="headerlink" title="2.4 变量类型"></a>2.4 变量类型</h3><p><strong>运行shell时，会同时存在三种变量</strong></p><ul><li><strong>局部变</strong>量 局部变量在脚本或命令中定义，仅在当前<code>shell</code>实例中有效，其他<code>shell</code>启动的程序不能访问局部变量</li><li><strong>环境变量</strong> 所有的程序，包括<code>shell</code>启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候<code>shell</code>脚本也可以定义环境变量</li><li><strong><code>shell</code>变量</strong> <code>shell</code>变量是由<code>shell</code>程序设置的特殊变量。<code>shell</code>变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了<code>shell</code>的正常运行</li></ul><h3 id="2-5-Shell-字符串"><a href="#2-5-Shell-字符串" class="headerlink" title="2.5 Shell 字符串"></a>2.5 Shell 字符串</h3><ul><li>字符串是<code>shell</code>编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟<code>PHP</code>类似。</li></ul><p><strong>单引号</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str=&apos;this is a string&apos;</span><br></pre></td></tr></table></figure><ul><li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的</li><li>单引号字串中不能出现单引号（对单引号使用转义符后也不行）</li></ul><p><strong>双引号</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">author=<span class="string">'poetries'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello,I'm <span class="variable">$&#123;author&#125;</span>"</span></span><br></pre></td></tr></table></figure><ul><li>双引号里可以有变量</li><li>双引号里可以出现转义字符</li></ul><h3 id="2-6-拼接字符串"><a href="#2-6-拼接字符串" class="headerlink" title="2.6 拼接字符串"></a>2.6 拼接字符串</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">your_name=<span class="string">"poetries"</span></span><br><span class="line">greeting=<span class="string">"hello, "</span><span class="variable">$your_name</span><span class="string">" !"</span></span><br><span class="line">greeting_1=<span class="string">"hello, <span class="variable">$&#123;your_name&#125;</span> !"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$greeting</span> <span class="variable">$greeting_1</span></span><br></pre></td></tr></table></figure><h3 id="2-7-获取字符串长度"><a href="#2-7-获取字符串长度" class="headerlink" title="2.7 获取字符串长度"></a>2.7 获取字符串长度</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">author=<span class="string">'poetries'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"length:<span class="variable">$&#123;#author&#125;</span>"</span> <span class="comment"># length:8</span></span><br></pre></td></tr></table></figure><h3 id="2-8-提取子字符串"><a href="#2-8-提取子字符串" class="headerlink" title="2.8 提取子字符串"></a>2.8 提取子字符串</h3><ul><li>以下实例从字符串第 <code>2</code> 个字符开始截取 <code>4</code> 个字符：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">author=<span class="string">'poetries'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"提取字符串：<span class="variable">$&#123;author:1:4&#125;</span>"</span> <span class="comment"># oetr</span></span><br></pre></td></tr></table></figure><h3 id="2-9-Shell-数组"><a href="#2-9-Shell-数组" class="headerlink" title="2.9 Shell 数组"></a>2.9 Shell 数组</h3><ul><li><code>bash</code>支持一维数组（不支持多维数组），并且没有限定数组的大小</li><li>类似与<code>C</code>语言，数组元素的下标由<code>0</code>开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于0</li></ul><h3 id="2-10-定义数组"><a href="#2-10-定义数组" class="headerlink" title="2.10 定义数组"></a>2.10 定义数组</h3><ul><li>在<code>Shell</code>中，用括号来表示数组，数组元素用”空格”符号分割开。定义数组的一般形式为：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名=(值1 值2 ... 值n)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_name=(value0 value1 value2 value3)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">array_name=(</span><br><span class="line">value0</span><br><span class="line">value1</span><br><span class="line">value2</span><br><span class="line">value3</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>还可以单独定义数组的各个分量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[n]=valuen</span><br></pre></td></tr></table></figure><h3 id="2-11-读取数组"><a href="#2-11-读取数组" class="headerlink" title="2.11 读取数组"></a>2.11 读取数组</h3><ul><li>读取数组元素值的一般格式是</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;数组名[下标]&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valuen=$&#123;array_name[n]&#125;</span><br></pre></td></tr></table></figure><ul><li>使用<code>@</code>符号可以获取数组中的所有元素，例如</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;array_name[@]&#125;</span><br></pre></td></tr></table></figure><h3 id="2-12-获取数组的长度"><a href="#2-12-获取数组的长度" class="headerlink" title="2.12 获取数组的长度"></a>2.12 获取数组的长度</h3><ul><li>获取数组长度的方法与获取字符串长度的方法相同，例如</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 取得数组元素的个数</span><br><span class="line">length=$&#123;#array_name[@]&#125;</span><br><span class="line"># 或者</span><br><span class="line">length=$&#123;#array_name[*]&#125;</span><br><span class="line"># 取得数组单个元素的长度</span><br><span class="line">lengthn=$&#123;#array_name[n]&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">like=(</span><br><span class="line">  <span class="string">'running'</span></span><br><span class="line">  <span class="string">'reading'</span></span><br><span class="line">  <span class="string">'play'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"读取数组元素：<span class="variable">$&#123;like[@]&#125;</span>"</span> <span class="comment"># @读取数组所有长度</span></span><br></pre></td></tr></table></figure><h3 id="2-13-Shell-注释"><a href="#2-13-Shell-注释" class="headerlink" title="2.13 Shell 注释"></a>2.13 Shell 注释</h3><ul><li>以<code>&quot;#&quot;</code>开头的行就是注释，会被解释器忽略</li><li><code>sh</code>里没有多行注释，只能每一行加一个#号。只能像这样</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#--------------------------------------------</span></span><br><span class="line"><span class="comment"># 这是一个注释</span></span><br><span class="line"><span class="comment"># author：poetry</span></span><br><span class="line"><span class="comment"># site：www.poetries.top！</span></span><br><span class="line"><span class="comment">#--------------------------------------------</span></span><br><span class="line"><span class="comment">##### 用户配置区 开始 #####</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 这里可以添加脚本描述信息</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">##### 用户配置区 结束  #####</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 学习记录</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'====学习变量===='</span></span><br><span class="line">author=<span class="string">'poetries'</span></span><br><span class="line">like=(</span><br><span class="line">  <span class="string">'running'</span></span><br><span class="line">  <span class="string">'reading'</span></span><br><span class="line">  <span class="string">'playing'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"读取数组元素：<span class="variable">$&#123;like[@]&#125;</span>"</span> <span class="comment"># @读取数组所有长度</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"提取字符串：<span class="variable">$&#123;author:1:4&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"字符串length:<span class="variable">$&#123;#author&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello,I'm <span class="variable">$&#123;author&#125;</span>"</span></span><br></pre></td></tr></table></figure><h2 id="三、shell传递参数"><a href="#三、shell传递参数" class="headerlink" title="三、shell传递参数"></a>三、shell传递参数</h2><ul><li>我们可以在执行 <code>Shell</code> 脚本时，向脚本传递参数，脚本内获取参数的格式为：<code>$n</code>。<code>n</code> 代表一个数字，<code>1</code> 为执行脚本的第一个参数，<code>2</code> 为执行脚本的第二个参数，以此类推</li><li>以下实例我们向脚本传递三个参数，并分别输出，其中 <code>$0</code> 为执行的文件名</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sh test.sh 1 2 3 4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># author:poetries</span></span><br><span class="line"><span class="comment"># url:blog.poetries.top</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Shell 传递参数实例！"</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"执行的文件名：<span class="variable">$0</span>"</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"第一个参数为：<span class="variable">$1</span>"</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"第二个参数为：<span class="variable">$2</span>"</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"第三个参数为：<span class="variable">$3</span>"</span>;</span><br></pre></td></tr></table></figure><ul><li>为脚本设置可执行权限，并执行脚本，输出结果如下所示</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x test.sh </span><br><span class="line">$ ./test.sh 1 2 3</span><br><span class="line">Shell 传递参数实例！</span><br><span class="line">执行的文件名：./test.sh</span><br><span class="line">第一个参数为：1</span><br><span class="line">第二个参数为：2</span><br><span class="line">第三个参数为：3</span><br></pre></td></tr></table></figure><h2 id="四、数组"><a href="#四、数组" class="headerlink" title="四、数组"></a>四、数组</h2><ul><li>数组中可以存放多个值。<code>Bash Shell</code> 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小</li><li>与大部分编程语言类似，数组元素的下标由<code>0</code>开始</li><li><code>Shell</code> 数组用括号来表示，元素用”空格”符号分割开，语法格式如下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># author:poetry</span></span><br><span class="line"><span class="comment"># url:blog.poetries.top</span></span><br><span class="line"></span><br><span class="line">my_array=(A B <span class="string">"C"</span> D)</span><br></pre></td></tr></table></figure><ul><li>我们也可以使用下标来定义数组:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[2]=value2</span><br></pre></td></tr></table></figure><h3 id="4-1-读取数组"><a href="#4-1-读取数组" class="headerlink" title="4.1 读取数组"></a>4.1 读取数组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;array_name[index]&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># author:poetry</span></span><br><span class="line"><span class="comment"># url:www.poetries.top</span></span><br><span class="line"></span><br><span class="line">my_array=(A B <span class="string">"C"</span> D)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"第一个元素为: <span class="variable">$&#123;my_array[0]&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"第二个元素为: <span class="variable">$&#123;my_array[1]&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"第三个元素为: <span class="variable">$&#123;my_array[2]&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"第四个元素为: <span class="variable">$&#123;my_array[3]&#125;</span>"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x test.sh </span><br><span class="line">$ ./test.sh</span><br><span class="line">第一个元素为: A</span><br><span class="line">第二个元素为: B</span><br><span class="line">第三个元素为: C</span><br><span class="line">第四个元素为: D</span><br></pre></td></tr></table></figure><h3 id="4-2-获取数组中的所有元素"><a href="#4-2-获取数组中的所有元素" class="headerlink" title="4.2 获取数组中的所有元素"></a>4.2 获取数组中的所有元素</h3><ul><li>使用<code>@</code> 或 <code>*</code> 可以获取数组中的所有元素，例如：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># author:poetries</span></span><br><span class="line"><span class="comment"># url:www.poetries.top</span></span><br><span class="line"></span><br><span class="line">my_array[0]=A</span><br><span class="line">my_array[1]=B</span><br><span class="line">my_array[2]=C</span><br><span class="line">my_array[3]=D</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"数组的元素为: <span class="variable">$&#123;my_array[*]&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"数组的元素为: <span class="variable">$&#123;my_array[@]&#125;</span>"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x test.sh </span><br><span class="line">$ ./test.sh</span><br><span class="line">数组的元素为: A B C D</span><br><span class="line">数组的元素为: A B C D</span><br></pre></td></tr></table></figure><h3 id="4-3-获取数组的长度"><a href="#4-3-获取数组的长度" class="headerlink" title="4.3 获取数组的长度"></a>4.3 获取数组的长度</h3><ul><li>获取数组长度的方法与获取字符串长度的方法相同，例如</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># author:poetries</span></span><br><span class="line"><span class="comment"># url:www.poetries.top</span></span><br><span class="line"></span><br><span class="line">my_array[0]=A</span><br><span class="line">my_array[1]=B</span><br><span class="line">my_array[2]=C</span><br><span class="line">my_array[3]=D</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"数组元素个数为: <span class="variable">$&#123;#my_array[*]&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"数组元素个数为: <span class="variable">$&#123;#my_array[@]&#125;</span>"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x test.sh </span><br><span class="line">$ ./test.sh</span><br><span class="line">数组元素个数为: 4</span><br><span class="line">数组元素个数为: 4</span><br></pre></td></tr></table></figure><h2 id="五、基本运算符"><a href="#五、基本运算符" class="headerlink" title="五、基本运算符"></a>五、基本运算符</h2><ul><li>原生<code>bash</code>不支持简单的数学运算，但是可以通过其他命令来实现，例如 <code>awk</code> 和 <code>expr</code>，<code>expr</code> 最常用</li><li><code>expr</code> 是一款表达式计算工具，使用它能完成表达式的求值操作</li><li>例如，两个数相加(注意使用的是反引号 ` 而不是单引号 ‘)：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">val=`expr 2 + 2` <span class="comment"># 注意 表达式和运算符之间要有空格</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"两数之和为 : <span class="variable">$val</span>"</span></span><br></pre></td></tr></table></figure><ul><li>表达式和运算符之间要有空格，例如 <code>2+2</code> 是不对的，必须写成 <code>2 + 2</code>，这与我们熟悉的大多数编程语言不一样。</li><li>完整的表达式要被 <code></code> 包含，注意这个字符不是常用的单引号</li></ul><h3 id="5-1-算术运算符"><a href="#5-1-算术运算符" class="headerlink" title="5.1 算术运算符"></a>5.1 算术运算符</h3><ul><li>下表列出了常用的算术运算符，假定变量 <code>a</code> 为 <code>10</code>，变量 <code>b</code> 为 <code>20</code>：</li></ul><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td><code>+</code></td><td>加法</td><td><code>expr $a + $b</code> 结果为 <code>30</code>。</td></tr><tr><td><code>-</code></td><td>减法</td><td><code>expr $a - $b</code> 结果为 <code>-10</code>。</td></tr><tr><td><code>*</code></td><td>乘法</td><td><code>expr $a \* $b</code> 结果为  <code>200</code>。</td></tr><tr><td><code>/</code></td><td>除法</td><td><code>expr $b / $a</code> 结果为 <code>2</code>。</td></tr><tr><td><code>%</code></td><td>取余</td><td><code>expr $b % $a</code> 结果为 <code>0</code>。</td></tr><tr><td><code>=</code></td><td>赋值</td><td><code>a=$b</code> 将把变量 b 的值赋给 a。</td></tr><tr><td><code>==</code></td><td>相等。用于比较两个数字，相同则返回 <code>true</code>。</td><td><code>[ $a == $b ]</code> 返回 <code>false</code>。</td></tr><tr><td><code>!=</code></td><td>不相等。用于比较两个数字，不相同则返回 <code>true</code>。</td><td><code>[ $a != $b ]</code> 返回 <code>true</code>。</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'shell运算符学习===='</span></span><br><span class="line">value=`expr 2 + 3`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"两数之和:<span class="variable">$&#123;value&#125;</span>"</span></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">add=`expr <span class="variable">$a</span> + <span class="variable">$b</span>`</span><br><span class="line">reduce=`expr <span class="variable">$a</span> - <span class="variable">$b</span>`</span><br><span class="line">cheng=`expr <span class="variable">$a</span> \* <span class="variable">$b</span>`</span><br><span class="line">chu=`expr <span class="variable">$a</span> / <span class="variable">$b</span>`</span><br><span class="line">quyu=`expr <span class="variable">$a</span> % <span class="variable">$b</span>`</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"+：<span class="variable">$&#123;add&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"-：<span class="variable">$&#123;reduce&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"*：<span class="variable">$&#123;cheng&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"/：<span class="variable">$&#123;chu&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"%：<span class="variable">$&#123;quyu&#125;</span>"</span></span><br></pre></td></tr></table></figure><ul><li>注意：条件表达式要放在方括号之间，并且要有空格，例如: <code>[$a==$b]</code> 是错误的，必须写成 <code>[ $a == $b ]</code></li></ul><h3 id="5-2-关系运算符"><a href="#5-2-关系运算符" class="headerlink" title="5.2 关系运算符"></a>5.2 关系运算符</h3><ul><li>关系运算符只支持数字，不支持字符串，除非字符串的值是数字</li><li>下表列出了常用的关系运算符，假定变量 <code>a</code> 为 <code>10</code>，变量 <code>b</code> 为 <code>20</code>：</li></ul><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td><code>-eq</code></td><td>检测两个数是否相等，相等返回 <code>true</code></td><td><code>[ $a -eq $b ]</code> 返回 <code>false</code></td></tr><tr><td><code>-ne</code></td><td>检测两个数是否相等，不相等返回 <code>true</code></td><td><code>[ $a -ne $b ]</code> 返回 <code>true</code></td><td>。</td></tr><tr><td><code>-gt</code></td><td>检测左边的数是否大于右边的，如果是，则返回 <code>true</code></td><td><code>[ $a -gt $b ]</code> 返回 <code>false</code></td></tr><tr><td><code>-lt</code></td><td>检测左边的数是否小于右边的，如果是，则返回 <code>true</code></td><td><code>[ $a -lt $b ]</code> 返回 <code>true</code></td></tr><tr><td><code>-ge</code></td><td>检测左边的数是否大于等于右边的，如果是，则返回 <code>true</code></td><td><code>[ $a -ge $b ]</code>返回 <code>false</code></td></tr><tr><td><code>-le</code></td><td>检测左边的数是否小于等于右边的，如果是，则返回 <code>true</code></td><td><code>[ $a -le $b ]</code>返回 <code>true</code></td></tr></tbody></table><h3 id="5-3-布尔运算符"><a href="#5-3-布尔运算符" class="headerlink" title="5.3 布尔运算符"></a>5.3 布尔运算符</h3><ul><li>下表列出了常用的布尔运算符，假定变量 <code>a</code> 为 <code>10</code>，变量 <code>b</code> 为 <code>20</code>：</li></ul><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td><code>!</code></td><td>非运算，表达式为 <code>true</code> 则返回 <code>false</code>，否则返回 <code>true</code>。</td><td><code>[ ! false ]</code> 返回 <code>true</code></td></tr><tr><td><code>-o</code></td><td>或运算，有一个表达式为 <code>true</code>则返回 <code>true</code>。</td><td><code>[ $a -lt 20 -o $b -gt 100 ]</code> 返回 <code>true</code></td></tr><tr><td><code>-a</code></td><td>与运算，两个表达式都为 <code>true</code> 才返回 <code>true</code>。</td><td><code>[ $a -lt 20 -a $b -gt 100 ]</code>返回 <code>false</code></td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># author:author</span></span><br><span class="line"><span class="comment"># url:blog.poetries.top</span></span><br><span class="line"></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> != <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> != <span class="variable">$b</span> : a 不等于 b"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> != <span class="variable">$b</span>: a 等于 b"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -lt 100 -a <span class="variable">$b</span> -gt 15 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> 小于 100 且 <span class="variable">$b</span> 大于 15 : 返回 true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> 小于 100 且 <span class="variable">$b</span> 大于 15 : 返回 false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -lt 100 -o <span class="variable">$b</span> -gt 100 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> 小于 100 或 <span class="variable">$b</span> 大于 100 : 返回 true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> 小于 100 或 <span class="variable">$b</span> 大于 100 : 返回 false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -lt 5 -o <span class="variable">$b</span> -gt 100 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> 小于 5 或 <span class="variable">$b</span> 大于 100 : 返回 true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> 小于 5 或 <span class="variable">$b</span> 大于 100 : 返回 false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="5-4-逻辑运算符"><a href="#5-4-逻辑运算符" class="headerlink" title="5.4 逻辑运算符"></a>5.4 逻辑运算符</h3><ul><li>以下介绍 Shell 的逻辑运算符，假定变量 <code>a</code> 为 <code>10</code>，变量 <code>b</code>为 <code>20</code></li></ul><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td><code>&amp;&amp;</code></td><td>逻辑的 <code>AND</code></td><td><code>[[ $a -lt 100 &amp;&amp; $b -gt 100 ]]</code>返回 <code>false</code></td></tr><tr><td>`</td><td></td><td>`</td><td>逻辑的 <code>OR</code></td><td>`[[ $a -lt 100</td><td></td><td>$b -gt 100 ]]<code>返回</code>true`</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$a</span> -lt 100 &amp;&amp; <span class="variable">$b</span> -gt 100 ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"返回 true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"返回 false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$a</span> -lt 100 || <span class="variable">$b</span> -gt 100 ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"返回 true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"返回 false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="5-5-字符串运算符"><a href="#5-5-字符串运算符" class="headerlink" title="5.5 字符串运算符"></a>5.5 字符串运算符</h3><ul><li>下表列出了常用的字符串运算符，假定变量 <code>a</code> 为 <code>&quot;abc&quot;</code>，变量 <code>b</code> 为 <code>&quot;efg&quot;</code></li></ul><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td><code>=</code></td><td>检测两个字符串是否相等，相等返回 <code>true</code></td><td><code>[ $a = $b ]</code> 返回 <code>false</code>。</td></tr><tr><td><code>!=</code></td><td>检测两个字符串是否相等，不相等返回 <code>true</code>。</td><td><code>[ $a != $b ]</code>返回 <code>true</code>。</td></tr><tr><td><code>-z</code></td><td>检测字符串长度是否为<code>0</code>，为<code>0</code>返回 <code>true</code>。</td><td><code>[ -z $a ]</code>返回 <code>false</code></td><td>。</td></tr><tr><td><code>-n</code></td><td>检测字符串长度是否为<code>0</code>，不为<code>0</code>返回 <code>true</code>。</td><td><code>[ -n $a ]</code> 返回 <code>true</code>。</td></tr><tr><td><code>str</code></td><td>检测字符串是否为空，不为空返回 <code>true</code>。</td><td><code>[ $a ]</code> 返回 <code>true</code>。</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">"abc"</span></span><br><span class="line">b=<span class="string">"efg"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> = <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> = <span class="variable">$b</span> : a 等于 b"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> = <span class="variable">$b</span>: a 不等于 b"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> != <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> != <span class="variable">$b</span> : a 不等于 b"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> != <span class="variable">$b</span>: a 等于 b"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$a</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"-z <span class="variable">$a</span> : 字符串长度为 0"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"-z <span class="variable">$a</span> : 字符串长度不为 0"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -n <span class="variable">$a</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"-n <span class="variable">$a</span> : 字符串长度不为 0"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"-n <span class="variable">$a</span> : 字符串长度为 0"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> : 字符串不为空"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> : 字符串为空"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="5-6-文件测试运算符"><a href="#5-6-文件测试运算符" class="headerlink" title="5.6 文件测试运算符"></a>5.6 文件测试运算符</h3><ul><li>文件测试运算符用于检测 <code>Unix</code> 文件的各种属性</li></ul><table><thead><tr><th>操作符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td><code>-b file</code></td><td>检测文件是否是块设备文件，如果是，则返回 <code>true</code>。</td><td><code>[ -b $file ]</code>返回 <code>false</code>。</td></tr><tr><td><code>-c file</code></td><td>检测文件是否是字符设备文件，如果是，则返回 <code>true</code>。</td><td><code>[ -c $file ]</code>返回 <code>false</code>。</td></tr><tr><td><code>-d file</code></td><td>检测文件是否是目录，如果是，则返回 <code>true</code>。</td><td><code>[ -d $file ]</code> 返回 <code>false</code>。</td></tr><tr><td><code>-f file</code></td><td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 <code>true</code>。</td><td><code>[ -f $file ]</code>返回 <code>true</code>。</td></tr><tr><td><code>-g file</code></td><td>检测文件是否设置了 <code>SGID</code>位，如果是，则返回 <code>true</code>。</td><td><code>[ -g $file ]</code> 返回 <code>false</code>。</td></tr><tr><td><code>-k file</code></td><td>检测文件是否设置了粘着位(<code>Sticky Bit</code>)，如果是，则返回 <code>true</code>。</td><td><code>[ -k $file ]</code> 返回 <code>false</code>。</td></tr><tr><td><code>-p file</code></td><td>检测文件是否是有名管道，如果是，则返回 <code>true</code>。</td><td><code>[ -p $file ]</code> 返回 <code>false</code>。</td></tr><tr><td><code>-u file</code></td><td>检测文件是否设置了 <code>SUID</code> 位，如果是，则返回 <code>true</code>。</td><td><code>[ -u $file ]</code> 返回 <code>false</code>。</td></tr><tr><td><code>-r file</code></td><td>检测文件是否可读，如果是，则返回 <code>true</code>。</td><td><code>[ -r $file ]</code> 返回 <code>true</code>。</td></tr><tr><td><code>-w file</code></td><td>检测文件是否可写，如果是，则返回 <code>true</code>。</td><td><code>[ -w $file ]</code> 返回 <code>true</code>。</td></tr><tr><td><code>-x file</code></td><td>检测文件是否可执行，如果是，则返回 <code>true</code>。</td><td><code>[ -x $file ]</code> 返回 <code>true</code>。</td></tr><tr><td><code>-s file</code></td><td>检测文件是否为空（文件大小是否大于<code>0</code>），不为空返回 <code>true</code>。</td><td><code>[ -s $file ]</code> 返回 <code>true</code>。</td></tr><tr><td><code>-e file</code></td><td>检测文件（包括目录）是否存在，如果是，则返回 <code>true</code>。</td><td><code>[ -e $file ]</code> 返回 <code>true</code>。</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">file=<span class="string">"/homee/shell/test1.sh"</span></span><br><span class="line"><span class="keyword">if</span> [ -r <span class="variable">$file</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"文件可读"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"文件不可读"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -w <span class="variable">$file</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"文件可写"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"文件不可写"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -x <span class="variable">$file</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"文件可执行"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"文件不可执行"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -f <span class="variable">$file</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"文件为普通文件"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"文件为特殊文件"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -d <span class="variable">$file</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"文件是个目录"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"文件不是个目录"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -s <span class="variable">$file</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"文件不为空"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"文件为空"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -e <span class="variable">$file</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"文件存在"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"文件不存在"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h2 id="六、echo用法"><a href="#六、echo用法" class="headerlink" title="六、echo用法"></a>六、echo用法</h2><ul><li><code>Shell</code> 的 <code>echo</code> 指令与 <code>PHP</code> 的 <code>echo</code> 指令类似，都是用于字符串的输出。命令格式</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> string</span><br></pre></td></tr></table></figure><h3 id="6-1-显示普通字符串"><a href="#6-1-显示普通字符串" class="headerlink" title="6.1 显示普通字符串:"></a>6.1 显示普通字符串:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"It is a test"</span></span><br></pre></td></tr></table></figure><ul><li>这里的双引号完全可以省略，以下命令与上面实例效果一致</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> It is a <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h3 id="6-2-显示转义字符"><a href="#6-2-显示转义字符" class="headerlink" title="6.2 显示转义字符"></a>6.2 显示转义字符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"\"It is a test\""</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;It is a test&quot;</span><br></pre></td></tr></table></figure><h3 id="6-3-显示变量"><a href="#6-3-显示变量" class="headerlink" title="6.3 显示变量"></a>6.3 显示变量</h3><ul><li><code>read</code> 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> name </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$name</span> It is a test"</span></span><br></pre></td></tr></table></figure><ul><li>以上代码保存为 <code>test.sh</code>，<code>name</code> 接收标准输入的变量，结果将是</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># sh test.sh</span></span><br><span class="line">poetry                     <span class="comment">#标准输入</span></span><br><span class="line">poetry It is a <span class="built_in">test</span>        <span class="comment">#输出</span></span><br></pre></td></tr></table></figure><h3 id="6-4-显示换行"><a href="#6-4-显示换行" class="headerlink" title="6.4 显示换行"></a>6.4 显示换行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">"OK! \n"</span> <span class="comment"># -e 开启转义</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"It it a test"</span></span><br></pre></td></tr></table></figure><h3 id="6-5-显示不换行"><a href="#6-5-显示不换行" class="headerlink" title="6.5 显示不换行"></a>6.5 显示不换行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"OK! \c"</span> <span class="comment"># -e 开启转义 \c 不换行</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"It is a test"</span></span><br></pre></td></tr></table></figure><h3 id="6-6-显示结果定向至文件"><a href="#6-6-显示结果定向至文件" class="headerlink" title="6.6 显示结果定向至文件"></a>6.6 显示结果定向至文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"It is a test"</span> &gt; myfile</span><br></pre></td></tr></table></figure><h3 id="6-7-显示命令执行结果"><a href="#6-7-显示命令执行结果" class="headerlink" title="6.7 显示命令执行结果"></a>6.7 显示命令执行结果</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> `date`</span><br></pre></td></tr></table></figure><ul><li>注意： 这里使用的是反引号 `, 而不是单引号 ‘</li><li>结果将显示当前日期</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thu Feb 22 14:34:57 GMT 2018</span><br></pre></td></tr></table></figure><h2 id="七、printf用法"><a href="#七、printf用法" class="headerlink" title="七、printf用法"></a>七、printf用法</h2><ul><li><code>printf</code> 命令模仿 <code>C</code> 程序库（<code>library</code>）里的 <code>printf()</code> 程序</li><li><code>printf</code> 由 <code>POSIX</code> 标准所定义，因此使用 <code>printf</code> 的脚本比使用 <code>echo</code> 移植性好</li><li>默认 <code>printf</code> 不会像 <code>echo</code>自动添加换行符，我们可以手动添加 <code>\n</code></li></ul><p><strong>printf 命令的语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>  format-string  [arguments...]</span><br></pre></td></tr></table></figure><ul><li><code>format-string</code>: 为格式控制字符串</li><li><code>arguments</code>: 为参数列表</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"Hello, Shell"</span></span><br><span class="line">Hello, Shell</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">printf</span> <span class="string">"Hello, Shell\n"</span></span><br><span class="line">Hello, Shell</span><br><span class="line">$</span><br></pre></td></tr></table></figure><ul><li>接下来,用一个脚本来体现<code>printf</code>的强大功能</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%-10s %-8s %-4s\n"</span> 姓名 性别 体重kg  </span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%-10s %-8s %-4.2f\n"</span> 郭靖 男 66.1234 </span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%-10s %-8s %-4.2f\n"</span> 杨过 男 48.6543 </span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%-10s %-8s %-4.2f\n"</span> 郭芙 女 47.9876</span><br></pre></td></tr></table></figure><ul><li>执行脚本，输出结果如下所示</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">姓名     性别   体重kg</span><br><span class="line">郭靖     男      66.12</span><br><span class="line">杨过     男      48.65</span><br><span class="line">郭芙     女      47.99</span><br></pre></td></tr></table></figure><ul><li><code>%s</code> <code>%c</code> <code>%d</code> <code>%f</code>都是格式替代符</li><li><code>%-10s</code> 指一个宽度为<code>10</code>个字符（<code>-</code>表示左对齐，没有则表示右对齐），任何字符都会被显示在<code>10</code>个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来</li><li><code>%-4.2f</code> 指格式化为小数，其中<code>.2</code>指保留<code>2</code>位小数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># format-string为双引号</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%d %s\n"</span> 1 <span class="string">"abc"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单引号与双引号效果一样 </span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">'%d %s\n'</span> 1 <span class="string">"abc"</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有引号也可以输出</span></span><br><span class="line"><span class="built_in">printf</span> %s abcdef</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用</span></span><br><span class="line"><span class="built_in">printf</span> %s abc def</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%s\n"</span> abc def</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%s %s %s\n"</span> a b c d e f g h i j</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%s and %d \n"</span></span><br></pre></td></tr></table></figure><p><strong>printf的转义序列</strong></p><table><thead><tr><th>序列</th><th>说明</th></tr></thead><tbody><tr><td><code>\a</code></td><td>警告字符，通常为<code>ASCII</code>的<code>BEL</code>字符</td></tr><tr><td><code>\b</code></td><td>后退</td></tr><tr><td><code>\c</code></td><td>抑制（不显示）输出结果中任何结尾的换行字符（只在<code>%b</code>格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</td></tr><tr><td><code>\f</code></td><td>换页（formfeed）</td></tr><tr><td><code>\n</code></td><td>换行</td></tr><tr><td><code>\r</code></td><td>回车（Carriage return）</td></tr><tr><td><code>\t</code></td><td>水平制表符</td></tr><tr><td><code>\v</code></td><td>垂直制表符</td></tr><tr><td><code>\\</code></td><td>一个字面上的反斜杠字符</td></tr><tr><td><code>\ddd</code></td><td>表示1到3位数八进制值的字符。仅在格式字符串中有效</td></tr><tr><td><code>\0ddd</code></td><td>表示1到3位的八进制值字符</td></tr></tbody></table><h2 id="八、test命令"><a href="#八、test命令" class="headerlink" title="八、test命令"></a>八、test命令</h2><ul><li><code>Shell</code>中的 <code>test</code> 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</li></ul><h3 id="8-1-数值测试"><a href="#8-1-数值测试" class="headerlink" title="8.1 数值测试"></a>8.1 数值测试</h3><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-eq</code></td><td>等于则为真</td></tr><tr><td><code>-ne</code></td><td>不等于则为真</td></tr><tr><td><code>-gt</code></td><td>大于则为真</td></tr><tr><td><code>-ge</code></td><td>大于等于则为真</td></tr><tr><td><code>-lt</code></td><td>小于则为真</td></tr><tr><td><code>-le</code></td><td>小于等于则为真</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num1=100</span><br><span class="line">num2=100</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> $[num1] -eq $[num2]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'两个数相等！'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'两个数不相等！'</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两个数相等！</span><br></pre></td></tr></table></figure><ul><li>代码中的 <code>[]</code> 执行基本的算数运算</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=5</span><br><span class="line">b=6</span><br><span class="line"></span><br><span class="line">result=$[a+b] <span class="comment"># 注意等号两边不能有空格</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"result 为： <span class="variable">$result</span>"</span></span><br></pre></td></tr></table></figure><h3 id="8-2-字符串测试"><a href="#8-2-字符串测试" class="headerlink" title="8.2 字符串测试"></a>8.2 字符串测试</h3><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>`=</td><td>`    等于则为真</td></tr><tr><td><code>!=</code></td><td>不相等则为真</td></tr><tr><td><code>-z</code></td><td>字符串</td><td>字符串的长度为零则为真</td></tr><tr><td><code>-n</code></td><td>字符串</td><td>字符串的长度不为零则为真</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num1=<span class="string">"poetries"</span></span><br><span class="line">num2=<span class="string">"poetries1"</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> <span class="variable">$num1</span> = <span class="variable">$num2</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'两个字符串相等!'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'两个字符串不相等!'</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两个字符串不相等!</span><br></pre></td></tr></table></figure><h3 id="8-3-文件测试"><a href="#8-3-文件测试" class="headerlink" title="8.3 文件测试"></a>8.3 文件测试</h3><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-e</code> 文件名</td><td>如果文件存在则为真</td></tr><tr><td><code>-r</code> 文件名</td><td>如果文件存在且可读则为真</td></tr><tr><td><code>-w</code>文件名</td><td>如果文件存在且可写则为真</td></tr><tr><td><code>-x</code> 文件名</td><td>如果文件存在且可执行则为真</td></tr><tr><td><code>-s</code> 文件名</td><td>如果文件存在且至少有一个字符则为真</td></tr><tr><td><code>-d</code> 文件名</td><td>如果文件存在且为目录则为真</td></tr><tr><td><code>-f</code> 文件名</td><td>如果文件存在且为普通文件则为真</td></tr><tr><td><code>-c</code> 文件名</td><td>如果文件存在且为字符型特殊文件则为真</td></tr><tr><td><code>-b</code> 文件名</td><td>如果文件存在且为块特殊文件则为真</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">file=/home/shell/test.sh</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -e <span class="variable">$file</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">'test.sh文件存在'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">'test.sh不存在'</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.sh文件存在</span><br></pre></td></tr></table></figure><ul><li>另外，<code>Shell</code>还提供了与( <code>-a</code> )、或( <code>-o</code> )、非( <code>!</code> )三个逻辑操作符用于将测试条件连接起来，其优先级为：”<code>!</code>“最高，”<code>-a</code>“次之，”<code>-o</code>“最低。例如：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">file=/home/shell/test.sh</span><br><span class="line">file1=/home/poetry</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -d <span class="variable">$file1</span> -o -e <span class="variable">$file</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">'至少有一个文件存在'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">'两个文件都不存在'</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有一个文件存在!</span><br></pre></td></tr></table></figure><h2 id="九、流程控制if-while-case"><a href="#九、流程控制if-while-case" class="headerlink" title="九、流程控制if/while/case"></a>九、流程控制if/while/case</h2><h3 id="9-1-if"><a href="#9-1-if" class="headerlink" title="9.1 if"></a>9.1 if</h3><ul><li><code>if</code> 语句语法格式</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ul><li>写成一行（适用于终端命令提示符）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ $(ps -ef | grep -c <span class="string">"ssh"</span>) -gt 1 ]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"true"</span>; <span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="9-2-if-else"><a href="#9-2-if-else" class="headerlink" title="9.2 if else"></a>9.2 if else</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="9-3-if-else-if-else"><a href="#9-3-if-else-if-else" class="headerlink" title="9.3 if else-if else"></a>9.3 if else-if else</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1</span><br><span class="line"><span class="keyword">elif</span> condition2 </span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">    command2</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ul><li>以下实例判断两个变量是否相等</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> == <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"a 等于 b"</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$a</span> -gt <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"a 大于 b"</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$a</span> -lt <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"a 小于 b"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"没有符合的条件"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a 小于 b</span><br></pre></td></tr></table></figure><ul><li><code>if else</code>语句经常与<code>test</code>命令结合使用，如下所示</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">num1=$[2*3]</span><br><span class="line">num2=$[1+5]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> $[num1] -eq $[num2]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'两个数字相等!'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'两个数字不相等!'</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="9-4-for-循环"><a href="#9-4-for-循环" class="headerlink" title="9.4 for 循环"></a>9.4 for 循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> item1 item2 ... itemN</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ul><li>写成一行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> item1 item2 ... itemN; <span class="keyword">do</span> command1; command2… <span class="keyword">done</span>;</span><br></pre></td></tr></table></figure><ul><li>当变量值在列表里，<code>for</code>循环即执行一次所有命令，使用变量名获取列表中的当前取值。</li><li>命令可为任何有效的<code>shell</code>命令和语句</li><li><code>in</code>列表可以包含替换、字符串和文件名</li><li><code>in</code>列表是可选的，如果不用它，<code>for</code>循环使用命令行的位置参数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> loop <span class="keyword">in</span> 1 2 3 4 5</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"The value is: <span class="variable">$loop</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The value is: 1</span><br><span class="line">The value is: 2</span><br><span class="line">The value is: 3</span><br><span class="line">The value is: 4</span><br><span class="line">The value is: 5</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> str <span class="keyword">in</span> <span class="string">'This is a string'</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$str</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is a string</span><br></pre></td></tr></table></figure><h3 id="9-5-while-语句"><a href="#9-5-while-语句" class="headerlink" title="9.5 while 语句"></a>9.5 while 语句</h3><ul><li><code>while</code>循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ul><li>以下是一个基本的<code>while</code>循环，测试条件是：如果<code>int</code>小于等于<code>5</code>，那么条件返回真。<code>int</code>从<code>0</code>开始，每次循环处理时，<code>int</code>加<code>1</code>。运行上述脚本，返回数字<code>1</code>到<code>5</code>，然后终止</li><li>使用中使用了 <code>Bash let</code> 命令，它用于执行一个或多个表达式，变量计算中不需要加上 <code>$</code> 来表示变量</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">int=1</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(( <span class="variable">$int</span>&lt;=5 ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$int</span></span><br><span class="line">    <span class="built_in">let</span> <span class="string">"int++"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="9-6-until-循环"><a href="#9-6-until-循环" class="headerlink" title="9.6 until 循环"></a>9.6 until 循环</h3><ul><li><code>until</code>循环执行一系列命令直至条件为真时停止</li><li><code>until</code>循环与<code>while</code>循环在处理方式上刚好相反</li><li>一般<code>while</code>循环优于<code>until</code>循环，但在某些时候—也只是极少数情况下，<code>until</code>循环更加有用</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="9-7-case"><a href="#9-7-case" class="headerlink" title="9.7 case"></a>9.7 case</h3><ul><li><code>Shell case</code>语句为多选择语句。可以用<code>case</code>语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。<code>case</code>语句格式如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> 值 <span class="keyword">in</span></span><br><span class="line">模式1)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">模式2）</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><ul><li><code>case</code>工作方式如上所示。取值后面必须为单词<code>in</code>，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至</li><li>取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 <code>*</code> 捕获该值，再执行后面的命令</li><li>下面的脚本提示输入<code>1</code>到<code>4</code>，与每一种模式进行匹配</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'输入 1 到 4 之间的数字:'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'你输入的数字为:'</span></span><br><span class="line"><span class="built_in">read</span> aNum</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$aNum</span> <span class="keyword">in</span></span><br><span class="line">    1)  <span class="built_in">echo</span> <span class="string">'你选择了 1'</span></span><br><span class="line">    ;;</span><br><span class="line">    2)  <span class="built_in">echo</span> <span class="string">'你选择了 2'</span></span><br><span class="line">    ;;</span><br><span class="line">    3)  <span class="built_in">echo</span> <span class="string">'你选择了 3'</span></span><br><span class="line">    ;;</span><br><span class="line">    4)  <span class="built_in">echo</span> <span class="string">'你选择了 4'</span></span><br><span class="line">    ;;</span><br><span class="line">    *)  <span class="built_in">echo</span> <span class="string">'你没有输入 1 到 4 之间的数字'</span></span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><h3 id="9-8-跳出循环"><a href="#9-8-跳出循环" class="headerlink" title="9.8 跳出循环"></a>9.8 跳出循环</h3><ul><li>在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，Shell使用两个命令来实现该功能：<code>break</code>和<code>continue</code></li></ul><p><strong>break命令</strong></p><ul><li><code>break</code>命令允许跳出所有循环（终止执行后面的所有循环）</li><li>下面的例子中，脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到<code>shell</code>提示符下，需要使用<code>break</code>命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"输入 1 到 5 之间的数字:"</span></span><br><span class="line">    <span class="built_in">read</span> aNum</span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$aNum</span> <span class="keyword">in</span></span><br><span class="line">        1|2|3|4|5) <span class="built_in">echo</span> <span class="string">"你输入的数字为 <span class="variable">$aNum</span>!"</span></span><br><span class="line">        ;;</span><br><span class="line">        *) <span class="built_in">echo</span> <span class="string">"你输入的数字不是 1 到 5 之间的! 游戏结束"</span></span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="9-9-continue"><a href="#9-9-continue" class="headerlink" title="9.9 continue"></a>9.9 continue</h3><ul><li><code>continue</code>命令与<code>break</code>命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"输入 1 到 5 之间的数字: "</span></span><br><span class="line">    <span class="built_in">read</span> aNum</span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$aNum</span> <span class="keyword">in</span></span><br><span class="line">        1|2|3|4|5) <span class="built_in">echo</span> <span class="string">"你输入的数字为 <span class="variable">$aNum</span>!"</span></span><br><span class="line">        ;;</span><br><span class="line">        *) <span class="built_in">echo</span> <span class="string">"你输入的数字不是 1 到 5 之间的!"</span></span><br><span class="line">            <span class="built_in">continue</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"游戏结束"</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="十、函数"><a href="#十、函数" class="headerlink" title="十、函数"></a>十、函数</h2><ul><li>linux shell 可以定义函数，然后在shell脚本中可以随便调用。</li><li>shell中函数的定义格式如下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="keyword">function</span> ] funname [()]</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    action;</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">return</span> int;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以带<code>function fun()</code> 定义，也可以直接<code>fun()</code> 定义,不带任何参数。</li><li>参数返回，可以显示加：<code>return</code> 返回，如果不加，将以最后一条命令运行结果，作为返回值。 <code>return</code>后跟数值<code>n(0-255)</code></li></ul><blockquote><p>下面的例子定义了一个函数并进行调用</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">demoFun</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"这是我的第一个 shell 函数!"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"-----函数开始执行-----"</span></span><br><span class="line">demoFun</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"-----函数执行完毕-----"</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----函数开始执行-----</span><br><span class="line">这是我的第一个 shell 函数!</span><br><span class="line">-----函数执行完毕-----</span><br></pre></td></tr></table></figure><ul><li>下面定义一个带有<code>return</code>语句的函数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">fun</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"这个函数会对输入的两个数字进行相加运算..."</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"输入第一个数字: "</span></span><br><span class="line">    <span class="built_in">read</span> aNum</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"输入第二个数字: "</span></span><br><span class="line">    <span class="built_in">read</span> anotherNum</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"两个数字分别为 <span class="variable">$aNum</span> 和 <span class="variable">$anotherNum</span> !"</span></span><br><span class="line">    <span class="built_in">return</span> $((<span class="variable">$aNum</span>+<span class="variable">$anotherNum</span>))</span><br><span class="line">&#125;</span><br><span class="line">sum=fun</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"输入的两个数字之和为 <span class="variable">$&#123;sum&#125;</span>"</span></span><br></pre></td></tr></table></figure><ul><li>输出类似下面</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这个函数会对输入的两个数字进行相加运算...</span><br><span class="line">输入第一个数字: </span><br><span class="line">1</span><br><span class="line">输入第二个数字: </span><br><span class="line">2</span><br><span class="line">两个数字分别为 1 和 2 !</span><br><span class="line">输入的两个数字之和为 3 !</span><br></pre></td></tr></table></figure><ul><li>注意：<strong>所有函数在使用前必须定义</strong>。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。</li></ul><p><strong>函数参数</strong></p><ul><li>在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 <code>$n</code> 的形式来获取参数的值，例如，<code>$1</code>表示第一个参数，<code>$2</code>表示第二个参数..</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">funWithParam</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"第一个参数为 <span class="variable">$1</span> !"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"第二个参数为 <span class="variable">$2</span> !"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"第十个参数为 <span class="variable">$10</span> !"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"第十个参数为 <span class="variable">$&#123;10&#125;</span> !"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"第十一个参数为 <span class="variable">$&#123;11&#125;</span> !"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"参数总数有 <span class="variable">$#</span> 个!"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"作为一个字符串输出所有参数 $* !"</span></span><br><span class="line">&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一个参数为 1 !</span><br><span class="line">第二个参数为 2 !</span><br><span class="line">第十个参数为 10 !</span><br><span class="line">第十个参数为 34 !</span><br><span class="line">第十一个参数为 73 !</span><br><span class="line">参数总数有 11 个!</span><br><span class="line">作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近使用&lt;code&gt;shell&lt;/code&gt;比较多，这里记录一下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、初识shell&quot;&gt;&lt;a href=&quot;#一、初识shell&quot; class=&quot;headerlink&quot; title=&quot;一、初识she
      
    
    </summary>
    
      <category term="Back-end" scheme="http://blog.poetries.top/categories/Back-end/"/>
    
    
      <category term="Linux" scheme="http://blog.poetries.top/tags/Linux/"/>
    
      <category term="Shell" scheme="http://blog.poetries.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>nodejs系列之express</title>
    <link href="http://blog.poetries.top/2018/12/23/express/"/>
    <id>http://blog.poetries.top/2018/12/23/express/</id>
    <published>2018-12-23T15:02:10.000Z</published>
    <updated>2019-01-07T08:48:58.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><blockquote><p>官网 <a href="http://expressjs.com/zh-cn/" target="_blank" rel="noopener">http://expressjs.com/zh-cn/</a></p></blockquote><blockquote><p><code>Express</code>是目前最流行的基于Node.js的Web开发框架，可以快速地搭建一个完整功能的网站</p></blockquote><p><strong>环境搭建</strong></p><blockquote><p><a href="http://www.expressjs.com.cn/starter/generator.html" target="_blank" rel="noopener">http://www.expressjs.com.cn/starter/generator.html</a></p></blockquote><blockquote><p>通过应用生成器工具 <code>express-generator</code>可以快速创建一个应用的骨架</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install express-generator -g</span><br></pre></td></tr></table></figure><h2 id="二、运行原理"><a href="#二、运行原理" class="headerlink" title="二、运行原理"></a>二、运行原理</h2><p><strong>底层：http模块</strong></p><blockquote><p>Express框架建立在node.js内置的http模块上。http模块生成服务器的原始代码如下</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">  response.end(<span class="string">"Hello world!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="string">"localhost"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>Express框架的核心是对http模块的再包装。上面的代码用Express改写如下</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">'Hello world!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><blockquote><p>Express框架等于在http模块之上，加了一个中间层</p></blockquote><p><strong>什么是中间件</strong></p><blockquote><ul><li>简单说，中间件（middleware）就是处理HTTP请求的函数。它最大的特点就是，一个中间件处理完，再传递给下一个中间件。App实例在运行过程中，会调用一系列的中间件</li><li>每个中间件可以从App实例，接收三个参数，依次为request对象（代表HTTP请求）、response对象（代表HTTP回应），next回调函数（代表下一个中间件）。每个中间件都可以对HTTP请求（request对象）进行加工，并且决定是否调用next方法，将request对象再传给下一个中间件。</li></ul></blockquote><ul><li>一个不进行任何操作、只传递<code>request</code>对象的中间件，就是下面这样</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uselessMiddleware</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面代码的next就是下一个中间件。如果它带有参数，则代表抛出一个错误，参数为错误文本</li><li>抛出错误以后，后面的中间件将不再执行，直到发现一个错误处理函数为止</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uselessMiddleware</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  next(<span class="string">'出错了！'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、use方法"><a href="#三、use方法" class="headerlink" title="三、use方法"></a>三、use方法</h2><blockquote><p>use是express注册中间件的方法，它返回一个函数。下面是一个连续调用两个中间件的例子</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"In comes a "</span> + request.method + <span class="string">" to "</span> + request.url);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">  response.end(<span class="string">"Hello world!\n"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.createServer(app).listen(<span class="number">1337</span>);</span><br></pre></td></tr></table></figure><blockquote><p>上面代码使用app.use方法，注册了两个中间件。收到HTTP请求后，先调用第一个中间件，在控制台输出一行信息，然后通过next方法，将执行权传给第二个中间件，输出HTTP回应。由于第二个中间件没有调用next方法，所以request对象就不再向后传递了</p></blockquote><ul><li>use方法内部可以对访问路径进行判断，据此就能实现简单的路由，根据不同的请求网址，返回不同的网页内容</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (request.url == <span class="string">"/"</span>) &#123;</span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">    response.end(<span class="string">"Welcome to the homepage!\n"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (request.url == <span class="string">"/about"</span>) &#123;</span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">404</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">  response.end(<span class="string">"404 error!\n"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.createServer(app).listen(<span class="number">1337</span>);</span><br></pre></td></tr></table></figure><blockquote><p>上面代码通过<code>request.url</code>属性，判断请求的网址，从而返回不同的内容。注意，<code>app.use</code>方法一共登记了三个中间件，只要请求路径匹配，就不会将执行权交给下一个中间件。因此，最后一个中间件会返回<code>404</code>错误，即前面的中间件都没匹配请求路径，找不到所要请求的资源</p></blockquote><ul><li>除了在回调函数内部判断请求的网址，<code>use</code>方法也允许将请求网址写在第一个参数。这代表，只有请求路径匹配这个参数，后面的中间件才会生效。无疑，这样写更加清晰和方便</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只对根目录的请求，调用某个中间件</span></span><br><span class="line">app.use(<span class="string">'/path'</span>, someMiddleware);</span><br></pre></td></tr></table></figure><ul><li>因此，上面的代码可以写成下面的样子</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ar express = require(&quot;express&quot;);</span><br><span class="line">var http = require(&quot;http&quot;);</span><br><span class="line"></span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">app.use(&quot;/home&quot;, function(request, response, next) &#123;</span><br><span class="line">  response.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;);</span><br><span class="line">  response.end(&quot;Welcome to the homepage!\n&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(&quot;/about&quot;, function(request, response, next) &#123;</span><br><span class="line">  response.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;);</span><br><span class="line">  response.end(&quot;Welcome to the about page!\n&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(function(request, response) &#123;</span><br><span class="line">  response.writeHead(404, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;);</span><br><span class="line">  response.end(&quot;404 error!\n&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.createServer(app).listen(1337)</span><br></pre></td></tr></table></figure><h2 id="四、Express的方法"><a href="#四、Express的方法" class="headerlink" title="四、Express的方法"></a>四、Express的方法</h2><p><strong>all方法和HTTP动词方法</strong></p><blockquote><p>针对不同的请求，Express提供了use方法的一些别名。比如，上面代码也可以用别名的形式来写</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.all(<span class="string">"*"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"/"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.end(<span class="string">"Welcome to the homepage!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"/about"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.end(<span class="string">"Welcome to the about page!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"*"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.end(<span class="string">"404!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.createServer(app).listen(<span class="number">1337</span>);</span><br></pre></td></tr></table></figure><blockquote><ul><li>上面代码的all方法表示，所有请求都必须通过该中间件，参数中的“*”表示对所有路径有效。get方法则是只有GET动词的HTTP请求通过该中间件，它的第一个参数是请求的路径。由于get方法的回调函数没有调用next方法，所以只要有一个中间件被调用了，后面的中间件就不会再被调用了</li><li>除了get方法以外，Express还提供post、put、delete方法，即HTTP动词都是Express的方法</li></ul></blockquote><ul><li>除了get方法以外，Express还提供post、put、delete方法，即HTTP动词都是Express的方法</li><li>这些方法的第一个参数，都是请求的路径。除了绝对匹配以外，Express允许模式匹配</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">"/hello/:who"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.end(<span class="string">"Hello, "</span> + req.params.who + <span class="string">"."</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="五、set方法"><a href="#五、set方法" class="headerlink" title="五、set方法"></a>五、set方法</h2><blockquote><p>set方法用于指定变量的值</p></blockquote><ul><li>使用set方法，为系统变量“views”和“view engine”指定值<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.set(<span class="string">"views"</span>, __dirname + <span class="string">"/views"</span>);</span><br><span class="line"></span><br><span class="line">app.set(<span class="string">"view engine"</span>, <span class="string">"jade"</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="六、response对象"><a href="#六、response对象" class="headerlink" title="六、response对象"></a>六、response对象</h2><p><strong>（1）response.redirect方法</strong></p><blockquote><p>response.redirect方法允许网址的重定向</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.redirect(<span class="string">"/hello/anime"</span>);</span><br><span class="line">response.redirect(<span class="string">"http://www.example.com"</span>);</span><br><span class="line">response.redirect(<span class="number">301</span>, <span class="string">"http://www.example.com"</span>);</span><br></pre></td></tr></table></figure><p><strong>（2）response.sendFile方法</strong></p><blockquote><p>response.sendFile方法用于发送文件</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendFile(<span class="string">"/path/to/anime.mp4"</span>);</span><br></pre></td></tr></table></figure><p><strong>（3）response.render方法</strong></p><blockquote><p>response.render方法用于渲染网页模板。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//  使用render方法，将message变量传入index模板，渲染成HTML网页</span><br><span class="line">app.get(&quot;/&quot;, function(request, response) &#123;</span><br><span class="line">  response.render(&quot;index&quot;, &#123; message: &quot;Hello World&quot; &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="七、requst对象"><a href="#七、requst对象" class="headerlink" title="七、requst对象"></a>七、requst对象</h2><p><strong>（1）request.ip</strong></p><blockquote><p>request.ip属性用于获得HTTP请求的IP地址</p></blockquote><p><strong>（2）request.files</strong></p><blockquote><p>request.files用于获取上传的文件</p></blockquote><h2 id="八、搭建HTTPs服务器"><a href="#八、搭建HTTPs服务器" class="headerlink" title="八、搭建HTTPs服务器"></a>八、搭建HTTPs服务器</h2><blockquote><p>使用Express搭建HTTPs加密服务器，也很简单</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  key: fs.readFileSync(<span class="string">'E:/ssl/myserver.key'</span>),</span><br><span class="line">  cert: fs.readFileSync(<span class="string">'E:/ssl/myserver.crt'</span>),</span><br><span class="line">  passphrase: <span class="string">'1234'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> https = <span class="built_in">require</span>(<span class="string">'https'</span>);</span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  res.send(<span class="string">'Hello World Expressjs'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = https.createServer(options, app);</span><br><span class="line">server.listen(<span class="number">8084</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running on port 8084'</span>);</span><br></pre></td></tr></table></figure><h2 id="九、静态网页模板"><a href="#九、静态网页模板" class="headerlink" title="九、静态网页模板"></a>九、静态网页模板</h2><blockquote><ul><li>在项目目录之中，建立一个子目录views，用于存放网页模板</li><li>假定这个项目有三个路径：根路径（/）、自我介绍（/about）和文章（/article）。那么，app.js可以这样写</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向服务器发送信息的方法，从send变成了sendfile，后者专门用于发送文件</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"> </span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   res.sendfile(<span class="string">'./views/index.html'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">app.get(<span class="string">'/about'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   res.sendfile(<span class="string">'./views/about.html'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">app.get(<span class="string">'/article'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   res.sendfile(<span class="string">'./views/article.html'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><h2 id="十、动态网页模板"><a href="#十、动态网页模板" class="headerlink" title="十、动态网页模板"></a>十、动态网页模板</h2><p><strong>安装模板引擎</strong></p><blockquote><p>Express支持多种模板引擎，这里采用Handlebars模板引擎的服务器端版本hbs模板引擎</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hbs --save-dev</span><br></pre></td></tr></table></figure><ul><li>安装模板引擎之后，就要改写app.js</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载hbs模块</span></span><br><span class="line"><span class="keyword">var</span> hbs = <span class="built_in">require</span>(<span class="string">'hbs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定模板文件的后缀名为html</span></span><br><span class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'html'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行hbs模块</span></span><br><span class="line">app.engine(<span class="string">'html'</span>, hbs.__express);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">res.render(<span class="string">'index'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/about'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">res.render(<span class="string">'about'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/article'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">res.render(<span class="string">'article'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>上面代码改用render方法，对网页模板进行渲染。render方法的参数就是模板的文件名，默认放在子目录views之中，后缀名已经在前面指定为html，这里可以省略。所以，res.render(‘index’) 就是指，把子目录views下面的index.html文件，交给模板引擎hbs渲染</p></blockquote><h2 id="十一、新建数据脚本"><a href="#十一、新建数据脚本" class="headerlink" title="十一、新建数据脚本"></a>十一、新建数据脚本</h2><blockquote><ul><li>渲染是指将数据代入模板的过程。实际运用中，数据都是保存在数据库之中的，这里为了简化问题，假定数据保存在一个脚本文件中</li><li>在项目目录中，新建一个文件blog.js，用于存放数据。blog.js的写法符合CommonJS规范，使得它可以被require语句加载</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// blog.js文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> entries = [</span><br><span class="line">&#123;<span class="string">"id"</span>:<span class="number">1</span>, <span class="string">"title"</span>:<span class="string">"第一篇"</span>, <span class="string">"body"</span>:<span class="string">"正文"</span>, <span class="string">"published"</span>:<span class="string">"6/2/2013"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"id"</span>:<span class="number">2</span>, <span class="string">"title"</span>:<span class="string">"第二篇"</span>, <span class="string">"body"</span>:<span class="string">"正文"</span>, <span class="string">"published"</span>:<span class="string">"6/3/2013"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"id"</span>:<span class="number">3</span>, <span class="string">"title"</span>:<span class="string">"第三篇"</span>, <span class="string">"body"</span>:<span class="string">"正文"</span>, <span class="string">"published"</span>:<span class="string">"6/4/2013"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"id"</span>:<span class="number">4</span>, <span class="string">"title"</span>:<span class="string">"第四篇"</span>, <span class="string">"body"</span>:<span class="string">"正文"</span>, <span class="string">"published"</span>:<span class="string">"6/5/2013"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"id"</span>:<span class="number">5</span>, <span class="string">"title"</span>:<span class="string">"第五篇"</span>, <span class="string">"body"</span>:<span class="string">"正文"</span>, <span class="string">"published"</span>:<span class="string">"6/10/2013"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"id"</span>:<span class="number">6</span>, <span class="string">"title"</span>:<span class="string">"第六篇"</span>, <span class="string">"body"</span>:<span class="string">"正文"</span>, <span class="string">"published"</span>:<span class="string">"6/12/2013"</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">exports.getBlogEntries = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> entries;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">exports.getBlogEntry = <span class="function"><span class="keyword">function</span> (<span class="params">id</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; entries.length; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(entries[i].id == id) <span class="keyword">return</span> entries[i];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十二、新建网页模板"><a href="#十二、新建网页模板" class="headerlink" title="十二、新建网页模板"></a>十二、新建网页模板</h2><blockquote><p>接着，新建模板文件<code>index.html</code></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- views/index.html文件 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;文章列表&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">&#123;&#123;#each entries&#125;&#125;</span></span><br><span class="line"><span class="regexp">   &lt;p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;a href="/</span>article/&#123;&#123;id&#125;&#125;<span class="string">"&gt;&#123;&#123;title&#125;&#125;&lt;/a&gt;&lt;br/&gt;</span></span><br><span class="line"><span class="string">      Published: &#123;&#123;published&#125;&#125;</span></span><br><span class="line"><span class="string">   &lt;/p&gt;</span></span><br><span class="line"><span class="string">&#123;&#123;/each&#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- views/about.html文件 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;自我介绍&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">&lt;p&gt;正文&lt;/</span>p&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- views/article.html文件 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;&#123;&#123;blog.title&#125;&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">Published: &#123;&#123;blog.published&#125;&#125;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">&lt;p/</span>&gt;</span><br><span class="line"> </span><br><span class="line">&#123;&#123;blog.body&#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看到，上面三个模板文件都只有网页主体。因为网页布局是共享的，所以布局的部分可以单独新建一个文件<code>layout.html</code></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- views/layout.html文件 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line"> </span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;&#123;&#123;title&#125;&#125;&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line"> </span><br><span class="line">&lt;body&gt;</span><br><span class="line"> </span><br><span class="line">&#123;&#123;&#123;body&#125;&#125;&#125;</span><br><span class="line"> </span><br><span class="line">   &lt;footer&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">         &lt;a href=<span class="string">"/"</span>&gt;首页&lt;<span class="regexp">/a&gt; - &lt;a href="/</span>about<span class="string">"&gt;自我介绍&lt;/a&gt;</span></span><br><span class="line"><span class="string">      &lt;/p&gt;</span></span><br><span class="line"><span class="string">   &lt;/footer&gt;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure><h2 id="十三、渲染模板"><a href="#十三、渲染模板" class="headerlink" title="十三、渲染模板"></a>十三、渲染模板</h2><blockquote><p>最后，改写app.js文件</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> hbs = <span class="built_in">require</span>(<span class="string">'hbs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载数据模块</span></span><br><span class="line"><span class="keyword">var</span> blogEngine = <span class="built_in">require</span>(<span class="string">'./blog'</span>);</span><br><span class="line"> </span><br><span class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'html'</span>);</span><br><span class="line">app.engine(<span class="string">'html'</span>, hbs.__express);</span><br><span class="line">app.use(express.bodyParser());</span><br><span class="line"> </span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   res.render(<span class="string">'index'</span>,&#123;<span class="attr">title</span>:<span class="string">"最近文章"</span>, <span class="attr">entries</span>:blogEngine.getBlogEntries()&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">app.get(<span class="string">'/about'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   res.render(<span class="string">'about'</span>, &#123;<span class="attr">title</span>:<span class="string">"自我介绍"</span>&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">app.get(<span class="string">'/article/:id'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> entry = blogEngine.getBlogEntry(req.params.id);</span><br><span class="line">   res.render(<span class="string">'article'</span>,&#123;<span class="attr">title</span>:entry.title, <span class="attr">blog</span>:entry&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><ul><li>上面代码中的render方法，现在加入了第二个参数，表示模板变量绑定的数据</li></ul><h2 id="十四、指定静态文件目录"><a href="#十四、指定静态文件目录" class="headerlink" title="十四、指定静态文件目录"></a>十四、指定静态文件目录</h2><blockquote><p>模板文件默认存放在views子目录。这时，如果要在网页中加载静态文件（比如样式表、图片等），就需要另外指定一个存放静态文件的目录</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(<span class="string">'public'</span>));</span><br></pre></td></tr></table></figure><blockquote><p>上面代码在文件app.js之中，指定静态文件存放的目录是public。于是，当浏览器发出非HTML文件请求时，服务器端就到public目录寻找这个文件。比如，浏览器发出如下的样式表请求：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=<span class="string">"/bootstrap/css/bootstrap.css"</span> rel=<span class="string">"stylesheet"</span>&gt;</span><br></pre></td></tr></table></figure><ul><li>服务器端就到<code>public/bootstrap/css/</code>目录中寻找<code>bootstrap.css</code>文件</li></ul><h2 id="十五、Express-Router用法"><a href="#十五、Express-Router用法" class="headerlink" title="十五、Express.Router用法"></a>十五、Express.Router用法</h2><blockquote><p>从<code>Express 4.0</code>开始，路由器功能成了一个单独的组件<code>Express.Router</code>。它好像小型的<code>express</code>应用程序一样，有自己的<code>use</code>、<code>get</code>、<code>param</code>和<code>route</code>方法</p></blockquote><p><strong>基本用法</strong></p><blockquote><p>首先，Express.Router是一个构造函数，调用后返回一个路由器实例。然后，使用该实例的HTTP动词方法，为不同的访问路径，指定回调函数；最后，挂载到某个路径。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">'首页'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/about'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">'关于'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/'</span>, router);</span><br></pre></td></tr></table></figure><blockquote><ul><li>上面代码先定义了两个访问路径，然后将它们挂载到根目录</li><li>这种路由器可以自由挂载的做法，为程序带来了更大的灵活性，既可以定义多个路由器实例，也可以为将同一个路由器实例挂载到多个路径。</li></ul></blockquote><h2 id="十六、router-route方法"><a href="#十六、router-route方法" class="headerlink" title="十六、router.route方法"></a>十六、router.route方法</h2><blockquote><p>router实例对象的route方法，可以接受访问路径作为参数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"></span><br><span class="line">router.route(<span class="string">'/api'</span>)</span><br><span class="line">.post(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line">.get(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">Bear.find(<span class="function"><span class="keyword">function</span>(<span class="params">err, bears</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (err) res.send(err);</span><br><span class="line">res.json(bears);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/'</span>, router);</span><br></pre></td></tr></table></figure><h2 id="十七、router中间件"><a href="#十七、router中间件" class="headerlink" title="十七、router中间件"></a>十七、router中间件</h2><blockquote><p>use方法为router对象指定中间件，即在数据正式发给用户之前，对数据进行处理。下面就是一个中间件的例子</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(req.method, req.url);</span><br><span class="line">next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>上面代码中，回调函数的next参数，表示接受其他中间件的调用。函数体中的next()，表示将数据传递给下一个中间件</li><li>注意，中间件的放置顺序很重要，等同于执行顺序。而且，中间件必须放在HTTP动词方法之前，否则不会执行</li></ul><h2 id="十八、对路径参数的处理"><a href="#十八、对路径参数的处理" class="headerlink" title="十八、对路径参数的处理"></a>十八、对路径参数的处理</h2><blockquote><p>router对象的param方法用于路径参数的处理，可以</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">router.param(<span class="string">'name'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next, name</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 对name进行验证或其他处理……</span></span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line">req.name = name;</span><br><span class="line">next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/hello/:name'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">res.send(<span class="string">'hello '</span> + req.name + <span class="string">'!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>上面代码中，get方法为访问路径指定了name参数，param方法则是对name参数进行处理。注意，param方法必须放在HTTP动词方法之前</p></blockquote><h2 id="十九、app-route"><a href="#十九、app-route" class="headerlink" title="十九、app.route"></a>十九、app.route</h2><blockquote><ul><li>假定app是Express的实例对象，Express 4.0为该对象提供了一个route属性。app.route实际上是express.Router()的缩写形式，直接挂载到根路径</li><li>因此，对同一个路径指定get和post方法的回调函数，可以写成链式形式</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.route(<span class="string">'/login'</span>)</span><br><span class="line">.get(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">res.send(<span class="string">'this is the login form'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.post(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'processing'</span>);</span><br><span class="line">res.send(<span class="string">'processing the login form!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="二十、上传文件"><a href="#二十、上传文件" class="headerlink" title="二十、上传文件"></a>二十、上传文件</h2><ul><li>首先，在网页插入上传文件的表单</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">"/pictures/upload"</span> method=<span class="string">"POST"</span> enctype=<span class="string">"multipart/form-data"</span>&gt;</span><br><span class="line">  Select an image to upload:</span><br><span class="line">  &lt;input type=<span class="string">"file"</span> name=<span class="string">"image"</span>&gt;</span><br><span class="line">  &lt;input type=<span class="string">"submit"</span> value=<span class="string">"Upload Image"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/form&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>然后，服务器脚本建立指向/upload目录的路由。这时可以安装multer模块，它提供了上传文件的许多功能</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"><span class="keyword">var</span> multer = <span class="built_in">require</span>(<span class="string">'multer'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> uploading = multer(&#123;</span><br><span class="line">  dest: __dirname + <span class="string">'../public/uploads/'</span>,</span><br><span class="line">  <span class="comment">// 设定限制，每次最多上传1个文件，文件大小不超过1MB</span></span><br><span class="line">  limits: &#123;<span class="attr">fileSize</span>: <span class="number">1000000</span>, <span class="attr">files</span>:<span class="number">1</span>&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">'/upload'</span>, uploading, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;官网 &lt;a href=&quot;http://expressjs.com/zh-cn/&quot; target=&quot;
      
    
    </summary>
    
      <category term="Back-End" scheme="http://blog.poetries.top/categories/Back-End/"/>
    
    
      <category term="Node" scheme="http://blog.poetries.top/tags/Node/"/>
    
      <category term="Express" scheme="http://blog.poetries.top/tags/Express/"/>
    
  </entry>
  
  <entry>
    <title>nodejs系列之Koa2</title>
    <link href="http://blog.poetries.top/2018/12/23/koa2/"/>
    <id>http://blog.poetries.top/2018/12/23/koa2/</id>
    <published>2018-12-23T11:10:43.000Z</published>
    <updated>2019-01-07T08:48:58.304Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>来源互联网</p></blockquote><h2 id="一、基本用法"><a href="#一、基本用法" class="headerlink" title="一、基本用法"></a>一、基本用法</h2><blockquote><p>Koa 就是一种简单好用的 Web 框架。它的特点是优雅、简洁、表达力强、自由度高</p></blockquote><p><strong>1.1 架设 HTTP 服务</strong></p><blockquote><p>只要三行代码，就可以用 <code>Koa</code> 架设一个 <code>HTTP</code> 服务。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><blockquote><p>打开浏览器，访问<code>http://127.0.0.1:3000</code> 。你会看到页面显示”Not Found”，表示没有发现任何内容。这是因为我们并没有告诉 <code>Koa</code> 应该显示什么内容</p></blockquote><p><strong>通过脚手架构建服务</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install koa-generator -g</span><br></pre></td></tr></table></figure><blockquote><p>创建一个项目 <code>koa2 -e hello-koa2</code> <code>-e</code>表示<code>ejs</code>语法，不写则是<code>jade</code>语法</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-1f13c3fb768c8910.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>打开浏览器，访问<code>http://127.0.0.1:3000</code> </p></blockquote><p><strong>1.2 Context 对象</strong></p><blockquote><p><code>Koa</code> 提供一个 <code>Context</code> 对象，表示一次对话的上下文（包括 <code>HTTP</code> 请求和 <code>HTTP</code> 回复）。通过加工这个对象，就可以控制返回给用户的内容</p></blockquote><ul><li><code>Context.response.body</code>属性就是发送给用户的内容</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">"koa"</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="params">ctx</span> =&gt;</span> &#123; <span class="comment">//处理请求的中间件</span></span><br><span class="line">    ctx.response.body = <span class="string">"hello world"</span>;</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><blockquote><p>上面代码中，<code>main</code>函数用来设置<code>ctx.response.body</code>。然后，使用<code>app.use</code>方法加载<code>main</code>函数</p></blockquote><ul><li><code>ctx.response</code>代表 <code>HTTP Response</code>。同样地，<code>ctx.request</code>代表 <code>HTTP Request</code></li></ul><p><strong>1.3 HTTP Response 的类型</strong></p><blockquote><p><code>Koa</code> 默认的返回类型是<code>text/plain</code>，如果想返回其他类型的内容，可以先用<code>ctx.request.accepts</code>判断一下，客户端希望接受什么数据（根据 <code>HTTP Request</code> 的Accept字段），然后使用<code>ctx.response.type</code>指定返回类型</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">"koa"</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.request.accepts(<span class="string">'xml'</span>)) &#123;</span><br><span class="line">        ctx.response.type = <span class="string">'xml'</span>;</span><br><span class="line">        ctx.response.body = <span class="string">'&lt;data&gt;Hello World&lt;/data&gt;'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ctx.request.accepts(<span class="string">'json'</span>)) &#123;</span><br><span class="line">        ctx.response.type = <span class="string">'json'</span>;</span><br><span class="line">        ctx.response.body = &#123; <span class="attr">data</span>: <span class="string">'Hello World'</span> &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ctx.request.accepts(<span class="string">'html'</span>)) &#123;</span><br><span class="line">        ctx.response.type = <span class="string">'html'</span>;</span><br><span class="line">        ctx.response.body = <span class="string">'&lt;p&gt;Hello World&lt;/p&gt;'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.response.type = <span class="string">'text'</span>;</span><br><span class="line">        ctx.response.body = <span class="string">'Hello World'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p><strong>1.4 网页模板</strong></p><blockquote><p>实际开发中，返回给用户的网页往往都写成模板文件。我们可以让 Koa 先读取模板文件，然后将这个模板返回给用户</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">"koa"</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">    ctx.response.type = <span class="string">'html'</span>;</span><br><span class="line">    ctx.response.body = fs.createReadStream(<span class="string">'./demos/template.html'</span>);</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><h2 id="二、路由"><a href="#二、路由" class="headerlink" title="二、路由"></a>二、路由</h2><blockquote><p>网站一般都有多个页面。通过<code>ctx.request.path</code>可以获取用户请求的路径，由此实现简单的路由</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">"koa"</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.request.path !== <span class="string">'/'</span>) &#123;</span><br><span class="line">        ctx.response.type = <span class="string">'html'</span>;</span><br><span class="line">        ctx.response.body = <span class="string">'&lt;a href="/"&gt;Index Page1&lt;/a&gt;'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.response.body = <span class="string">'Hello World'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p><strong>2.2 koa-route 模块</strong></p><blockquote><p>原生路由用起来不太方便，我们可以使用封装好的<code>koa-route</code>模块</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">"koa"</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> route = <span class="built_in">require</span>(<span class="string">'koa-route'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = route.get(<span class="string">"/"</span>, ctx =&gt; &#123;</span><br><span class="line">    ctx.response.type = <span class="string">'html'</span>;</span><br><span class="line">    ctx.response.body = <span class="string">'&lt;a href="/"&gt;Index Page1&lt;/a&gt;'</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> about = route.get(<span class="string">"/about"</span>, ctx =&gt; &#123;</span><br><span class="line">    ctx.response.body = <span class="string">'Hello World'</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(main);</span><br><span class="line">app.use(about);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p><strong>2.3 静态资源</strong></p><blockquote><p>如果网站提供静态资源（图片、字体、样式表、脚本……），为它们一个个写路由就很麻烦，也没必要。<code>koa-static</code>模块封装了这部分的请求</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问 http://localhost:3000/test.json</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">"koa"</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> serve = <span class="built_in">require</span>(<span class="string">'koa-static'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = serve(path.join(__dirname, <span class="string">"../public/"</span>));</span><br><span class="line"></span><br><span class="line">app.use(main);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p><strong>2.4 重定向</strong></p><blockquote><p>有些场合，服务器需要重定向（<code>redirect</code>）访问请求。比如，用户登陆以后，将他重定向到登陆前的页面。<code>ctx.response.redirect()</code>方法可以发出一个<code>302</code>跳转，将用户导向另一个路由</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">"koa"</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> route = <span class="built_in">require</span>(<span class="string">"koa-route"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> redirect = route.get(<span class="string">"/redirect"</span>, ctx =&gt; &#123;</span><br><span class="line">    ctx.response.redirect(<span class="string">'/'</span>);</span><br><span class="line">    ctx.response.body = <span class="string">'&lt;a href="/"&gt;Index Page&lt;/a&gt;'</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> main = route.get(<span class="string">"/"</span>, ctx =&gt; &#123;</span><br><span class="line">    ctx.response.body = <span class="string">"hello world"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(main);</span><br><span class="line">app.use(redirect);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><h2 id="三、中间件"><a href="#三、中间件" class="headerlink" title="三、中间件"></a>三、中间件</h2><p><strong>3.1 Logger 功能</strong></p><blockquote><p>Koa 的最大特色，也是最重要的一个设计，就是中间件（middleware）。为了理解中间件，我们先看一下 Logger （打印日志）功能的实现</p></blockquote><p><strong>3.2 中间件的概念</strong></p><blockquote><p>“中间件”（middleware），它处在 HTTP Request 和 HTTP Response 中间，用来实现某种中间功能。app.use()用来加载中间件</p></blockquote><ul><li>基本上，Koa 所有的功能都是通过中间件实现的，前面例子里面的main也是中间件</li><li>每个中间件默认接受两个参数，第一个参数是 Context 对象，第二个参数是next函数。只要调用next函数，就可以把执行权转交给下一个中间件</li></ul><p><strong>3.3 中间件栈</strong></p><blockquote><p>多个中间件会形成一个栈结构（<code>middle stack</code>），以”先进后出”（<code>first-in-last-out</code>）的顺序执行</p></blockquote><ul><li>最外层的中间件首先执行。</li><li>调用next函数，把执行权交给下一个中间件。</li><li>…</li><li>最内层的中间件最后执行。</li><li>执行结束后，把执行权交回上一层的中间件。</li><li>…</li><li>最外层的中间件收回执行权之后，执行next函数后面的代码</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'&gt;&gt; one'</span>);</span><br><span class="line">  next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'&lt;&lt; one'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> two = <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'&gt;&gt; two'</span>);</span><br><span class="line">  next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'&lt;&lt; two'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> three = <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'&gt;&gt; three'</span>);</span><br><span class="line">  next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'&lt;&lt; three'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(one);</span><br><span class="line">app.use(two);</span><br><span class="line">app.use(three);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; one</span><br><span class="line">&gt;&gt; two</span><br><span class="line">&gt;&gt; three</span><br><span class="line">&lt;&lt; three</span><br><span class="line">&lt;&lt; two</span><br><span class="line">&lt;&lt; one</span><br></pre></td></tr></table></figure><blockquote><p>如果中间件内部没有调用<code>next</code>函数，那么执行权就不会传递下去</p></blockquote><p><strong>3.4 异步中间件</strong></p><blockquote><p>如果有异步操作（比如读取数据库），中间件就必须写成 <code>async</code> 函数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs.promised'</span>);</span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">  ctx.response.type = <span class="string">'html'</span>;</span><br><span class="line">  ctx.response.body = <span class="keyword">await</span> fs.readFile(<span class="string">'./demos/template.html'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.use(main);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><blockquote><p>上面代码中，<code>fs.readFile</code>是一个异步操作，必须写成<code>await fs.readFile()</code>，然后中间件必须写成 <code>async</code>函数。</p></blockquote><p><strong>3.5 中间件的合成</strong></p><blockquote><p><code>koa-compose</code>模块可以将多个中间件合成为一个</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> compose = <span class="built_in">require</span>(<span class="string">'koa-compose'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span> <span class="subst">$&#123;ctx.request.method&#125;</span> <span class="subst">$&#123;ctx.request.url&#125;</span>`</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = <span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">  ctx.response.body = <span class="string">'Hello World'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> middlewares = compose([logger, main]);</span><br><span class="line"></span><br><span class="line">app.use(middlewares);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><h2 id="四、错误处理"><a href="#四、错误处理" class="headerlink" title="四、错误处理"></a>四、错误处理</h2><p><strong>4.1 500 错误</strong></p><blockquote><p>如果代码运行过程中发生错误，我们需要把错误信息返回给用户。HTTP 协定约定这时要返回500状态码</p></blockquote><ul><li><code>Koa</code>提供了<code>ctx.throw()</code>方法，用来抛出错误，<code>ctx.throw(500)</code>就是抛出<code>500</code>错误</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = <span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">  ctx.throw(<span class="number">500</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.use(main);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p><strong>4.2 404错误</strong></p><blockquote><p>如果将<code>ctx.response.status</code>设置成<code>404</code>，就相当于<code>ctx.throw(404)</code>，返回<code>404</code>错误</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = <span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">  ctx.response.status = <span class="number">404</span>;</span><br><span class="line">  ctx.response.body = <span class="string">'Page Not Found'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.use(main);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p><strong>4.3 处理错误的中间件</strong></p><blockquote><p>为了方便处理错误，最好使用<code>try...catch</code>将其捕获。但是，为每个中间件都写<code>try...catch</code>太麻烦，我们可以让最外层的中间件，负责所有中间件的错误处理</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    ctx.response.status = err.statusCode || err.status || <span class="number">500</span>;</span><br><span class="line">    ctx.response.body = &#123;</span><br><span class="line">      message: err.message</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = <span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">  ctx.throw(<span class="number">500</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.use(handler);</span><br><span class="line">app.use(main);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p><strong>4.4 error 事件的监听</strong></p><blockquote><p>运行过程中一旦出错，Koa 会触发一个error事件。监听这个事件，也可以处理错误</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = <span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">  ctx.throw(<span class="number">500</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">'error'</span>, (err, ctx) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'server error'</span>, err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(main);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><blockquote><p>访问 <a href="http://127.0.0.1:3000" target="_blank" rel="noopener">http://127.0.0.1:3000</a> ，你会在命令行窗口看到”server error xxx”。</p></blockquote><h2 id="五、Web-App-的功能"><a href="#五、Web-App-的功能" class="headerlink" title="五、Web App 的功能"></a>五、Web App 的功能</h2><p><strong>5.1 Cookies</strong></p><blockquote><p>ctx.cookies用来读写 Cookie</p></blockquote><blockquote><p>访问 <a href="http://127.0.0.1:3000" target="_blank" rel="noopener">http://127.0.0.1:3000</a> ，你会看到1 views。刷新一次页面，就变成了2 views。再刷新，每次都会计数增加1</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = <span class="function"><span class="keyword">function</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = <span class="built_in">Number</span>(ctx.cookies.get(<span class="string">'view'</span>) || <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">    ctx.cookies.set(<span class="string">'view'</span>, n);</span><br><span class="line">    ctx.response.body = n + <span class="string">' views'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(main);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p><strong>5.2 表单</strong></p><blockquote><p><code>Web</code>应用离不开处理表单。本质上，表单就是<code>POST</code> 方法发送到服务器的键值对。<code>koa-body</code>模块可以用来从 <code>POST</code> 请求的数据体里面提取键值对</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> koaBody = <span class="built_in">require</span>(<span class="string">'koa-body'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> body = ctx.request.body;</span><br><span class="line">  <span class="keyword">if</span> (!body.name) ctx.throw(<span class="number">400</span>, <span class="string">'.name required'</span>);</span><br><span class="line">  ctx.body = &#123; <span class="attr">name</span>: body.name &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.use(koaBody());</span><br><span class="line">app.use(main);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><ul><li>打开另一个命令行窗口，运行下面的命令</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X POST --data <span class="string">"name=Jack"</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">3000</span></span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"Jack"</span>&#125;</span><br><span class="line"></span><br><span class="line">$ curl -X POST --data <span class="string">"name"</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">3000</span></span><br><span class="line">name required</span><br></pre></td></tr></table></figure><blockquote><p>上面代码使用 POST 方法向服务器发送一个键值对，会被正确解析。如果发送的数据不正确，就会收到错误提示。</p></blockquote><p><strong>2.3 文件上传</strong></p><blockquote><p>koa-body模块还可以用来处理文件上传</p></blockquote><ul><li>打开另一个命令行窗口，运行下面的命令，上传一个文件。注意，<code>/path/to/file</code>要更换为真实的文件路径</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl --form upload=@/path/to/file http:<span class="comment">//127.0.0.1:3000</span></span><br><span class="line">[<span class="string">"/tmp/file"</span>]</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">'os'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> koaBody = <span class="built_in">require</span>(<span class="string">'koa-body'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> tmpdir = os.tmpdir();</span><br><span class="line">  <span class="keyword">const</span> filePaths = [];</span><br><span class="line">  <span class="keyword">const</span> files = ctx.request.body.files || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> files) &#123;</span><br><span class="line">    <span class="keyword">const</span> file = files[key];</span><br><span class="line">    <span class="keyword">const</span> filePath = path.join(tmpdir, file.name);</span><br><span class="line">    <span class="keyword">const</span> reader = fs.createReadStream(file.path);</span><br><span class="line">    <span class="keyword">const</span> writer = fs.createWriteStream(filePath);</span><br><span class="line">    reader.pipe(writer);</span><br><span class="line">    filePaths.push(filePath);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ctx.body = filePaths;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.use(koaBody(&#123; <span class="attr">multipart</span>: <span class="literal">true</span> &#125;));</span><br><span class="line">app.use(main);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;来源互联网&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、基本用法&quot;&gt;&lt;a href=&quot;#一、基本用法&quot; class=&quot;headerlink&quot; title=&quot;一、基本用法&quot;&gt;&lt;/a&gt;一、基本用法&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;K
      
    
    </summary>
    
      <category term="Back-End" scheme="http://blog.poetries.top/categories/Back-End/"/>
    
    
      <category term="Node" scheme="http://blog.poetries.top/tags/Node/"/>
    
      <category term="Koa2" scheme="http://blog.poetries.top/tags/Koa2/"/>
    
  </entry>
  
  <entry>
    <title>Object.defineProperty详解</title>
    <link href="http://blog.poetries.top/2018/12/23/Object.defineProperty/"/>
    <id>http://blog.poetries.top/2018/12/23/Object.defineProperty/</id>
    <published>2018-12-23T01:40:12.000Z</published>
    <updated>2019-01-07T08:48:58.280Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>来自网络</p></blockquote><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p><strong>兼容性</strong></p><blockquote><p>在<code>ie8</code>下只能在<code>DOM</code>对象上使用，尝试在原生的对象使用 <code>Object.defineProperty()</code>会报错。</p></blockquote><p>定义对象可以使用构造函数或字面量的形式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>;  <span class="comment">//obj = &#123;&#125;</span></span><br><span class="line">obj.name = <span class="string">"张三"</span>;  <span class="comment">//添加描述</span></span><br><span class="line">obj.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;  <span class="comment">//添加行为</span></span><br></pre></td></tr></table></figure><blockquote><p>除了以上添加属性的方式，还可以使用<code>Object.defineProperty</code>定义新属性或修改原有的属性</p></blockquote><h2 id="二、Object-defineProperty"><a href="#二、Object-defineProperty" class="headerlink" title="二、Object.defineProperty()"></a>二、Object.defineProperty()</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, prop, descriptor)</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong>：</p><ul><li><code>obj</code>：必需。目标对象 </li><li><code>prop</code>：必需。需定义或修改的属性的名字</li><li><code>descriptor</code>：必需。目标属性所拥有的特性</li></ul><blockquote><p>返回值：传入函数的对象。即第一个参数<code>obj</code></p></blockquote><ul><li>针对属性，我们可以给这个属性设置一些特性，比如是否只读不可以写；是否可以被<code>for..in</code>或<code>Object.keys()</code>遍历。</li></ul><p><strong>给对象的属性添加特性描述，目前提供两种形式：数据描述和存取器描述</strong></p><h3 id="2-2-数据描述"><a href="#2-2-数据描述" class="headerlink" title="2.2 数据描述"></a>2.2 数据描述</h3><blockquote><p>当修改或定义对象的某个属性的时候，给这个属性添加一些特性</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    test:<span class="string">"hello"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对象已有的属性添加特性描述</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">"test"</span>,&#123;</span><br><span class="line">    configurable:<span class="literal">true</span> | <span class="literal">false</span>,</span><br><span class="line">    enumerable:<span class="literal">true</span> | <span class="literal">false</span>,</span><br><span class="line">    value:任意类型的值,</span><br><span class="line">    writable:<span class="literal">true</span> | <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//对象新添加的属性的特性描述</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">"newKey"</span>,&#123;</span><br><span class="line">    configurable:<span class="literal">true</span> | <span class="literal">false</span>,</span><br><span class="line">    enumerable:<span class="literal">true</span> | <span class="literal">false</span>,</span><br><span class="line">    value:任意类型的值,</span><br><span class="line">    writable:<span class="literal">true</span> | <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>数据描述中的属性都是可选的，来看一下设置每一个属性的作用</p></blockquote><h4 id="2-2-1-value"><a href="#2-2-1-value" class="headerlink" title="2.2.1 value"></a>2.2.1 value</h4><blockquote><p>属性对应的值,可以使任意类型的值，默认为<code>undefined</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="comment">//第一种情况：不设置value属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">"newKey"</span>,&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log( obj.newKey );  <span class="comment">//undefined</span></span><br><span class="line">------------------------------</span><br><span class="line"><span class="comment">//第二种情况：设置value属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">"newKey"</span>,&#123;</span><br><span class="line">    value:<span class="string">"hello"</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log( obj.newKey );  <span class="comment">//hello</span></span><br></pre></td></tr></table></figure><h4 id="2-2-2-writable"><a href="#2-2-2-writable" class="headerlink" title="2.2.2 writable"></a>2.2.2 writable</h4><blockquote><p>属性的值是否可以被重写。设置为<code>true</code>可以被重写；设置为<code>false</code>，不能被重写。默认为<code>false</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="comment">//第一种情况：writable设置为false，不能重写。</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">"newKey"</span>,&#123;</span><br><span class="line">    value:<span class="string">"hello"</span>,</span><br><span class="line">    writable:<span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//更改newKey的值</span></span><br><span class="line">obj.newKey = <span class="string">"change value"</span>;</span><br><span class="line"><span class="built_in">console</span>.log( obj.newKey );  <span class="comment">//hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种情况：writable设置为true，可以重写</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">"newKey"</span>,&#123;</span><br><span class="line">    value:<span class="string">"hello"</span>,</span><br><span class="line">    writable:<span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//更改newKey的值</span></span><br><span class="line">obj.newKey = <span class="string">"change value"</span>;</span><br><span class="line"><span class="built_in">console</span>.log( obj.newKey );  <span class="comment">//change value</span></span><br></pre></td></tr></table></figure><h4 id="2-2-3-enumerable"><a href="#2-2-3-enumerable" class="headerlink" title="2.2.3 enumerable"></a>2.2.3 enumerable</h4><blockquote><p>此属性是否可以被枚举（使用<code>for...in</code>或<code>Object.keys()</code>）。设置为<code>true</code>可以被枚举；设置为<code>false</code>，不能被枚举。默认为<code>false</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="comment">//第一种情况：enumerable设置为false，不能被枚举。</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">"newKey"</span>,&#123;</span><br><span class="line">    value:<span class="string">"hello"</span>,</span><br><span class="line">    writable:<span class="literal">false</span>,</span><br><span class="line">    enumerable:<span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举对象的属性</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> attr <span class="keyword">in</span> obj )&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( attr );  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种情况：enumerable设置为true，可以被枚举。</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">"newKey"</span>,&#123;</span><br><span class="line">    value:<span class="string">"hello"</span>,</span><br><span class="line">    writable:<span class="literal">false</span>,</span><br><span class="line">    enumerable:<span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举对象的属性</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> attr <span class="keyword">in</span> obj )&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( attr );  <span class="comment">//newKey</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-4-configurable"><a href="#2-2-4-configurable" class="headerlink" title="2.2.4 configurable"></a>2.2.4 configurable</h4><blockquote><p>是否可以删除目标属性或是否可以再次修改属性的特性（<code>writable</code>, <code>configurable</code>, <code>enumerable</code>）。设置为<code>true</code>可以被删除或可以重新设置特性；设置为<code>false</code>，不能被可以被删除或不可以重新设置特性。默认为<code>false</code></p></blockquote><p><strong>这个属性起到两个作用</strong></p><ul><li>目标属性是否可以使用<code>delete</code>删除</li><li>目标属性是否可以再次设置特性</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-----------------测试目标属性是否能被删除------------------------</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="comment">//第一种情况：configurable设置为false，不能被删除。</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">"newKey"</span>,&#123;</span><br><span class="line">    value:<span class="string">"hello"</span>,</span><br><span class="line">    writable:<span class="literal">false</span>,</span><br><span class="line">    enumerable:<span class="literal">false</span>,</span><br><span class="line">    configurable:<span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//删除属性</span></span><br><span class="line"><span class="keyword">delete</span> obj.newKey;</span><br><span class="line"><span class="built_in">console</span>.log( obj.newKey ); <span class="comment">//hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种情况：configurable设置为true，可以被删除。</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">"newKey"</span>,&#123;</span><br><span class="line">    value:<span class="string">"hello"</span>,</span><br><span class="line">    writable:<span class="literal">false</span>,</span><br><span class="line">    enumerable:<span class="literal">false</span>,</span><br><span class="line">    configurable:<span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//删除属性</span></span><br><span class="line"><span class="keyword">delete</span> obj.newKey;</span><br><span class="line"><span class="built_in">console</span>.log( obj.newKey ); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-----------------测试是否可以再次修改特性------------------------</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="comment">//第一种情况：configurable设置为false，不能再次修改特性。</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">"newKey"</span>,&#123;</span><br><span class="line">    value:<span class="string">"hello"</span>,</span><br><span class="line">    writable:<span class="literal">false</span>,</span><br><span class="line">    enumerable:<span class="literal">false</span>,</span><br><span class="line">    configurable:<span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新修改特性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">"newKey"</span>,&#123;</span><br><span class="line">    value:<span class="string">"hello"</span>,</span><br><span class="line">    writable:<span class="literal">true</span>,</span><br><span class="line">    enumerable:<span class="literal">true</span>,</span><br><span class="line">    configurable:<span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log( obj.newKey ); <span class="comment">//报错：Uncaught TypeError: Cannot redefine property: newKey</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种情况：configurable设置为true，可以再次修改特性。</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">"newKey"</span>,&#123;</span><br><span class="line">    value:<span class="string">"hello"</span>,</span><br><span class="line">    writable:<span class="literal">false</span>,</span><br><span class="line">    enumerable:<span class="literal">false</span>,</span><br><span class="line">    configurable:<span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新修改特性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">"newKey"</span>,&#123;</span><br><span class="line">    value:<span class="string">"hello"</span>,</span><br><span class="line">    writable:<span class="literal">true</span>,</span><br><span class="line">    enumerable:<span class="literal">true</span>,</span><br><span class="line">    configurable:<span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log( obj.newKey ); <span class="comment">//hello</span></span><br></pre></td></tr></table></figure><blockquote><p>除了可以给新定义的属性设置特性，也可以给已有的属性设置特性</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义对象的时候添加的属性，是可删除、可重写、可枚举的。</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    test:<span class="string">"hello"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改写值</span></span><br><span class="line">obj.test = <span class="string">'change value'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( obj.test ); <span class="comment">//'change value'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">"test"</span>,&#123;</span><br><span class="line">    writable:<span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//再次改写值</span></span><br><span class="line">obj.test = <span class="string">'change value again'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( obj.test ); <span class="comment">//依然是：'change value'</span></span><br></pre></td></tr></table></figure><blockquote><p>提示：一旦使用<code>Object.defineProperty</code>给对象添加属性，那么如果不设置属性的特性，那么<code>configurable</code>、<code>enumerable</code>、<code>writable</code>这些值都为默认的<code>false</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="comment">//定义的新属性后，这个属性的特性中configurable，enumerable，writable都为默认的值false</span></span><br><span class="line"><span class="comment">//这就导致了neykey这个是不能重写、不能枚举、不能再次设置特性</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">'newKey'</span>,&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置值</span></span><br><span class="line">obj.newKey = <span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.newKey);  <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> attr <span class="keyword">in</span> obj )&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(attr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>设置的特性总结</strong></p><ul><li><code>value</code>: 设置属性的值</li><li><code>writable</code>: 值是否可以重写。<code>true</code> | <code>false</code></li><li><code>enumerable</code>: 目标属性是否可以被枚举。<code>true</code> | <code>false</code></li><li><code>configurable</code>: 目标属性是否可以被删除或是否可以再次修改特性 <code>true</code> | <code>false</code></li></ul><h3 id="2-3-存取器描述"><a href="#2-3-存取器描述" class="headerlink" title="2.3 存取器描述"></a>2.3 存取器描述</h3><h4 id="2-3-1-定义"><a href="#2-3-1-定义" class="headerlink" title="2.3.1 定义"></a>2.3.1 定义</h4><blockquote><p>当使用存取器描述属性的特性的时候，允许设置以下特性属性</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">"newKey"</span>,&#123;</span><br><span class="line">    get:<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125; | <span class="literal">undefined</span>,</span><br><span class="line">    set:<span class="function"><span class="keyword">function</span> (<span class="params">value</span>)</span>&#123;&#125; | <span class="literal">undefined</span></span><br><span class="line">    configurable: <span class="literal">true</span> | <span class="literal">false</span></span><br><span class="line">    enumerable: <span class="literal">true</span> | <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>注意：当使用了<code>getter</code>或<code>setter</code>方法，不允许使用<code>writable</code>和<code>value</code>这两个属性</p></blockquote><h4 id="2-3-2-getter-setter"><a href="#2-3-2-getter-setter" class="headerlink" title="2.3.2 getter/setter"></a>2.3.2 getter/setter</h4><blockquote><p>当设置或获取对象的某个属性的值的时候，可以提供<code>getter/setter</code>方法。</p></blockquote><ul><li><code>getter</code> 是一种获得属性值的方法</li><li><code>setter</code>是一种设置属性值的方法</li></ul><blockquote><p>在特性中使用<code>get/set</code>属性来定义对应的方法</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> initValue = <span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">"newKey"</span>,&#123;</span><br><span class="line">    get:<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//当获取值的时候触发的函数</span></span><br><span class="line">        <span class="keyword">return</span> initValue;    </span><br><span class="line">    &#125;,</span><br><span class="line">    set:<span class="function"><span class="keyword">function</span> (<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//当设置值的时候触发的函数,设置的新值通过参数value拿到</span></span><br><span class="line">        initValue = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//获取值</span></span><br><span class="line"><span class="built_in">console</span>.log( obj.newKey );  <span class="comment">//hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置值</span></span><br><span class="line">obj.newKey = <span class="string">'change value'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( obj.newKey ); <span class="comment">//change value</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：get或set不是必须成对出现，任写其一就可以。如果不设置方法，则<code>get</code>和<code>set</code>的默认值为<code>undefined</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;来自网络&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;兼容性&lt;/strong&gt;&lt;/p
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="JavaScript" scheme="http://blog.poetries.top/tags/JavaScript/"/>
    
      <category term="Object.defineProperty" scheme="http://blog.poetries.top/tags/Object-defineProperty/"/>
    
  </entry>
  
  <entry>
    <title>Javascript中的复制粘贴功能</title>
    <link href="http://blog.poetries.top/2018/12/23/js-copy/"/>
    <id>http://blog.poetries.top/2018/12/23/js-copy/</id>
    <published>2018-12-23T01:10:43.000Z</published>
    <updated>2019-01-07T08:48:58.300Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>来源网络</p></blockquote><h2 id="一、基本使用"><a href="#一、基本使用" class="headerlink" title="一、基本使用"></a>一、基本使用</h2><h3 id="1-1-API-介绍"><a href="#1-1-API-介绍" class="headerlink" title="1.1 API 介绍"></a>1.1 API 介绍</h3><p><strong>复制、剪切、粘贴事件</strong></p><ul><li><code>copy</code> 发生复制操作时触发;</li><li><code>cut</code> 发生剪切操作时触发;</li><li><code>paste</code> 发生粘贴操作时触发</li></ul><blockquote><p>每个事件都有一个 <code>before</code> 事件对应：<code>beforecopy</code>、<code>beforecut</code>、<code>beforepaste</code>。这几个 <code>before</code> 一般不怎么用，所以我们把注意力放在另外三个事件就可以了</p></blockquote><p><strong>触发条件</strong></p><ul><li>鼠标右键菜单的<code>复制</code>、<code>粘贴</code>、<code>剪切</code></li><li>使用了相应的键盘组合键，比如:<code>command+c</code>、<code>command+v</code></li></ul><p><strong>使用姿势</strong></p><blockquote><p>以 <code>copy</code> 为例</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.oncopy = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 监听全局复制 做点什么</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 还有这种写法：</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'copy'</span>, e =&gt; &#123;</span><br><span class="line">  <span class="comment">// 监听全局复制 做点什么</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>上面是在<code>document.body</code>上全局监听的，然而很多人不知道的是，我们还可以为某些 <code>dom</code> 单独添加剪切板事件</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// html结构</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 写法一样：</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> test1 = <span class="built_in">document</span>.querySelector(<span class="string">'#test1'</span>);</span></span><br><span class="line"><span class="javascript">    test1.oncopy = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 监听test1发生的复制事件 做点什么</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// test1发生的复制事件会触发回调，其他地方不会触发回调</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>其他事件也是一样的</p></blockquote><h3 id="1-2-clipboardData"><a href="#1-2-clipboardData" class="headerlink" title="1.2 clipboardData"></a>1.2 clipboardData</h3><p><strong>clipboardData 对象:用于访问以及修改剪贴板中的数据</strong></p><blockquote><p>不同浏览器，所属的对象不同：在 <code>IE</code> 中这个对象是<code>window</code>对象的属性，在<code>Chrome</code>、<code>Safari</code>和<code>Firefox</code>中，这个对象是相应的<code>event</code>对象的属性。所以我们在使用的时候，需要做一下如下兼容</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.oncopy = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> clipboardData = e.clipboardData || <span class="built_in">window</span>.clipboardData;</span><br><span class="line">  <span class="comment">// 获取clipboardData对象 + do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>对象方法</strong></p><blockquote><p>对象有三个方法: <code>getData()</code>、<code>setData()</code>、<code>clearData()</code></p></blockquote><p><strong>getData() 访问剪切板中的数据</strong></p><blockquote><p><code>getData()</code>接受一个<code>text</code>参数，即要取得的数据的格式</p></blockquote><p><strong>在复制、剪切、粘贴触发的事件的数据</strong></p><blockquote><p>实际上在 <code>chorme</code> 上测试只有<code>paste</code>粘贴的时候才能用<code>getData()</code>访问到数据，用法如下</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要粘贴的数据：</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.onpaste = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> clipboardData = e.clipboardData || <span class="built_in">window</span>.clipboardData; <span class="comment">// 兼容处理</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'要粘贴的数据'</span>, clipboardData.getData(<span class="string">'text'</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>被复制/剪切的数据</strong>：</p><blockquote><p>在复制和剪切中的数据，需要通过<code>window.getSelection(0).toString()</code>来访问:</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.oncopy = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'被复制的数据:'</span>, <span class="built_in">window</span>.getSelection(<span class="number">0</span>).toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>setData(): 修改剪切板中的数据</strong></p><blockquote><p>第一个参数也是<code>text</code>，第二个参数是要放在剪切板中的文本</p></blockquote><p><strong>clearData()</strong></p><h2 id="二、应用"><a href="#二、应用" class="headerlink" title="二、应用"></a>二、应用</h2><h3 id="2-1-复制大段文本"><a href="#2-1-复制大段文本" class="headerlink" title="2.1 复制大段文本"></a>2.1 复制大段文本</h3><p><strong>实现类知乎/掘金复制大段文本添加版权信息</strong></p><blockquote><p>实现很简单：取消默认复制之后，主要是在被复制的内容后面添加信息，然后根据 <code>clipboardData</code> 的 <code>setData()</code>方法将信息写入剪贴板</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 掘金这里不是全局监听，应该只是监听文章的dom范围内。</span></span><br><span class="line"><span class="built_in">document</span>.body.oncopy = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  event.preventDefault(); <span class="comment">// 取消默认的复制事件</span></span><br><span class="line">  <span class="keyword">let</span> textFont,</span><br><span class="line">    copyFont = <span class="built_in">window</span>.getSelection(<span class="number">0</span>).toString(); <span class="comment">// 被复制的文字 等下插入</span></span><br><span class="line">  <span class="comment">// 防知乎掘金 复制一两个字则不添加版权信息 超过一定长度的文字 就添加版权信息</span></span><br><span class="line">  <span class="keyword">if</span> (copyFont.length &gt; <span class="number">10</span>) &#123;</span><br><span class="line">    textFont =</span><br><span class="line">      copyFont +</span><br><span class="line">      <span class="string">'\n'</span> +</span><br><span class="line">      <span class="string">'作者：OBKoro1\n'</span> +</span><br><span class="line">      <span class="string">'链接：https://juejin.im/user/58714f0e325b123db4a2eb95372/posts\n'</span> +</span><br><span class="line">      <span class="string">'来源：掘金\n'</span> +</span><br><span class="line">      <span class="string">'著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    textFont = copyFont; <span class="comment">// 没超过十个字 则采用被复制的内容。</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (event.clipboardData) &#123;</span><br><span class="line">    <span class="keyword">return</span> event.clipboardData.setData(<span class="string">'text'</span>, textFont); <span class="comment">// 将信息写入粘贴板</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 兼容IE</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">window</span>.clipboardData.setData(<span class="string">'text'</span>, textFont);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>然后 <code>command+c</code>、<code>command+v</code>，输出:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">你复制的内容</span><br><span class="line">作者：OBKoro1</span><br><span class="line">链接：https://juejin.im/user/58714f0eb123db4a2eb95372/posts</span><br><span class="line">来源：掘金</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h3 id="2-2-防复制功能"><a href="#2-2-防复制功能" class="headerlink" title="2.2 防复制功能"></a>2.2 防复制功能</h3><ul><li>禁止复制+剪切</li><li>禁止右键，右键某些选项:全选，复制，粘贴等。</li><li>禁用文字选择，能选择却不能复制，体验很差。</li><li><code>user-select</code> 用 <code>css</code> 禁止选择文本</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 禁止右键菜单</span></span><br><span class="line"><span class="built_in">document</span>.body.oncontextmenu = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e, <span class="string">'右键'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// e.preventDefault();</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 禁止文字选择。</span></span><br><span class="line"><span class="built_in">document</span>.body.onselectstart = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e, <span class="string">'文字选择'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// e.preventDefault();</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 禁止复制</span></span><br><span class="line"><span class="built_in">document</span>.body.oncopy = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e, <span class="string">'copy'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// e.preventDefault();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 禁止剪切</span></span><br><span class="line"><span class="built_in">document</span>.body.oncut = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e, <span class="string">'cut'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// e.preventDefault();</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 禁止粘贴</span></span><br><span class="line"><span class="built_in">document</span>.body.onpaste = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e, <span class="string">'paste'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// e.preventDefault();</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** css 禁止文本选择 这样不会触发js**/</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">user-select</span>: none;</span><br><span class="line">    <span class="attribute">-moz-user-select</span>: none;</span><br><span class="line">    <span class="attribute">-webkit-user-select</span>: none;</span><br><span class="line">    <span class="attribute">-ms-user-select</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用<code>e.preventDefault()</code>也可以禁用，但建议使用<code>return false</code>这样就不用去访问<code>e</code>和<code>e</code>的方法了。</li><li>示例中<code>document.body</code>全局都禁用了，也可以对 <code>dom</code>(某些区域)进行禁用</li></ul><p><strong>破解防复制</strong></p><p>上面的防复制方法通过<code>js+css</code>实现的，所以思路就是：禁用<code>js+取消user-select</code>样式。</p><blockquote><p><code>Chrome</code>浏览器的话：打开浏览器控制台，按<code>F1</code>进入<code>Setting</code>，勾选<code>Disable</code> <code>JavaScript</code>(禁止 <code>js</code>)。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-2f3188629fa5a86d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>此时如果还不能复制的话，就要去找<code>user-select</code>样式,取消这个样式就可以了</p></blockquote><h3 id="2-3-点击复制功能"><a href="#2-3-点击复制功能" class="headerlink" title="2.3 点击复制功能"></a>2.3 点击复制功能</h3><p><strong>不能使用 clipboardData</strong></p><ul><li>在 <code>IE</code> 中可以用<code>window.clipboardData.setData(&#39;text&#39;,&#39;内容&#39;)</code>实现</li><li>上文提到过，在 <code>IE</code> 中<code>clipboardData</code>是<code>window</code>的属性</li><li>而其他浏览器则是相应的<code>event</code>对象的属性，这实际上是一种安全措施，防止未经授权的访问,为了兼容其他浏览器，所以我们不能通过<code>clipboardData</code>来实现这种操作</li></ul><p><strong>具体做法</strong></p><ul><li>创建一个隐藏的<code>input</code>框</li><li>点击的时候，将要复制的内容放进<code>input</code>框中</li><li>选择文本内容<code>input.select()</code>。这里只能用<code>input</code>或者<code>textarea</code>才能选择文本</li><li><code>document.execCommand(&quot;copy&quot;)</code>，执行浏览器的复制命令</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyText</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> text = <span class="built_in">document</span>.getElementById(<span class="string">'text'</span>).innerText; <span class="comment">// 获取要复制的内容也可以传进来</span></span><br><span class="line">  <span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span>); <span class="comment">// 获取隐藏input的dom</span></span><br><span class="line">  input.value = text; <span class="comment">// 修改文本框的内容</span></span><br><span class="line">  input.select(); <span class="comment">// 选中文本</span></span><br><span class="line">  <span class="built_in">document</span>.execCommand(<span class="string">'copy'</span>); <span class="comment">// 执行浏览器复制命令</span></span><br><span class="line">  alert(<span class="string">'复制成功'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-第三方库clipboard"><a href="#2-4-第三方库clipboard" class="headerlink" title="2.4 第三方库clipboard"></a>2.4 第三方库clipboard</h3><blockquote><p><a href="https://github.com/zenorocha/clipboard.js" target="_blank" rel="noopener">https://github.com/zenorocha/clipboard.js</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;来源网络&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、基本使用&quot;&gt;&lt;a href=&quot;#一、基本使用&quot; class=&quot;headerlink&quot; title=&quot;一、基本使用&quot;&gt;&lt;/a&gt;一、基本使用&lt;/h2&gt;&lt;h3 id=&quot;1-1-API-介绍
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="JavaScript" scheme="http://blog.poetries.top/tags/JavaScript/"/>
    
      <category term="复制粘贴" scheme="http://blog.poetries.top/tags/%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript原型链回顾</title>
    <link href="http://blog.poetries.top/2018/12/22/js-prototype-review/"/>
    <id>http://blog.poetries.top/2018/12/22/js-prototype-review/</id>
    <published>2018-12-22T04:13:53.000Z</published>
    <updated>2019-01-07T08:48:58.304Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、JS内置对象"><a href="#一、JS内置对象" class="headerlink" title="一、JS内置对象"></a>一、JS内置对象</h2><blockquote><p>所谓的内置对象 指的是：<code>JavaScript</code>本身就自己有的对象 可以直接拿来就用。例如<code>Array</code> <code>String</code> 等等。<code>JavaScript</code>一共有12内置对象</p></blockquote><p><strong>函数类型(10个)</strong></p><ul><li><code>String</code></li><li><code>Number</code></li><li><code>Boolean</code></li><li><code>Array</code></li><li><code>Function</code></li><li><code>Date</code></li><li><code>RegExp</code></li><li><code>Error</code></li><li><code>Object</code></li><li><code>Event</code></li></ul><blockquote><p>函数类型 有 <code>__proto__</code>和 <code>prototype</code> 属性</p></blockquote><p><strong>对象类型(2个)</strong></p><ul><li><code>Math</code></li><li><code>JSON</code></li></ul><blockquote><p>对象类型只有<code>__proto__</code>属性</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-9b6c5ca4a84f967c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="二、JS原型链"><a href="#二、JS原型链" class="headerlink" title="二、JS原型链"></a>二、JS原型链</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p><img src="https://upload-images.jianshu.io/upload_images/1480597-86427eafb257f868.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>每个函数都有 <code>prototype</code> 属性，除了 <code>Function.prototype.bind()</code>，该属性指向原型。</li><li>每个对象都有 <code>__proto__</code> 属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 <code>[[prototype]]</code>，但是 <code>[[prototype]]</code> 是内部属性，我们并不能访问到，所以使用 <code>__proto__</code> 来访问</li><li>对象可以通过 <strong>proto</strong> 来寻找不属于该对象的属性，<code>__proto__</code> 将对象连接起来组成了原型链</li></ul><blockquote><p>打开浏览器的控制面板，随便输入一个<code>JS</code>内置的构造器函数，比如<code>Array</code>，控制台输出的是一个名为<code>Array</code>的函数体，这好像并没有什么稀奇的，但是，当你接着输入<code>Array.prototype</code>，控制面板输出了一堆我们经常用到的<code>Array</code>构造器的方法，把目光转移到最下方，有一个叫<code>__proto__</code>的属性，好奇的点开。列表列出的不是<code>Object</code>构造器的方法么，里边有我们非常熟悉的<code>hasOwnProperty</code>还有<code>toString</code>等方法。如果<code>Array</code>是构造器，那么控制面板输出的<code>Array.prototype</code>的所有属性中<code>constructor</code>又是什么构造器？点开看看，之后就像身处德罗斯特效应中一样，<code>__proto__</code>和<code>constructor</code>，还有<code>Array</code>构造器中常用的方法名不断的出现，一层套一层，一层层展开，没有尽头</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-33dcb28a487a5b1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>拿<code>Array</code>举例，<code>Array.prototype</code>中有一个<code>constructor</code>属性，这个属性的值就是<code>Array</code>构造器自己</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.constructor === Array //true</span><br></pre></td></tr></table></figure><h3 id="2-2-prototype"><a href="#2-2-prototype" class="headerlink" title="2.2 prototype"></a>2.2 prototype</h3><blockquote><p>这是一个显式原型属性，只有函数才拥有该属性。基本上所有函数都有这个属性，但是也有一个例外</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fun = <span class="built_in">Function</span>.prototype.bind()</span><br></pre></td></tr></table></figure><blockquote><p>如果你以上述方法创建一个函数，那么可以发现这个函数是不具有 <code>prototype</code> 属性的</p></blockquote><h4 id="2-2-1-prototype-如何产生的"><a href="#2-2-1-prototype-如何产生的" class="headerlink" title="2.2.1 prototype 如何产生的"></a>2.2.1 prototype 如何产生的</h4><blockquote><p>当我们声明一个函数时，这个属性就被自动创建了</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>并且这个属性的值是一个对象（也就是原型），只有一个属性 <code>constructor</code></p></blockquote><ul><li><code>constructor</code> 对应着构造函数，也就是 <code>Foo</code></li></ul><h4 id="2-2-2-constructor"><a href="#2-2-2-constructor" class="headerlink" title="2.2.2 constructor"></a>2.2.2 constructor</h4><blockquote><p><code>constructor</code>是一个公有且不可枚举的属性。一旦我们改变了函数的 <code>prototype</code> ，那么新对象就没有这个属性了（当然可以通过原型链取到 <code>constructor</code>）</p></blockquote><p>那么你肯定也有一个疑问，这个属性到底有什么用呢？其实这个属性可以说是一个历史遗留问题，在大部分情况下是没用的，在我的理解里，我认为他有两个作用：</p><ul><li>让实例对象知道是什么函数构造了它</li><li>如果想给某些类库中的构造函数增加一些自定义的方法，就可以通过 <code>xx.constructor.method</code> 来扩展</li></ul><h3 id="2-3-proto"><a href="#2-3-proto" class="headerlink" title="2.3 __proto__"></a>2.3 <code>__proto__</code></h3><blockquote><p>这是每个对象都有的隐式原型属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 <code>[[prototype]]</code>，但是 <code>[[prototype]]</code> 是内部属性，我们并不能访问到，所以使用 <code>__proto__</code> 来访问</p></blockquote><ul><li>因为在 <code>JS</code> 中是没有类的概念的，为了实现类似继承的方式，通过 <code>__proto__</code> 将对象和原型联系起来组成原型链，得以让对象可以访问到不属于自己的属性</li></ul><h4 id="2-3-1-实例对象的-proto-如何产生的"><a href="#2-3-1-实例对象的-proto-如何产生的" class="headerlink" title="2.3.1 实例对象的 _proto_ 如何产生的"></a>2.3.1 实例对象的 <code>_proto_</code> 如何产生的</h4><blockquote><p>当我们使用 <code>new</code> 操作符时，生成的实例对象拥有了 <code>__proto__</code>属性</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 这个函数是 Function 的实例对象</span></span><br><span class="line"><span class="comment">// function 就是一个语法糖</span></span><br><span class="line"><span class="comment">// 内部调用了 new Function(...)</span></span><br></pre></td></tr></table></figure><blockquote><p>所以可以说，在 <code>new</code> 的过程中，新对象被添加了 <code>__proto__</code> 并且链接到构造函数的原型上</p></blockquote><h4 id="2-3-2-new-的过程"><a href="#2-3-2-new-的过程" class="headerlink" title="2.3.2 new 的过程"></a>2.3.2 new 的过程</h4><ul><li>新生成了一个对象</li><li>链接到原型</li><li>绑定 <code>this</code></li><li>返回新对象</li></ul><blockquote><p>在调用 <code>new</code> 的过程中会发生以上四件事情，我们也可以试着来自己实现一个 <code>new</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的对象</span></span><br><span class="line">    <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    <span class="comment">// 获得构造函数</span></span><br><span class="line">    <span class="keyword">let</span> Con = [].shift.call(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="comment">// 链接到原型</span></span><br><span class="line">obj.__proto__ = Con.prototype</span><br><span class="line">    <span class="comment">// 绑定 this，执行构造函数</span></span><br><span class="line">    <span class="keyword">let</span> result = Con.apply(obj, <span class="built_in">arguments</span>)</span><br><span class="line">    <span class="comment">// 确保 new 出来的是个对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">'object'</span> ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于实例对象来说，都是通过 <code>new</code> 产生的，无论是 <code>function Foo()</code> 还是 <code>let a = { b : 1 }</code></li><li>对于创建一个对象来说，更推荐使用字面量的方式创建对象。因为你使用 <code>new Object()</code>的方式创建对象需要通过作用域链一层层找到 <code>Object</code>，但是你使用字面量的方式就没这个问题。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function 就是个语法糖</span></span><br><span class="line"><span class="comment">// 内部等同于 new Function()</span></span><br><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="comment">// 这个字面量内部也是使用了 new Object()</span></span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1480597-e4a91031a78eb153.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>这里<code>Array</code> 内置对象 且是函数类型。所以<code>Array</code>有<code>__proto__</code>属性 指向的是函数类型 <code>(function（）{})</code>。所以当我们在输出<code>Array.__proto__.proto__</code>;就会返回对象类型<code>(Object{})</code>.但是再向上就<code>null</code>。因为<code>Object</code>就是父类了。所有的继承自<code>Object</code>。</p></blockquote><ul><li><code>JS</code>内置构造器其中之一的<code>Array</code>原本就是一个函数，而这个函数就是<code>Function</code>的<code>prototype</code>，所以<code>Function.prototype</code>有的方法，<code>JS</code>内置构造器都有，比如<code>call()</code>、<code>apply()</code>、<code>bind()</code>等（其实我们自定义的函数也是继承自<code>Function.prototype</code>，所以我们自己也可以定义构造器）。而<code>Function.prototype</code>的进化链指针又指向了<code>Object.prototype</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组实例的__proto__指向构造器的原型</span></span><br><span class="line"></span><br><span class="line">[].__proto__ === <span class="built_in">Array</span>.prototype</span><br></pre></td></tr></table></figure><h3 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h3><ul><li><code>Object</code> 是所有对象的爸爸，所有对象都可以通过 <code>__proto__</code> 找到它</li><li><code>Function</code> 是所有函数的爸爸，所有函数都可以通过 <code>__proto__</code> 找到它</li><li><code>Function.prototype</code> 和 <code>Object.prototype</code> 是两个特殊的对象，他们由引擎来创建</li><li>除了以上两个特殊对象，其他对象都是通过构造器 <code>new</code> 出来的</li><li>函数的 <code>prototype</code> 是一个对象，也就是原型</li><li>对象的 <code>__proto__</code> 指向原型， <code>__proto__</code>将对象和原型连接起来组成了原型链</li></ul><p><strong>关于原型有3个相关的概</strong>念:</p><ul><li>函数对象的<code>prototype</code>属性, 可以称之为显式原型属性(简称: 显式原型)</li><li>实例对象的<code>__proto__</code>属性, 可以称之为隐式原型属性(简称: 隐式原型)</li><li>原型对象: 也就是<code>prototype</code>属性和<code>_proto__</code>属性指向的对象</li></ul><p><img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype5.png" alt=""></p><blockquote><p>图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线</p></blockquote><h2 id="三、JSON和Math"><a href="#三、JSON和Math" class="headerlink" title="三、JSON和Math"></a>三、JSON和Math</h2><blockquote><p><code>JS</code>内置的构造器函数都可以使用<code>new</code>关键字实例化一个对象，我们称实例化后的这个对象就是某某构造器的一个实例</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-ae2f194cbd110416.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>我们试试<code>JSON</code> 和<code>Math</code> 能不能实例化对象</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-1514936d90349c18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p><code>JSON</code>和<code>Math</code>不是构造器函数，他们是普通的对象。只有构造器函数才能使用<code>new</code>关键字实例化一个对象，而<code>JSON</code>和<code>Math</code>已经是对象了，所以我们可以不用实例化直接使用<code>JSON</code>和<code>Math</code>中的属性和方法</p></blockquote><ul><li>所以<code>JSON</code>和<code>Math</code>不属于<code>10</code>个构造器函数，但他们<code>12</code>个共同属于<code>Javascript</code>的内置对象</li></ul><h2 id="四、更多参考"><a href="#四、更多参考" class="headerlink" title="四、更多参考"></a>四、更多参考</h2><ul><li><a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="noopener">JavaScript深入之从原型到原型链</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、JS内置对象&quot;&gt;&lt;a href=&quot;#一、JS内置对象&quot; class=&quot;headerlink&quot; title=&quot;一、JS内置对象&quot;&gt;&lt;/a&gt;一、JS内置对象&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;所谓的内置对象 指的是：&lt;code&gt;JavaScript&lt;/cod
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="JavaScript" scheme="http://blog.poetries.top/tags/JavaScript/"/>
    
      <category term="原型链" scheme="http://blog.poetries.top/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>浏览器渲染原理</title>
    <link href="http://blog.poetries.top/2018/12/22/browser-render/"/>
    <id>http://blog.poetries.top/2018/12/22/browser-render/</id>
    <published>2018-12-22T02:20:43.000Z</published>
    <updated>2019-01-07T08:48:58.280Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、浏览器如何渲染网页"><a href="#一、浏览器如何渲染网页" class="headerlink" title="一、浏览器如何渲染网页"></a>一、浏览器如何渲染网页</h2><p><strong>概述：浏览器渲染一共有五步</strong></p><ol><li>处理 <code>HTML</code> 并构建 <code>DOM</code> 树。</li><li>处理 <code>CSS</code>构建 <code>CSSOM</code> 树。</li><li>将 <code>DOM</code> 与 <code>CSSOM</code> 合并成一个渲染树。</li><li>根据渲染树来布局，计算每个节点的位置。</li><li>调用 <code>GPU</code> 绘制，合成图层，显示在屏幕上</li></ol><blockquote><p>第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染</p></blockquote><p>具体如下图过程如下图所示</p><p><img src="https://upload-images.jianshu.io/upload_images/1480597-08e6f204c42595ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/1480597-365009d6fa2d4b77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>渲染</strong></p><ul><li>网页生成的时候，至少会渲染一次</li><li>在用户访问的过程中，还会不断重新渲染</li></ul><blockquote><p>重新渲染需要重复之前的第四步(重新生成布局)+第五步(重新绘制)或者只有第五个步(重新绘制)</p></blockquote><ul><li>在构建 <code>CSSOM</code> 树时，会阻塞渲染，直至 <code>CSSOM</code>树构建完成。并且构建 <code>CSSOM</code> 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 <code>CSS</code> 选择器，执行速度越慢</li><li>当 <code>HTML</code> 解析到 <code>script</code> 标签时，会暂停构建 <code>DOM</code>，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 <code>JS</code> 文件。并且<code>CSS</code>也会影响 <code>JS</code> 的执行，只有当解析完样式表才会执行 <code>JS</code>，所以也可以认为这种情况下，<code>CSS</code> 也会暂停构建 <code>DOM</code></li></ul><h2 id="二、浏览器渲染五个阶段"><a href="#二、浏览器渲染五个阶段" class="headerlink" title="二、浏览器渲染五个阶段"></a>二、浏览器渲染五个阶段</h2><h3 id="2-1-第一步：解析HTML标签，构建DOM树"><a href="#2-1-第一步：解析HTML标签，构建DOM树" class="headerlink" title="2.1 第一步：解析HTML标签，构建DOM树"></a>2.1 第一步：解析HTML标签，构建DOM树</h3><blockquote><p>在这个阶段，引擎开始解析<code>html</code>，解析出来的结果会成为一棵<code>dom</code>树<br><code>dom</code>的目的至少有<code>2</code>个</p></blockquote><ul><li>作为下个阶段渲染树状图的输入</li><li>成为网页和脚本的交互界面。(最常用的就是<code>getElementById</code>等等)</li></ul><p><strong>当解析器到达script标签的时候，发生下面四件事情</strong></p><ol><li><code>html</code>解析器停止解析,</li><li>如果是外部脚本，就从外部网络获取脚本代码</li><li>将控制权交给<code>js</code>引擎，执行<code>js</code>代码</li><li>恢复<code>html</code>解析器的控制权</li></ol><blockquote><p>由此可以得到第一个结论1</p></blockquote><ul><li>由于<code>&lt;script&gt;</code>标签是阻塞解析的，将脚本放在网页尾部会加速代码渲染。</li><li><code>defer</code>和<code>async</code>属性也能有助于加载外部脚本。</li><li><code>defer</code>使得脚本会在<code>dom</code>完整构建之后执行；</li><li><code>async</code>标签使得脚本只有在完全<code>available</code>才执行，并且是以非阻塞的方式进行的</li></ul><h3 id="2-2-第二步：解析CSS标签，构建CSSOM树"><a href="#2-2-第二步：解析CSS标签，构建CSSOM树" class="headerlink" title="2.2 第二步：解析CSS标签，构建CSSOM树"></a>2.2 第二步：解析CSS标签，构建CSSOM树</h3><ul><li>我们已经看到<code>html</code>解析器碰到脚本后会做的事情，接下来我们看下<code>html</code>解析器碰到样式表会发生的情况</li><li><code>js</code>会阻塞解析，因为它会修改文档(<code>document</code>)。<code>css</code>不会修改文档的结构，如果这样的话，似乎看起来<code>css</code>样式不会阻塞浏览器<code>html</code>解析。但是事实上 <code>css</code>样式表是阻塞的。阻塞是指当<code>cssom</code>树建立好之后才会进行下一步的解析渲染</li></ul><p><strong>通过以下手段可以减轻cssom带来的影响</strong></p><ul><li>将<code>script</code>脚本放在页面底部</li><li>尽可能快的加载<code>css</code>样式表</li><li>将样式表按照<code>media type</code>和<code>media query</code>区分，这样有助于我们将<code>css</code>资源标记成非阻塞渲染的资源。</li><li>非阻塞的资源还是会被浏览器下载，只是优先级较低</li></ul><h3 id="2-3-第三步：把DOM和CSSOM组合成渲染树（render-tree）"><a href="#2-3-第三步：把DOM和CSSOM组合成渲染树（render-tree）" class="headerlink" title="2.3 第三步：把DOM和CSSOM组合成渲染树（render tree）"></a>2.3 第三步：把DOM和CSSOM组合成渲染树（render tree）</h3><p><img src="https://upload-images.jianshu.io/upload_images/1480597-c0d854c01697ceda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="2-4-第四步：在渲染树的基础上进行布局，计算每个节点的几何结构"><a href="#2-4-第四步：在渲染树的基础上进行布局，计算每个节点的几何结构" class="headerlink" title="2.4 第四步：在渲染树的基础上进行布局，计算每个节点的几何结构"></a>2.4 第四步：在渲染树的基础上进行布局，计算每个节点的几何结构</h3><blockquote><p>布局(<code>layout</code>)：定位坐标和大小，是否换行，各种<code>position</code>, <code>overflow</code>, <code>z-index</code>属性</p></blockquote><h3 id="2-5-调用-GPU-绘制，合成图层，显示在屏幕上"><a href="#2-5-调用-GPU-绘制，合成图层，显示在屏幕上" class="headerlink" title="2.5 调用 GPU 绘制，合成图层，显示在屏幕上"></a>2.5 调用 GPU 绘制，合成图层，显示在屏幕上</h3><blockquote><p>将渲染树的各个节点绘制到屏幕上，这一步被称为绘制<code>painting</code></p></blockquote><h2 id="三、渲染优化相关"><a href="#三、渲染优化相关" class="headerlink" title="三、渲染优化相关"></a>三、渲染优化相关</h2><h3 id="3-1-Load-和-DOMContentLoaded-区别"><a href="#3-1-Load-和-DOMContentLoaded-区别" class="headerlink" title="3.1 Load 和 DOMContentLoaded 区别"></a>3.1 Load 和 DOMContentLoaded 区别</h3><ul><li><code>Load</code> 事件触发代表页面中的 <code>DOM</code>，<code>CSS</code>，<code>JS</code>，图片已经全部加载完毕。</li><li><code>DOMContentLoaded</code> 事件触发代表初始的 <code>HTML</code> 被完全加载和解析，不需要等待 <code>CSS</code>，<code>JS</code>，图片加载</li></ul><h3 id="3-2-图层"><a href="#3-2-图层" class="headerlink" title="3.2 图层"></a>3.2 图层</h3><blockquote><p>一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用。</p></blockquote><p><strong>通过以下几个常用属性可以生成新图层</strong></p><ul><li><code>3D</code> 变换：<code>translate3d</code>、<code>translateZ</code></li><li><code>will-change</code></li><li><code>video</code>、<code>iframe</code> 标签</li><li>通过动画实现的 <code>opacity</code> 动画转换</li><li><code>position: fixed</code></li></ul><h3 id="3-3-重绘（Repaint）和回流（Reflow）"><a href="#3-3-重绘（Repaint）和回流（Reflow）" class="headerlink" title="3.3 重绘（Repaint）和回流（Reflow）"></a>3.3 重绘（Repaint）和回流（Reflow）</h3><blockquote><p>重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大</p></blockquote><ul><li>重绘是当节点需要更改外观而不会影响布局的，比如改变 <code>color</code> 就叫称为重绘</li><li>回流是布局或者几何属性需要改变就称为回流。</li></ul><blockquote><p>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流</p></blockquote><p><strong>以下几个动作可能会导致性能问题</strong></p><ul><li>改变 <code>window</code> 大小</li><li>改变字体</li><li>添加或删除样式</li><li>文字改变</li><li>定位或者浮动</li><li>盒模型</li></ul><p><strong>很多人不知道的是，重绘和回流其实和 Event loop 有关</strong></p><ul><li>当 <code>Event loop</code> 执行完<code>Microtasks</code> 后，会判断 <code>document</code> 是否需要更新。因为浏览器是 <code>60Hz</code> 的刷新率，每 <code>16ms</code> 才会更新一次。</li><li>然后判断是否有 <code>resize</code> 或者 <code>scroll</code> ，有的话会去触发事件，所以 <code>resize</code> 和 <code>scroll</code> 事件也是至少 <code>16ms</code>才会触发一次，并且自带节流功能。</li><li>判断是否触发了 <code>media query</code></li><li>更新动画并且发送事件</li><li>判断是否有全屏操作事件</li><li>执行 <code>requestAnimationFrame</code> 回调</li><li>执行 <code>IntersectionObserver</code> 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好</li><li>更新界面</li><li>以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 <code>requestIdleCallback</code> 回调</li></ul><p><strong>常见的引起重绘的属性</strong></p><ul><li><code>color</code></li><li><code>border-style</code>    </li><li><code>visibility</code>    </li><li><code>background</code></li><li><code>text-decoration</code>    </li><li><code>background-image</code>    </li><li><code>background-position</code>    </li><li><code>background-repeat</code></li><li><code>outline-color</code>    </li><li><code>outline</code>    </li><li><code>outline-style</code>    </li><li><code>border-radius</code></li><li><code>outline-width</code>    </li><li><code>box-shadow</code>    </li><li><code>background-size</code>    </li></ul><h3 id="3-4-常见引起回流属性和方法"><a href="#3-4-常见引起回流属性和方法" class="headerlink" title="3.4 常见引起回流属性和方法"></a>3.4 常见引起回流属性和方法</h3><blockquote><p>任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发重排，下面列一些栗子</p></blockquote><ul><li>添加或者删除可见的<code>DOM</code>元素；</li><li>元素尺寸改变——边距、填充、边框、宽度和高度</li><li>内容变化，比如用户在<code>input</code>框中输入文字</li><li>浏览器窗口尺寸改变——<code>resize</code>事件发生时</li><li>计算 <code>offsetWidth</code> 和 <code>offsetHeight</code> 属性</li><li>设置 <code>style</code> 属性的值</li></ul><p><strong>回流影响的范围</strong></p><blockquote><p>由于浏览器渲染界面是基于流失布局模型的，所以触发重排时会对周围DOM重新排列，影响的范围有两种</p></blockquote><ul><li>全局范围：从根节点<code>html</code>开始对整个渲染树进行重新布局。</li><li>局部范围：对渲染树的某部分或某一个渲染对象进行重新布局</li></ul><p><strong>全局范围回流</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hello"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>Name:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>BDing<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h5</span>&gt;</span>male<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>coding<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>loving<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>当<code>p</code>节点上发生<code>reflow</code>时，<code>hello</code>和<code>body</code>也会重新渲染，甚至<code>h5</code>和<code>ol</code>都会收到影响</p></blockquote><p><strong>局部范围回流</strong></p><blockquote><p>用局部布局来解释这种现象：把一个<code>dom</code>的宽高之类的几何信息定死，然后在<code>dom</code>内部触发重排，就只会重新渲染该<code>dom</code>内部的元素，而不会影响到外界</p></blockquote><h3 id="3-5-减少重绘和回流"><a href="#3-5-减少重绘和回流" class="headerlink" title="3.5 减少重绘和回流"></a>3.5 减少重绘和回流</h3><blockquote><p>使用 <code>translate</code> 替代 <code>top</code></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.test</span> &#123;</span></span><br><span class="line"><span class="undefined">        position: absolute;</span></span><br><span class="line"><span class="undefined">        top: 10px;</span></span><br><span class="line"><span class="undefined">        width: 100px;</span></span><br><span class="line"><span class="undefined">        height: 100px;</span></span><br><span class="line"><span class="undefined">        background: red;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 引起回流</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.querySelector(<span class="string">'.test'</span>).style.top = <span class="string">'100px'</span></span></span><br><span class="line"><span class="undefined">    &#125;, 1000)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>使用 <code>visibility</code> 替换 <code>display: none</code> ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li><li>把 <code>DOM</code> 离线后修改，比如：先把 <code>DOM</code> 给 <code>display:none</code> (有一次 <code>Reflow)</code>，然后你修改<code>100</code>次，然后再把它显示出来</li><li>不要把 <code>DOM</code> 结点的属性值放在一个循环里当成循环里的变量</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 获取 offsetTop 会导致回流，因为需要去获取正确的值</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">'.test'</span>).style.offsetTop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不要使用 <code>table</code> 布局，可能很小的一个小改动会造成整个 <code>table</code> 的重新布局</li><li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 <code>requestAnimationFrame</code></li><li><code>CSS</code>选择符从右往左匹配查找，避免 <code>DOM</code>深度过深</li><li>将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 <code>video</code>标签，浏览器会自动将该节点变为图层。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1480597-7820ddaab0b9710e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p><a href="http://blog.poetries.top/2018/01/12/fed-performance-optimization/#%E5%85%AD%E3%80%81%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81">重绘与回流</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、浏览器如何渲染网页&quot;&gt;&lt;a href=&quot;#一、浏览器如何渲染网页&quot; class=&quot;headerlink&quot; title=&quot;一、浏览器如何渲染网页&quot;&gt;&lt;/a&gt;一、浏览器如何渲染网页&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;概述：浏览器渲染一共有五步&lt;/strong&gt;&lt;/p&gt;
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="JavaScript" scheme="http://blog.poetries.top/tags/JavaScript/"/>
    
      <category term="浏览器渲染" scheme="http://blog.poetries.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript运行机制Event Loop</title>
    <link href="http://blog.poetries.top/2018/12/21/js-event-loop/"/>
    <id>http://blog.poetries.top/2018/12/21/js-event-loop/</id>
    <published>2018-12-21T15:20:54.000Z</published>
    <updated>2019-01-07T08:48:58.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、JavaScript是单线程"><a href="#一、JavaScript是单线程" class="headerlink" title="一、JavaScript是单线程"></a>一、JavaScript是单线程</h2><ul><li><code>JavaScript</code>语言的一大特点就是单线程，也就是说，同一个时间只能做一件事</li><li>假定<code>JavaScript</code>同时有两个线程，一个线程在某个<code>DOM</code>节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</li><li>所以，为了避免复杂性，从一诞生，<code>JavaScript</code>就是单线程，这已经成了这门语言的核心特征，将来也不会改变</li><li>为了利用多核<code>CPU</code>的计算能力，<code>HTML5</code>提出<code>Web Worker</code>标准，允许<code>JavaScript</code>脚本创建多个线程，但是子线程完全受主线程控制，且不得操作<code>DOM</code>。所以，这个新标准并没有改变<code>JavaScript</code>单线程的本质。</li></ul><h2 id="二、任务队列"><a href="#二、任务队列" class="headerlink" title="二、任务队列"></a>二、任务队列</h2><ul><li>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着</li><li>如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行</li></ul><blockquote><p>所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）</p></blockquote><ul><li>同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务</li><li>异步任务指的是，不进入主线程、而进入”任务队列”（<code>task queue</code>）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行</li></ul><p><strong>异步执行的运行机制</strong></p><ul><li>所有同步任务都在主线程上执行，形成一个执行栈</li><li>主线程之外，还存在一个”任务队列”（<code>task queue</code>）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件</li><li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行</li><li>主线程不断重复上面的第三步</li></ul><p>主线程和任务队列的示意图</p><p><img src="https://upload-images.jianshu.io/upload_images/1480597-bd9b065237a09d55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>只要主线程空了，就会去读取”任务队列”，这就是<code>JavaScript</code>的运行机制。这个过程会不断重复</p></blockquote><h2 id="三、事件和回调函数"><a href="#三、事件和回调函数" class="headerlink" title="三、事件和回调函数"></a>三、事件和回调函数</h2><ul><li>“任务队列”是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。</li><li>“任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。</li><li>所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。</li><li>“任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。</li></ul><h2 id="四、JS中的event-loop"><a href="#四、JS中的event-loop" class="headerlink" title="四、JS中的event loop"></a>四、JS中的event loop</h2><h3 id="4-1-原理分析"><a href="#4-1-原理分析" class="headerlink" title="4.1 原理分析"></a>4.1 原理分析</h3><blockquote><p>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-ca5b7ba49448a750.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在”任务队列”中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取”任务队列”，依次执行那些事件所对应的回调函数</p></blockquote><ul><li><code>JS</code> 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 <code>Task</code>（有多种 <code>task</code>） 队列中。一旦执行栈为空，<code>Event Loop</code> 就会从 <code>Task</code> 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>不同的任务源会被分配到不同的 <code>Task</code> 队列中，任务源可以分为 微任务（<code>microtask</code>） 和 宏任务（<code>macrotask</code>）。在 <code>ES6</code> 规范中，<code>microtask</code>称为 <code>jobs</code>，<code>macrotask</code> 称为 <code>task</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise'</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line"><span class="comment">// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout</span></span><br></pre></td></tr></table></figure><blockquote><p>以上代码虽然 <code>setTimeout</code>写在 <code>Promise</code> 之前，但是因为 <code>Promise</code>属于微任务而 <code>setTimeout</code> 属于宏任务</p></blockquote><h3 id="4-2-微任务"><a href="#4-2-微任务" class="headerlink" title="4.2 微任务"></a>4.2 微任务</h3><ul><li><code>process.nextTick</code></li><li><code>promise</code></li><li><code>Object.observe</code></li><li><code>MutationObserver</code></li></ul><h3 id="4-3-宏任务"><a href="#4-3-宏任务" class="headerlink" title="4.3 宏任务"></a>4.3 宏任务</h3><ul><li><code>script</code></li><li><code>setTimeout</code></li><li><code>setInterval</code></li><li><code>setImmediate</code></li><li><code>I/O</code></li><li><code>UI rendering</code></li></ul><blockquote><p>宏任务中包括了 <code>script</code> ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务</p></blockquote><h3 id="4-4-正确的Event-loop-顺序"><a href="#4-4-正确的Event-loop-顺序" class="headerlink" title="4.4 正确的Event loop 顺序"></a>4.4 正确的Event loop 顺序</h3><ul><li>执行同步代码，这属于宏任务</li><li>执行栈为空，查询是否有微任务需要执行</li><li>执行所有微任务</li><li>必要的话渲染 <code>UI</code></li><li>然后开始下一轮 <code>Event loop</code>，执行宏任务中的异步代码</li></ul><blockquote><p>通过上述的 <code>Event loop</code> 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 <code>DOM</code> 的话，为了更快的响应界面响应，我们可以把操作 <code>DOM</code> 放入微任务中</p></blockquote><h2 id="五、Node-中的-Event-loop"><a href="#五、Node-中的-Event-loop" class="headerlink" title="五、Node 中的 Event loop"></a>五、Node 中的 Event loop</h2><ul><li><code>Node.js</code>也是单线程的<code>Event Loop</code>，但是它的运行机制不同于浏览器环境</li><li><code>Node</code> 的 <code>Event loop</code> 分为<code>6</code>个阶段，它们会按照顺序反复运行</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1480597-56985351e0645f57.png" alt="image.png"></p><h3 id="5-1-Node-js的运行机制"><a href="#5-1-Node-js的运行机制" class="headerlink" title="5.1 Node.js的运行机制"></a>5.1 Node.js的运行机制</h3><ul><li><code>V8</code>引擎解析<code>JavaScript</code>脚本</li><li>解析后的代码，调用<code>Node API</code></li><li><code>libuv</code>库负责<code>Node API</code>的执行。它将不同的任务分配给不同的线程，形成一个<code>Event Loop</code>（事件循环），以异步的方式将任务的执行结果返回给V8引擎</li><li><code>V8</code>引擎再将结果返回给用户</li></ul><blockquote><p>除了<code>setTimeout</code>和<code>setInterval</code>这两个方法，<code>Node.js</code>还提供了另外两个与”任务队列”有关的方法：<code>process.nextTick</code>和s<code>etImmediate</code>。它们可以帮助我们加深对”任务队列”的理解</p></blockquote><h3 id="5-2-各个阶段"><a href="#5-2-各个阶段" class="headerlink" title="5.2 各个阶段"></a>5.2 各个阶段</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;──connections───     │</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure><h4 id="5-2-1-timer"><a href="#5-2-1-timer" class="headerlink" title="5.2.1 timer"></a>5.2.1 timer</h4><ul><li><code>timers</code> 阶段会执行 <code>setTimeout</code> 和 <code>setInterval</code></li><li>一个 <code>timer</code> 指定的时间并不是准确时间，而是在达到这个时间后尽快执行回调，可能会因为系统正在执行别的事务而延迟</li><li>下限的时间有一个范围：<code>[1, 2147483647]</code> ，如果设定的时间不在这个范围，将被设置为<code>1</code>。</li></ul><h4 id="5-2-2-I-O"><a href="#5-2-2-I-O" class="headerlink" title="5.2.2 I/O"></a>5.2.2 I/O</h4><blockquote><p><code>I/O</code> 阶段会执行除了 <code>close</code> 事件，定时器和 <code>setImmediate</code> 的回调</p></blockquote><h4 id="5-2-3-idle-prepare"><a href="#5-2-3-idle-prepare" class="headerlink" title="5.2.3 idle, prepare"></a>5.2.3 idle, prepare</h4><blockquote><p><code>idle</code>, <code>prepare</code> 阶段内部实现</p></blockquote><h4 id="5-2-4-poll"><a href="#5-2-4-poll" class="headerlink" title="5.2.4 poll"></a>5.2.4 poll</h4><blockquote><p><code>poll</code> 阶段很重要，这一阶段中，系统会做两件事情</p></blockquote><ul><li>执行到点的定时器</li><li>执行 <code>poll</code> 队列中的事件</li></ul><blockquote><p>并且当 poll 中没有定时器的情况下，会发现以下两件事情</p></blockquote><ul><li>如果 <code>poll</code> 队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制</li><li>如果 <code>poll</code> 队列为空，会有两件事发生<ul><li>如果有 <code>setImmediate</code> 需要执行，<code>poll</code> 阶段会停止并且进入到 <code>check</code> 阶段执行 <code>setImmediate</code></li><li>如果没有 <code>setImmediate</code> 需要执行，会等待回调被加入到队列中并立即执行回调</li></ul></li><li>如果有别的定时器需要被执行，会回到 <code>timer</code> 阶段执行回调</li></ul><h4 id="5-2-5-check"><a href="#5-2-5-check" class="headerlink" title="5.2.5 check"></a>5.2.5 check</h4><blockquote><p><code>check</code> 阶段执行 <code>setImmediate</code></p></blockquote><h4 id="5-2-6-close-callbacks"><a href="#5-2-6-close-callbacks" class="headerlink" title="5.2.6 close callbacks"></a>5.2.6 close callbacks</h4><ul><li><code>close callbacks</code> 阶段执行 <code>close</code> 事件</li><li>并且在 <code>Node</code> 中，有些情况下的定时器执行顺序是随机的</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setImmediate'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 这里可能会输出 setTimeout，setImmediate</span></span><br><span class="line"><span class="comment">// 可能也会相反的输出，这取决于性能</span></span><br><span class="line"><span class="comment">// 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate</span></span><br><span class="line"><span class="comment">// 否则会执行 setTimeout</span></span><br></pre></td></tr></table></figure><blockquote><p>当然在这种情况下，执行顺序是相同的</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">    setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 因为 readFile 的回调在 poll 中执行</span></span><br><span class="line"><span class="comment">// 发现有 setImmediate ，所以会立即跳到 check 阶段执行回调</span></span><br><span class="line"><span class="comment">// 再去 timer 阶段执行 setTimeout</span></span><br><span class="line"><span class="comment">// 所以以上输出一定是 setImmediate，setTimeout</span></span><br></pre></td></tr></table></figure><blockquote><p>上面介绍的都是<code>macrotask</code> 的执行情况，<code>microtask</code> 会在以上每个阶段完成后立即执行。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码在浏览器和 node 中打印情况是不同的</span></span><br><span class="line"><span class="comment">// 浏览器中一定打印 timer1, promise1, timer2, promise2</span></span><br><span class="line"><span class="comment">// node 中可能打印 timer1, timer2, promise1, promise2</span></span><br><span class="line"><span class="comment">// 也可能打印 timer1, promise1, timer2, promise2</span></span><br></pre></td></tr></table></figure><blockquote><p><code>Node</code> 中的 <code>process.nextTick</code> 会先于其他 <code>microtask</code> 执行。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"timer1"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"promise1"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"nextTick"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// nextTick, timer1, promise1</span></span><br></pre></td></tr></table></figure><h2 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、JavaScript是单线程&quot;&gt;&lt;a href=&quot;#一、JavaScript是单线程&quot; class=&quot;headerlink&quot; title=&quot;一、JavaScript是单线程&quot;&gt;&lt;/a&gt;一、JavaScript是单线程&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ja
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="JavaScript" scheme="http://blog.poetries.top/tags/JavaScript/"/>
    
      <category term="Event Loop" scheme="http://blog.poetries.top/tags/Event-Loop/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript事件机制</title>
    <link href="http://blog.poetries.top/2018/12/21/js-event/"/>
    <id>http://blog.poetries.top/2018/12/21/js-event/</id>
    <published>2018-12-21T14:40:21.000Z</published>
    <updated>2019-01-07T08:48:58.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><blockquote><p>事件流是一个事件沿着特定数据结构传播的过程。冒泡和捕获是事件流在<code>DOM</code>中两种不同的传播方法</p></blockquote><p><strong>事件流有三个阶段</strong></p><ul><li>事件捕获阶段</li><li>处于目标阶段</li><li>事件冒泡阶段</li></ul><p><strong>事件捕获</strong></p><blockquote><p>事件捕获（<code>event capturing</code>）：通俗的理解就是，当鼠标点击或者触发<code>dom</code>事件时，浏览器会从根节点开始由外到内进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件</p></blockquote><p><strong>事件冒泡</strong></p><blockquote><p>事件冒泡（dubbed bubbling）：与事件捕获恰恰相反，事件冒泡顺序是由内到外进行事件传播，直到根节点</p></blockquote><p>无论是事件捕获还是事件冒泡，它们都有一个共同的行为，就是事件传播</p><p><img src="https://upload-images.jianshu.io/upload_images/1480597-f492b6a8997493d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="二、捕获和冒泡"><a href="#二、捕获和冒泡" class="headerlink" title="二、捕获和冒泡"></a>二、捕获和冒泡</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> div2 = <span class="built_in">document</span>.getElementById(<span class="string">'div2'</span>);</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">    div1.onClick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">'1'</span>)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">    div2.onClick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">'2'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>当点击 <code>div2</code>时，会弹出两个弹出框。在 <code>ie8/9/10</code>、<code>chrome</code>浏览器，会先弹出”2”再弹出“1”，这就是事件冒泡：事件从最底层的节点向上冒泡传播。事件捕获则跟事件冒泡相反</p></blockquote><blockquote><p>W3C的标准是先捕获再冒泡， <code>addEventListener</code>的第三个参数决定把事件注册在捕获（<code>true</code>）还是冒泡(<code>false</code>)</p></blockquote><h2 id="三、事件对象"><a href="#三、事件对象" class="headerlink" title="三、事件对象"></a>三、事件对象</h2><p><img src="https://upload-images.jianshu.io/upload_images/1480597-350140df0758ccbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="四、事件流阻止"><a href="#四、事件流阻止" class="headerlink" title="四、事件流阻止"></a>四、事件流阻止</h2><blockquote><p>在一些情况下需要阻止事件流的传播，阻止默认动作的发生</p></blockquote><ul><li><code>event.preventDefault()</code>：取消事件对象的默认动作以及继续传播。</li><li><code>event.stopPropagation()/ event.cancelBubble = true</code>：阻止事件冒泡。</li></ul><p><strong>事件的阻止在不同浏览器有不同处理</strong></p><ul><li>在<code>IE</code>下使用 <code>event.returnValue= false</code>，</li><li>在非<code>IE</code>下则使用 <code>event.preventDefault()</code>进行阻止</li></ul><p><strong>preventDefault与stopPropagation的区别</strong></p><ul><li><code>preventDefault</code>告诉浏览器不用执行与事件相关联的默认动作（如表单提交）</li><li><code>stopPropagation</code>是停止事件继续冒泡，但是对IE9以下的浏览器无效</li></ul><h2 id="五、事件注册"><a href="#五、事件注册" class="headerlink" title="五、事件注册"></a>五、事件注册</h2><ul><li>通常我们使用 <code>addEventListener</code> 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 <code>useCapture</code> 参数来说，该参数默认值为 <code>false</code>。<code>useCapture</code> 决定了注册的事件是捕获事件还是冒泡事件</li><li>一般来说，我们只希望事件只触发在目标上，这时候可以使用 <code>stopPropagation</code> 来阻止事件的进一步传播。通常我们认为 <code>stopPropagation</code> 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。<code>stopImmediatePropagation</code> 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">node.addEventListener(<span class="string">'click'</span>,(event) =&gt;&#123;</span><br><span class="line">event.stopImmediatePropagation()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'冒泡'</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 点击 node 只会执行上面的函数，该函数不会执行</span></span><br><span class="line">node.addEventListener(<span class="string">'click'</span>,(event) =&gt; &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'捕获 '</span>)</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><h2 id="六、事件委托"><a href="#六、事件委托" class="headerlink" title="六、事件委托"></a>六、事件委托</h2><ul><li>在<code>js</code>中性能优化的其中一个主要思想是减少<code>dom</code>操作。</li></ul><blockquote><p>假设有<code>100</code>个<code>li</code>，每个<code>li</code>有相同的点击事件。如果为每<code>个Li</code>都添加事件，则会造成<code>dom</code>访问次数过多，引起浏览器重绘与重排的次数过多，性能则会降低。<br>使用事件委托则可以解决这样的问题</p></blockquote><p><strong>原理</strong></p><blockquote><p>实现事件委托是利用了事件的冒泡原理实现的。当我们为最外层的节点添加点击事件，那么里面的<code>ul</code>、<code>li</code>、<code>a</code>的点击事件都会冒泡到最外层节点上，委托它代为执行事件</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ulEle = <span class="built_in">document</span>.getElementById(<span class="string">'ul'</span>);</span><br><span class="line">    ul.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//兼容IE</span></span><br><span class="line">        ev = ev || <span class="built_in">window</span>.event;</span><br><span class="line">        <span class="keyword">var</span> target = ev.target || ev.srcElement;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(target.nodeName.toLowerCase() == <span class="string">'li'</span>)&#123;</span><br><span class="line">            alert( target.innerHTML);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;事件流是一个事件沿着特定数据结构传播的过程。冒泡和捕获是事件流在&lt;code&gt;DOM&lt;/code&gt;中
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="JavaScript" scheme="http://blog.poetries.top/tags/JavaScript/"/>
    
      <category term="事件机制" scheme="http://blog.poetries.top/tags/%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript防抖节流原理</title>
    <link href="http://blog.poetries.top/2018/12/21/js-debounce/"/>
    <id>http://blog.poetries.top/2018/12/21/js-debounce/</id>
    <published>2018-12-21T13:20:43.000Z</published>
    <updated>2019-01-07T08:48:58.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、防抖debounce"><a href="#一、防抖debounce" class="headerlink" title="一、防抖debounce"></a>一、防抖debounce</h2><blockquote><p>你是否在日常开发中遇到一个问题，在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作</p></blockquote><ul><li>这些需求都可以通过函数防抖动来实现。如果在频繁的事件回调中做复杂计算，很有可能导致页面卡顿，不如将多次计算合并为一次计算，只在一个精确点做操作</li><li>防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于<code>wait</code>，防抖的情况下只会调用一次，而节流的 情况会每隔一定时间（参数<code>wait</code>）调用函数</li></ul><blockquote><p>持续触发<code>scroll</code>事件时，并不执行<code>handle</code>函数，当<code>1000</code>毫秒内没有触发<code>scroll</code>事件时，才会延时触发<code>scroll</code>事件</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-9ac8da1501c475d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防抖</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">var</span> timeout = <span class="literal">null</span>;    </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;        </span><br><span class="line">        <span class="keyword">if</span>(timeout !== <span class="literal">null</span>)   clearTimeout(timeout);        </span><br><span class="line">        timeout = setTimeout(fn, wait);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Math</span>.random()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 滚动事件</span></span><br><span class="line"><span class="comment">// 当持续触发scroll事件时，事件处理函数handle只在停止滚动1000毫秒之后才会调用一次，也就是说在持续触发scroll事件的过程中，事件处理函数handle一直没有执行</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, debounce(handle, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure><blockquote><p>我们先来看一个袖珍版的防抖理解一下防抖的实现</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func是用户传入需要防抖的函数</span></span><br><span class="line"><span class="comment">// wait是等待时间</span></span><br><span class="line"><span class="keyword">const</span> debounce = <span class="function">(<span class="params">func, wait = <span class="number">50</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 缓存一个定时器id</span></span><br><span class="line">  <span class="keyword">let</span> timer = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 这里返回的函数是每次用户实际调用的防抖函数</span></span><br><span class="line">  <span class="comment">// 如果已经设定过定时器了就清空上一次的定时器</span></span><br><span class="line">  <span class="comment">// 开始一个新的定时器，延迟执行用户传入的方法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) clearTimeout(timer)</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      func.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不难看出如果用户调用该函数的间隔小于wait的情况下，上一次的时间还未到就被清除了，并不会执行函数</span></span><br></pre></td></tr></table></figure><blockquote><p>这是一个简单版的防抖，但是有缺陷，这个防抖只能在最后调用。一般的防抖会有<code>immediate</code>选项，表示是否立即调用。这两者的区别，举个栗子来说</p></blockquote><ul><li>例如在搜索引擎搜索问题的时候，我们当然是希望用户输入完最后一个字才调用查询接口，这个时候适用延迟执行的防抖函数，它总是在一连串（间隔小于<code>wait</code>的）函数触发之后调用。</li><li>例如用户给<code>interviewMap</code>点<code>star</code>的时候，我们希望用户点第一下的时候就去调用接口，并且成功之后改变<code>star</code>按钮的样子，用户就可以立马得到反馈是否<code>star</code>成功了，这个情况适用立即执行的防抖函数，它总是在第一次调用，并且下一次调用必须与前一次调用的时间间隔大于<code>wait</code>才会触发</li></ul><p><strong>完整代码</strong></p><blockquote><p>下面我们来实现一个带有立即执行选项的防抖函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个是用来获取当前时间戳的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">now</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param  &#123;function&#125; func        回调函数</span></span><br><span class="line"><span class="comment"> * @param  &#123;number&#125;   wait        表示时间窗口的间隔</span></span><br><span class="line"><span class="comment"> * @param  &#123;boolean&#125;  immediate   设置为ture时，是否立即调用函数</span></span><br><span class="line"><span class="comment"> * @return &#123;function&#125;             返回客户调用函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">func, wait = <span class="number">50</span>, immediate = true</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer, context, args</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 延迟执行函数</span></span><br><span class="line">  <span class="keyword">const</span> later = <span class="function"><span class="params">()</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 延迟函数执行完毕，清空缓存的定时器序号</span></span><br><span class="line">    timer = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 延迟执行的情况下，函数会在延迟函数中执行</span></span><br><span class="line">    <span class="comment">// 使用到之前缓存的参数和上下文</span></span><br><span class="line">    <span class="keyword">if</span> (!immediate) &#123;</span><br><span class="line">      func.apply(context, args)</span><br><span class="line">      context = args = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, wait)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里返回的函数是每次实际调用的函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...params</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果没有创建延迟执行函数（later），就创建一个</span></span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = later()</span><br><span class="line">      <span class="comment">// 如果是立即执行，调用函数</span></span><br><span class="line">      <span class="comment">// 否则缓存参数和调用上下文</span></span><br><span class="line">      <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">        func.apply(<span class="keyword">this</span>, params)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        context = <span class="keyword">this</span></span><br><span class="line">        args = params</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个</span></span><br><span class="line">    <span class="comment">// 这样做延迟函数会重新计时</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">      timer = later()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于按钮防点击来说的实现：如果函数是立即执行的，就立即调用，如果函数是延迟执行的，就缓存上下文和参数，放到延迟函数中去执行。一旦我开始一个定时器，只要我定时器还在，你每次点击我都重新计时。一旦你点累了，定时器时间到，定时器重置为 <code>null</code>，就可以再次点击了。</li><li>对于延时执行函数来说的实现：清除定时器ID，如果是延迟调用就调用函数<br>#</li></ul><h2 id="二、节流throttle"><a href="#二、节流throttle" class="headerlink" title="二、节流throttle"></a>二、节流throttle</h2><blockquote><p>防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行</p></blockquote><p>如下图，持续触发<code>scroll</code>事件时，并不立即执行<code>handle</code>函数，每隔<code>1000</code>毫秒才会执行一次<code>handle</code>函数</p><p><img src="https://upload-images.jianshu.io/upload_images/1480597-81791a77f37fcbb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>节流版本</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param  &#123;function&#125;   func      回调函数</span></span><br><span class="line"><span class="comment"> * @param  &#123;number&#125;     wait      表示时间窗口的间隔</span></span><br><span class="line"><span class="comment"> * @param  &#123;object&#125;     options   如果想忽略开始函数的的调用，传入&#123;leading: false&#125;。</span></span><br><span class="line"><span class="comment"> *                                如果想忽略结尾函数的调用，传入&#123;trailing: false&#125;</span></span><br><span class="line"><span class="comment"> *                                两者不能共存，否则函数不能执行</span></span><br><span class="line"><span class="comment"> * @return &#123;function&#125;             返回客户调用函数   </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">_.throttle = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context, args, result;</span><br><span class="line">    <span class="keyword">var</span> timeout = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 之前的时间戳</span></span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果 options 没传则设为空对象</span></span><br><span class="line">    <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 定时器回调函数</span></span><br><span class="line">    <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 如果设置了 leading，就将 previous 设为 0</span></span><br><span class="line">      <span class="comment">// 用于下面函数的第一个 if 判断</span></span><br><span class="line">      previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : _.now();</span><br><span class="line">      <span class="comment">// 置空一是为了防止内存泄漏，二是为了下面的定时器判断</span></span><br><span class="line">      timeout = <span class="literal">null</span>;</span><br><span class="line">      result = func.apply(context, args);</span><br><span class="line">      <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 获得当前时间戳</span></span><br><span class="line">      <span class="keyword">var</span> now = _.now();</span><br><span class="line">      <span class="comment">// 首次进入前者肯定为 true</span></span><br><span class="line">  <span class="comment">// 如果需要第一次不执行函数</span></span><br><span class="line">  <span class="comment">// 就将上次时间戳设为当前的</span></span><br><span class="line">      <span class="comment">// 这样在接下来计算 remaining 的值时会大于0</span></span><br><span class="line">      <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">      <span class="comment">// 计算剩余时间</span></span><br><span class="line">      <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">      context = <span class="keyword">this</span>;</span><br><span class="line">      args = <span class="built_in">arguments</span>;</span><br><span class="line">      <span class="comment">// 如果当前调用已经大于上次调用时间 + wait</span></span><br><span class="line">      <span class="comment">// 或者用户手动调了时间</span></span><br><span class="line">   <span class="comment">// 如果设置了 trailing，只会进入这个条件</span></span><br><span class="line">  <span class="comment">// 如果没有设置 leading，那么第一次会进入这个条件</span></span><br><span class="line">  <span class="comment">// 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了</span></span><br><span class="line">  <span class="comment">// 其实还是会进入的，因为定时器的延时</span></span><br><span class="line">  <span class="comment">// 并不是准确的时间，很可能你设置了2秒</span></span><br><span class="line">  <span class="comment">// 但是他需要2.2秒才触发，这时候就会进入这个条件</span></span><br><span class="line">      <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">        <span class="comment">// 如果存在定时器就清理掉否则会调用二次回调</span></span><br><span class="line">        <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">          clearTimeout(timeout);</span><br><span class="line">          timeout = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        previous = now;</span><br><span class="line">        result = func.apply(context, args);</span><br><span class="line">        <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断是否设置了定时器和 trailing</span></span><br><span class="line">    <span class="comment">// 没有的话就开启一个定时器</span></span><br><span class="line">        <span class="comment">// 并且不能不能同时设置 leading 和 trailing</span></span><br><span class="line">        timeout = setTimeout(later, remaining);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、防抖debounce&quot;&gt;&lt;a href=&quot;#一、防抖debounce&quot; class=&quot;headerlink&quot; title=&quot;一、防抖debounce&quot;&gt;&lt;/a&gt;一、防抖debounce&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;你是否在日常开发中遇到一个问题，在
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="JavaScript" scheme="http://blog.poetries.top/tags/JavaScript/"/>
    
      <category term="防抖节流" scheme="http://blog.poetries.top/tags/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深浅拷贝</title>
    <link href="http://blog.poetries.top/2018/12/21/js-deep-copy/"/>
    <id>http://blog.poetries.top/2018/12/21/js-deep-copy/</id>
    <published>2018-12-21T10:08:43.000Z</published>
    <updated>2019-01-07T08:48:58.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><blockquote><p>在<code>js</code>中，变量的类型可以大致分成两种：基本数据类型和引用数据类型，其中基本数据类型指的是简单的数据段，包括：</p></blockquote><ul><li><code>undefined</code></li><li><code>Null</code></li><li><code>Boolean</code></li><li><code>Number</code></li><li><code>String</code>(字符串在一些其他语言中是被当做对象使用的，属于引用类型，但在<code>js</code>里是基本类型)</li></ul><blockquote><p>而引用类型的值指的是可能包含多个值的对象。本质上，是因为基本数据类型保存在栈内存,而引用类型保存在堆内存中。为什么要分两种保存方式呢？ 根本原因在于保存在栈内存的必须是大小固定的数据，引用类型的大小不固定，只能保存在堆内存中，但是我们可以把它的地址写在占内存中以供我们访问</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;<span class="comment">//定义了一个number类型</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="comment">//定义了一个objr类型</span></span><br><span class="line">    name:<span class="string">'obj'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>在执行这段代码后，内存空间里是这样的</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-2123b32287c6f82a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>因为这种保存方式的存在，所以我们在操作变量的时候，如果是基本数据类型，则按值访问，操作的就是变量保存的值；如果是引用类型的值，我们只是通过保存在变量中的引用类型的地址类操作实际对象。从而也引出了所谓的深浅复制问题</p></blockquote><h2 id="二、浅拷贝"><a href="#二、浅拷贝" class="headerlink" title="二、浅拷贝"></a>二、浅拷贝</h2><p><strong>方法一</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设有两个对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objA = &#123;</span><br><span class="line">  a: <span class="string">'aa'</span>,</span><br><span class="line">  b: <span class="string">'bb'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> objB = &#123;&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现在想把对象A的值复制给B，由于对象A的两个值都是原始类型，用浅复制即可</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">sub, sup</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> sup) &#123;</span><br><span class="line">    sub[key] = sup[key];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">copy(objB, objA);</span><br></pre></td></tr></table></figure><p><strong>方法二</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.assign() (兼容性不好)</span><br></pre></td></tr></table></figure><p><strong>方法三</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.clone()</span><br></pre></td></tr></table></figure><p><strong>方法四</strong></p><blockquote><p>数组中<code>concat</code>和<code>slice</code>方法</p></blockquote><p><strong>方法五</strong></p><blockquote><p>ES6展开运算</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [&#123;<span class="attr">name</span>:<span class="string">'poetries'</span>,<span class="attr">age</span>:<span class="number">22</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> target = [...arr]</span><br></pre></td></tr></table></figure><h2 id="三、深拷贝"><a href="#三、深拷贝" class="headerlink" title="三、深拷贝"></a>三、深拷贝</h2><blockquote><p>简单来说深复制就是当遇到值是对象类型的时候就再运行一遍复制</p></blockquote><p><strong>方法一 JSON.parse(JSON.stringify(obj))</strong></p><blockquote><p>简单粗暴又有点<code>dirty</code>，但是能满足日常需求，只能处理<code>json</code>能理解的数据格式，当然不包括函数了，性能也没有特别好</p></blockquote><p><strong>方法二 lodash —— _.cloneDeep()</strong></p><blockquote><p>很好地兼容了ES6的新引用类型，而且处理了环型对象的情况</p></blockquote><p><strong>方法三 jQuery —— $.clone() / $.extend()</strong></p><blockquote><p>源码适合初学者学习，比较好理解</p></blockquote><p><strong>方法四 自己实现一个</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//引用类型分数组和对象分别递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(obj) == <span class="string">'[object Array]'</span>) &#123;</span><br><span class="line">      result = []</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; obj.length; i++) &#123;</span><br><span class="line">        result[i] = deepCopy(obj[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(obj) == <span class="string">'[object Object]'</span>) &#123;</span><br><span class="line">      result = &#123;&#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> attr <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        result[attr] = deepCopy(obj[attr])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//值类型直接返回</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在&lt;code&gt;js&lt;/code&gt;中，变量的类型可以大致分成两种：基本数据类型和引用数据类型，其中基
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="JavaScript" scheme="http://blog.poetries.top/tags/JavaScript/"/>
    
      <category term="深浅拷贝" scheme="http://blog.poetries.top/tags/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>ES6系列之Async/await</title>
    <link href="http://blog.poetries.top/2018/12/21/es6-async/"/>
    <id>http://blog.poetries.top/2018/12/21/es6-async/</id>
    <published>2018-12-21T08:50:43.000Z</published>
    <updated>2019-01-07T08:48:58.284Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>来自一峰ES6教程</p></blockquote><h2 id="一、含义"><a href="#一、含义" class="headerlink" title="一、含义"></a>一、含义</h2><blockquote><p><code>async</code> 函数是什么？一句话，它就是 <code>Generator</code> 函数的语法糖</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有一个 Generator 函数，依次读取两个文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">return</span> reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>上面代码的函数<code>gen</code>可以写成<code>async</code>函数，就是下面这样</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">await</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><code>async</code>函数就是将 <code>Generator</code> 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>，仅此而已</p></blockquote><p><strong>async函数对 Generator 函数的改进，体现在以下四点</strong></p><ol><li>内置执行器</li></ol><blockquote><p><code>Generator</code>函数的执行必须靠执行器，所以才有了<code>co</code>模块，而<code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样，只要一行</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asyncReadFile();</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码调用了<code>asyncReadFile</code>函数，然后它就会自动执行，输出最后结果。这完全不像 <code>Generator</code> 函数，需要调用<code>next</code>方法，或者用<code>co</code>模块，才能真正执行，得到最后结果</p></blockquote><ol start="2"><li>更好的语义</li></ol><blockquote><p><code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚了。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果</p></blockquote><ol start="3"><li>更广的适用性</li></ol><blockquote><p><code>co</code>模块约定，<code>yield</code>命令后面只能是 <code>Thunk</code> 函数或 <code>Promise</code> 对象，而<code>async</code>函数的<code>await</code>命令后面，可以是 <code>Promise</code> 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）</p></blockquote><ol start="4"><li>返回值是 <code>Promise</code></li></ol><blockquote><p><code>async</code>函数的返回值是 <code>Promise</code> 对象，这比 <code>Generator</code> 函数的返回值是 <code>Iterator</code> 对象方便多了。你可以用<code>then</code>方法指定下一步的操作</p></blockquote><p>进一步说，<code>async</code>函数完全可以看作多个异步操作，包装成的一个 <code>Promise</code> 对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖</p><h2 id="二、基本用法"><a href="#二、基本用法" class="headerlink" title="二、基本用法"></a>二、基本用法</h2><blockquote><p><code>async</code>函数返回一个 <code>Promise</code> 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-863470b10afbd742.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用该函数时，会立即返回一个Promise对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getStockPriceByName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> symbol = <span class="keyword">await</span> getStockSymbol(name);</span><br><span class="line">  <span class="keyword">const</span> stockPrice = <span class="keyword">await</span> getStockPrice(symbol);</span><br><span class="line">  <span class="keyword">return</span> stockPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getStockPriceByName(<span class="string">'goog'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>async 函数有多种使用形式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的方法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="keyword">async</span> foo() &#123;&#125; &#125;;</span><br><span class="line">obj.foo().then(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class 的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.cachePromise = caches.open(<span class="string">'avatars'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> getAvatar(name) &#123;</span><br><span class="line">    <span class="keyword">const</span> cache = <span class="keyword">await</span> <span class="keyword">this</span>.cachePromise;</span><br><span class="line">    <span class="keyword">return</span> cache.match(<span class="string">`/avatars/<span class="subst">$&#123;name&#125;</span>.jpg`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> storage = <span class="keyword">new</span> Storage();</span><br><span class="line">storage.getAvatar(<span class="string">'jake'</span>).then(…);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="三、语法"><a href="#三、语法" class="headerlink" title="三、语法"></a>三、语法</h2><blockquote><p><code>async</code>函数的语法规则总体上比较简单，难点是错误处理机制</p></blockquote><h3 id="3-1-返回-Promise-对象"><a href="#3-1-返回-Promise-对象" class="headerlink" title="3.1 返回 Promise 对象"></a>3.1 返回 Promise 对象</h3><ul><li><code>async</code>函数返回一个 <code>Promise</code> 对象</li><li><code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数f内部return命令返回的值，会被then方法回调函数接收到</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hello world'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// "hello world"</span></span><br></pre></td></tr></table></figure><blockquote><p><code>async</code>函数内部抛出错误，会导致返回的 <code>Promise</code> 对象变为<code>reject</code>状态。抛出的错误对象会被<code>catch</code>方法回调函数接收到</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(</span><br><span class="line">  v =&gt; <span class="built_in">console</span>.log(v),</span><br><span class="line">  e =&gt; <span class="built_in">console</span>.log(e)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// Error: 出错了</span></span><br></pre></td></tr></table></figure><h3 id="3-2-Promise-对象的状态变化"><a href="#3-2-Promise-对象的状态变化" class="headerlink" title="3.2 Promise 对象的状态变化"></a>3.2 Promise 对象的状态变化</h3><blockquote><p><code>async</code>函数返回的 <code>Promise</code> 对象，必须等到内部所有<code>await</code>命令后面的 <code>Promise</code> 对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。也就是说，只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getTitle</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">  <span class="keyword">let</span> html = <span class="keyword">await</span> response.text();</span><br><span class="line">  <span class="keyword">return</span> html.match(<span class="regexp">/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i</span>)[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">getTitle(<span class="string">'https://tc39.github.io/ecma262/'</span>).then(<span class="built_in">console</span>.log)</span><br><span class="line"><span class="comment">// "ECMAScript 2017 Language Specification"</span></span><br></pre></td></tr></table></figure><h3 id="3-3-await-命令"><a href="#3-3-await-命令" class="headerlink" title="3.3 await 命令"></a>3.3 await 命令</h3><blockquote><p>正常情况下，<code>await</code>命令后面是一个 <code>Promise</code> 对象，返回该对象的结果。如果不是 <code>Promise</code> 对象，就直接返回对应的值</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 等同于</span></span><br><span class="line">  <span class="comment">// return 123;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure><blockquote><p>另一种情况是，<code>await</code>命令后面是一个<code>thenable</code>对象（即定义<code>then</code>方法的对象），那么<code>await</code>会将其等同于 <code>Promise</code> 对象</p></blockquote><ul><li><code>await</code>命令后面的 <code>Promise</code> 对象如果变为<code>reject</code>状态，则<code>reject</code>的参数会被<code>catch</code>方法的回调函数接收到。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><ul><li>注意，上面代码中，<code>await</code>语句前面没有<code>return</code>，但是<code>reject</code>方法的参数依然传入了<code>catch</code>方法的回调函数。这里如果在<code>await</code>前面加上<code>return</code>，效果是一样的。</li><li>任何一个<code>await</code>语句后面的 <code>Promise</code> 对象变为<code>reject</code>状态，那么整个<code>async</code>函数都会中断执行</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个<code>await</code>都会执行</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><blockquote><p>另一种方法是<code>await</code>后面的 <code>Promise</code> 对象再跟一个<code>catch</code>方法，处理前面可能出现的错误。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>)</span><br><span class="line">    .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// 出错了</span></span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><h3 id="3-4-错误处理"><a href="#3-4-错误处理" class="headerlink" title="3.4 错误处理"></a>3.4 错误处理</h3><blockquote><p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 <code>Promise</code> 对象被<code>reject</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br><span class="line"><span class="comment">// Error：出错了</span></span><br></pre></td></tr></table></figure><blockquote><p>防止出错的方法，也是将其放在<code>try...catch</code>代码块之中</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span>(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果有多个<code>await</code>命令，可以统一放在<code>try...catch</code>结构中</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> val1 = <span class="keyword">await</span> firstStep();</span><br><span class="line">    <span class="keyword">const</span> val2 = <span class="keyword">await</span> secondStep(val1);</span><br><span class="line">    <span class="keyword">const</span> val3 = <span class="keyword">await</span> thirdStep(val1, val2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Final: '</span>, val3);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-使用注意点"><a href="#3-5-使用注意点" class="headerlink" title="3.5 使用注意点"></a>3.5 使用注意点</h3><blockquote><p>第一点：<code>await</code>命令后面的Promise对象，运行结果可能是<code>rejected</code>，所以最好把<code>await</code>命令放在<code>try...catch</code>代码块中</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> somethingThatReturnsAPromise();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> somethingThatReturnsAPromise()</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第二点，多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> getFoo();</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> getBar();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两种写法，getFoo和getBar都是同时触发，这样就会缩短程序的执行时间。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = getFoo();</span><br><span class="line"><span class="keyword">let</span> barPromise = getBar();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br></pre></td></tr></table></figure><blockquote><p>第三点，<code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  docs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、async-函数的实现原理"><a href="#四、async-函数的实现原理" class="headerlink" title="四、async 函数的实现原理"></a>四、async 函数的实现原理</h2><blockquote><p><code>async</code> 函数的实现原理，就是将 <code>Generator</code> 函数和自动执行器，包装在一个函数里</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> spawn(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>所有的<code>async</code>函数都可以写成上面的第二种形式，其中的<code>spawn</code>函数就是自动执行器</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// spawn函数的实现，基本就是前文自动执行器的翻版</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawn</span>(<span class="params">genF</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> gen = genF();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">nextF</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> next;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        next = nextF();</span><br><span class="line">      &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(next.done) &#123;</span><br><span class="line">        <span class="keyword">return</span> resolve(next.value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(next.value).then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.next(v); &#125;);</span><br><span class="line">      &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.throw(e); &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.next(<span class="literal">undefined</span>); &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;来自一峰ES6教程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、含义&quot;&gt;&lt;a href=&quot;#一、含义&quot; class=&quot;headerlink&quot; title=&quot;一、含义&quot;&gt;&lt;/a&gt;一、含义&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="JavaScript" scheme="http://blog.poetries.top/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://blog.poetries.top/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6系列之Generator</title>
    <link href="http://blog.poetries.top/2018/12/21/es6-generator/"/>
    <id>http://blog.poetries.top/2018/12/21/es6-generator/</id>
    <published>2018-12-21T08:20:31.000Z</published>
    <updated>2019-01-07T08:48:58.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是Generator-函数"><a href="#一、什么是Generator-函数" class="headerlink" title="一、什么是Generator 函数"></a>一、什么是Generator 函数</h2><h3 id="1-1-语法"><a href="#1-1-语法" class="headerlink" title="1.1 语法"></a>1.1 语法</h3><blockquote><p>学习 <code>Generator</code> 语法，你需要了解<code>function*</code> 、<code>yield</code>、<code>next</code>三个基本概念。</p></blockquote><ul><li><code>function*</code> 用来声明一个函数是生成器函数，它比普通的函数声明多了一个<code>*</code>,<code>*</code>的位置比较随意可以挨着 <code>function</code> 关键字，也可以挨着函数名</li><li><code>yield</code> 产出的意思，这个关键字只能出现在生成器函数体内，但是生成器中也可以没有<code>yield</code> 关键字，函数遇到 <code>yield</code> 的时候会暂停，并把 <code>yield</code> 后面的表达式结果抛出去</li><li><code>next</code>作用是将代码的控制权交还给生成器函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明生成器函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// A</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'foo'</span></span><br><span class="line">    <span class="comment">// B</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取生成器对象</span></span><br><span class="line"><span class="keyword">let</span> g = generator();</span><br><span class="line"><span class="comment">// 第一个 next()，首次启动生成器</span></span><br><span class="line">g.next(); <span class="comment">// &#123;value: "foo", done: false&#125;</span></span><br><span class="line"><span class="comment">// 唤醒被 yield 暂停的状态</span></span><br><span class="line">g.next();</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-过程分析"><a href="#1-2-过程分析" class="headerlink" title="1.2 过程分析"></a>1.2 过程分析</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分析一个简单例子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">yield</span> <span class="string">"hello"</span>;</span><br><span class="line">   <span class="keyword">yield</span> <span class="string">"generator"</span>;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> h = helloGenerator();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(h.next());<span class="comment">//&#123; value: 'hello', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(h.next());<span class="comment">//&#123; value: 'generator', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(h.next());<span class="comment">//&#123; value: 'undefined', done: true &#125;</span></span><br></pre></td></tr></table></figure><ul><li>创建了<code>h</code>对象，指向<code>helloGenerator</code>的句柄</li><li>第一次调用<code>next()</code>，执行到<code>&quot;yield hello&quot;</code>，暂缓执行,并返回了<code>&quot;hello&quot;</code></li><li>第二次调用<code>next()</code>，继续上一次的执行，执行到<code>&quot;yield generator&quot;</code>,暂缓执行，并返回了<code>&quot;generator&quot;</code>。</li><li>第三次调用<code>next()</code>,直接执行<code>return</code>，并返回<code>done:true</code>，表明结束</li></ul><blockquote><p>经过上面的分析，<code>yield</code>实际就是暂缓执行的标示，每执行一次<code>next()</code>，相当于指针移动到下一个<code>yield</code>位置</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-9141623112dee6ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>总结一下</strong>，<code>Generator</code>函数是<code>ES6</code>提供的一种异步编程解决方案。通过<code>yield</code>标识位和<code>next()</code>方法调用，实现函数的分段执行</p><h3 id="1-3-yield-表达式"><a href="#1-3-yield-表达式" class="headerlink" title="1.3 yield 表达式"></a>1.3 yield 表达式</h3><blockquote><p><code>yield</code>是<code>Generator</code>函数的暂缓执行的标识，对于<code>yield</code>只能配合<code>Generator</code>函数使用，在普通的函数中使用会报错</p></blockquote><p><code>Generator</code>函数中还有一种<code>yield*</code>这个表达方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">yield</span> <span class="string">"a"</span>;</span><br><span class="line">   <span class="keyword">yield</span> <span class="string">"b"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">yield</span>* foo();</span><br><span class="line">     <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> g = gen();</span><br><span class="line">   <span class="built_in">console</span>.log(g.next());<span class="comment">//&#123;value: 1, done: false&#125;</span></span><br><span class="line">   <span class="built_in">console</span>.log(g.next());<span class="comment">//&#123;value: 2, done: false&#125;</span></span><br><span class="line">   <span class="built_in">console</span>.log(g.next());<span class="comment">//&#123;value: "a", done: true&#125;</span></span><br><span class="line">   <span class="built_in">console</span>.log(g.next());<span class="comment">//&#123;value: "b", done: true&#125;</span></span><br><span class="line">   <span class="built_in">console</span>.log(g.next());<span class="comment">//&#123;value: "3", done: true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当执行<code>yield*</code>时，实际是遍历后面的<code>Generator</code>函数，等价于下面的写法：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">yield</span> <span class="string">"a"</span>;</span><br><span class="line">   <span class="keyword">yield</span> <span class="string">"b"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> value <span class="keyword">of</span> foo())&#123;</span><br><span class="line">      <span class="keyword">yield</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<code>yield</code> 后面只能适配<code>Generator</code>函数</p><h2 id="二、Generator应用场景"><a href="#二、Generator应用场景" class="headerlink" title="二、Generator应用场景"></a>二、Generator应用场景</h2><h3 id="2-1-异步操作的同步化表达"><a href="#2-1-异步操作的同步化表达" class="headerlink" title="2.1 异步操作的同步化表达"></a>2.1 异步操作的同步化表达</h3><blockquote><p><code>Generator</code>函数的暂停执行的效果，意味着可以把异步操作写在<code>yield</code>表达式里面，等到调用<code>next</code>方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在<code>yield</code>表达式下面，反正要等到调用<code>next</code>方法时再执行。所以，<code>Generator</code>函数的一个重要实际意义就是用来处理异步操作，改写回调函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">loadUI</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  showLoadingScreen();</span><br><span class="line">  <span class="keyword">yield</span> loadUIDataAsynchronously();</span><br><span class="line">  hideLoadingScreen();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> loader = loadUI();</span><br><span class="line"><span class="comment">// 加载UI</span></span><br><span class="line">loader.next()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载UI</span></span><br><span class="line">loader.next()</span><br></pre></td></tr></table></figure><blockquote><p>上面代码中，第一次调用<code>loadUI</code>函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用<code>next</code>方法，则会显示<code>Loading</code>界面，并且异步加载数据。等到数据加载完成，再一次使用next方法，则会隐藏<code>Loading</code>界面。可以看到，这种写法的好处是所有<code>Loading</code>界面的逻辑，都被封装在一个函数，按部就班非常清晰</p></blockquote><ul><li>通过<code>Generator</code>函数部署<code>Ajax</code>操作，可以用同步的方式表达。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> request(<span class="string">"http://some.url"</span>);</span><br><span class="line">  <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse(result);</span><br><span class="line">    <span class="built_in">console</span>.log(resp.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  makeAjaxCall(url, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">    it.next(response);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = main();</span><br><span class="line">it.next();</span><br></pre></td></tr></table></figure><h3 id="2-2-控制流管理"><a href="#2-2-控制流管理" class="headerlink" title="2.2 控制流管理"></a>2.2 控制流管理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDataAsync</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> res = &#123;</span><br><span class="line">                url: url,</span><br><span class="line">                data: <span class="built_in">Math</span>.random()</span><br><span class="line">            &#125;</span><br><span class="line">            resolve(res)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用 <code>Generator</code> 函数可以这样写</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">getData</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res1 = <span class="keyword">yield</span> getDataAsync(<span class="string">'/page/1?param=123'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res1)</span><br><span class="line">    <span class="keyword">var</span> res2 = <span class="keyword">yield</span> getDataAsync(<span class="string">`/page/2?param=<span class="subst">$&#123;res1.data&#125;</span>`</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res2)</span><br><span class="line">    <span class="keyword">var</span> res3 = <span class="keyword">yield</span> getDataAsync(<span class="string">`/page/2?param=<span class="subst">$&#123;res2.data&#125;</span>`</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res3))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然后我们这样逐步执行</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = getData()</span><br><span class="line">g.next().value.then(<span class="function"><span class="params">res1</span> =&gt;</span> &#123;</span><br><span class="line">    g.next(res1).value.then(<span class="function"><span class="params">res2</span> =&gt;</span> &#123;</span><br><span class="line">        g.next(res2).value.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            g.next()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码，我们逐步调用遍历器的 <code>next()</code>方法，由于每一个 <code>next()</code> 方法返回值的 <code>value</code> 属性为一个 <code>Promise</code> 对象，所以我们为其添加 <code>then</code>方法， 在 <code>then</code> 方法里面接着运行 <code>next</code> 方法挪移遍历器指针，直到 <code>Generator</code> 函数运行完成，实际上，这个过程我们不必手动完成，可以封装成一个简单的执行器</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> g = gen()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> res = g.next(data)</span><br><span class="line">        <span class="keyword">if</span> (res.done) <span class="keyword">return</span> res.value</span><br><span class="line">        res.value.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">            next(data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>run</code>方法用来自动运行异步的 <code>Generator</code> 函数，其实就是一个递归的过程调用的过程。这样我们就不必手动执行 <code>Generator</code> 函数了。 有了 <code>run</code> 方法，我们只需要这样运行 <code>getData</code> 方法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run(getData)</span><br></pre></td></tr></table></figure><blockquote><p>这样，我们就可以把异步操作封装到 <code>Generator</code> 函数内部，使用 <code>run</code>方法作为 <code>Generator</code> 函数的自执行器，来处理异步。其实我们不难发现， <code>async/await</code> 方法相比于 <code>Generator</code> 处理异步的方式，有很多相似的地方，只不过 async/await 在语义化方面更加明显，同时 <code>async/await</code> 不需要我们手写执行器，其内部已经帮我们封装好了，这就是为什么说 <code>async/await</code>是 <code>Generator</code>函数处理异步的语法糖了</p></blockquote><h3 id="2-3-部署-Iterator-接口"><a href="#2-3-部署-Iterator-接口" class="headerlink" title="2.3 部署 Iterator 接口"></a>2.3 部署 Iterator 接口</h3><blockquote><p>利用 <code>Generator</code> 函数，可以在任意对象上部署 <code>Iterator</code> 接口。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iterEntries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = keys[i];</span><br><span class="line">    <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = &#123; <span class="attr">foo</span>: <span class="number">3</span>, <span class="attr">bar</span>: <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> iterEntries(myObj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo 3</span></span><br><span class="line"><span class="comment">// bar 7</span></span><br></pre></td></tr></table></figure><blockquote><p>上述代码中，<code>myObj</code>是一个普通对象，通过<code>iterEntries</code>函数，就有了 <code>Iterator</code> 接口。也就是说，可以在任意对象上部署<code>next</code>方法</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是一个对数组部署 Iterator 接口的例子，尽管数组原生具有这个接口</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">makeSimpleGenerator</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(nextIndex &lt; array.length)&#123;</span><br><span class="line">    <span class="keyword">yield</span> array[nextIndex++];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = makeSimpleGenerator([<span class="string">'yo'</span>, <span class="string">'ya'</span>]);</span><br><span class="line"></span><br><span class="line">gen.next().value <span class="comment">// 'yo'</span></span><br><span class="line">gen.next().value <span class="comment">// 'ya'</span></span><br><span class="line">gen.next().done  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="三、更多参考"><a href="#三、更多参考" class="headerlink" title="三、更多参考"></a>三、更多参考</h2><ul><li><a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener">ryf教程-generator</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、什么是Generator-函数&quot;&gt;&lt;a href=&quot;#一、什么是Generator-函数&quot; class=&quot;headerlink&quot; title=&quot;一、什么是Generator 函数&quot;&gt;&lt;/a&gt;一、什么是Generator 函数&lt;/h2&gt;&lt;h3 id=&quot;1-1-语
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="ES6" scheme="http://blog.poetries.top/tags/ES6/"/>
    
      <category term="Javascript" scheme="http://blog.poetries.top/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>ES6系列之Symbol</title>
    <link href="http://blog.poetries.top/2018/12/21/es6-symbol/"/>
    <id>http://blog.poetries.top/2018/12/21/es6-symbol/</id>
    <published>2018-12-21T07:00:21.000Z</published>
    <updated>2019-01-07T08:48:58.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><blockquote><p><code>ES6</code>新加入了一种原始数据类型<code>Symbol</code>，表示独一无二的值，这是<code>js</code>的第七种数据类型，前六种是：<code>Undefined</code>、<code>Null</code>、布尔值（<code>Boolean</code>）、字符串（<code>String</code>）、数值（<code>Number</code>）、对象（<code>Object</code>）</p></blockquote><ul><li>对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的<code>Symbol</code>类型。凡是属性名属于<code>Symbol</code>类型，就都是独一无二的，可以保证不会与其他属性名产生冲突</li></ul><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Symbol([description])</span><br></pre></td></tr></table></figure><blockquote><p>参数 <code>description</code> 是一个可选参数，是一个字符串，可以用于调试，但不能访问<code>Symbol</code> 自身</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">var</span> sym2 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">var</span> sym3 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br></pre></td></tr></table></figure><h3 id="1-2-值唯一性"><a href="#1-2-值唯一性" class="headerlink" title="1.2 值唯一性"></a>1.2 值唯一性</h3><blockquote><p>每一个 <code>Symbol()</code>返回的值都是唯一的。一个<code>Symbol</code> 值能作为对象属性的标识符，这是改数据类型仅有的目的</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>(<span class="string">"yuan"</span>) === <span class="built_in">Symbol</span>(<span class="string">"yuan"</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="1-3-不可以使用-new-操作符"><a href="#1-3-不可以使用-new-操作符" class="headerlink" title="1.3 不可以使用 new 操作符"></a>1.3 不可以使用 new 操作符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym = <span class="keyword">new</span> <span class="built_in">Symbol</span>(); <span class="comment">// TypeError报错</span></span><br></pre></td></tr></table></figure><h3 id="1-4-结合-Object-函数"><a href="#1-4-结合-Object-函数" class="headerlink" title="1.4 结合 Object() 函数"></a>1.4 结合 Object() 函数</h3><blockquote><p>结合 <code>Object()</code> 函数，创建一个 <code>Symbol</code> 包装器对象</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">typeof</span> sym;  <span class="comment">// "symbol“”</span></span><br><span class="line"><span class="keyword">var</span> symobj = <span class="built_in">Object</span>(sym);</span><br><span class="line"><span class="keyword">typeof</span> symobj; <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure><h3 id="1-5-全局共享-Symbol"><a href="#1-5-全局共享-Symbol" class="headerlink" title="1.5 全局共享 Symbol"></a>1.5 全局共享 Symbol</h3><blockquote><p>使用<code>Symbol.for()</code> 方法会根据给定的键 <code>key</code>，来从运行时的 <code>symbol</code> 注册表中找到对应的 <code>symbol</code>，如果找到了，则返回它，否则，新建一个与该键关联的 <code>symbol</code>，并放入全局 <code>symbol</code> 注册表中</p></blockquote><h3 id="1-6-在对象中查找-Symbol-属性"><a href="#1-6-在对象中查找-Symbol-属性" class="headerlink" title="1.6 在对象中查找 Symbol 属性"></a>1.6 在对象中查找 Symbol 属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>(<span class="string">"a"</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Symbol</span>.for(<span class="string">"b"</span>);</span><br><span class="line"></span><br><span class="line">obj[a] = <span class="string">"localSymbol"</span>;</span><br><span class="line">obj[b] = <span class="string">"globalSymbol"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(objectSymbols)         <span class="comment">// [Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></figure><h2 id="二、静态属性"><a href="#二、静态属性" class="headerlink" title="二、静态属性"></a>二、静态属性</h2><h3 id="2-1-length-属性"><a href="#2-1-length-属性" class="headerlink" title="2.1 length 属性"></a>2.1 length 属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Symbol 的长度属性值为0.</span></span><br><span class="line"><span class="built_in">Symbol</span>.length <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h3 id="2-2-迭代-Symbols"><a href="#2-2-迭代-Symbols" class="headerlink" title="2.2 迭代 Symbols"></a>2.2 迭代 Symbols</h3><blockquote><p><code>Symbol.iterator</code> 该方法为每一个对象定义了默认的迭代器。该迭代器可以被 <code>for.. of</code> 循环使用。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义迭代器</span></span><br><span class="line"><span class="keyword">var</span> myIterator = &#123;&#125;;</span><br><span class="line">myIterator[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line">[...myIterator] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><blockquote><p><code>Symbols</code> 与 <code>for... in</code> 迭代</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj[<span class="built_in">Symbol</span>(<span class="string">"a"</span>)] = <span class="string">"a"</span>;</span><br><span class="line">obj[<span class="built_in">Symbol</span>.for(<span class="string">"b"</span>)] = <span class="string">"b"</span>;</span><br><span class="line">obj[<span class="string">"c"</span>] = <span class="string">"c"</span>;</span><br><span class="line">obj.d = <span class="string">"d"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(i); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "c"</span></span><br><span class="line"><span class="comment">// "d"</span></span><br></pre></td></tr></table></figure><h3 id="2-3-Symbol的正则表达式"><a href="#2-3-Symbol的正则表达式" class="headerlink" title="2.3 Symbol的正则表达式"></a>2.3 Symbol的正则表达式</h3><blockquote><p>用于标识对象是否具有正则表达式的行为。<code>Symbol.match</code>:对象是否具有指定的匹配的正则表达式</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"/bar/"</span>.startsWith(<span class="regexp">/bar/</span>); </span><br><span class="line"><span class="comment">// Throws TypeError, 因为 /bar/ 是一个正则表达式</span></span><br><span class="line"><span class="comment">// 且 Symbol.match 没有修改。</span></span><br></pre></td></tr></table></figure><blockquote><p>如果你将 <code>Symbol.match</code> 置为 <code>false</code>，使用 <code>match</code> 属性的表达式检查会认为该象不是正则表达式对象。<code>startsWith</code> 和 <code>endsWith</code> 方法将不会抛出 <code>TypeError</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/foo/</span>;</span><br><span class="line">re[<span class="built_in">Symbol</span>.match] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="string">"/foo/"</span>.startsWith(re); <span class="comment">// true</span></span><br><span class="line"><span class="string">"/baz/"</span>.endsWith(re);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><strong>Symbol.replace</strong></p><blockquote><p>这个属性指定了当一个字符串替换所匹配字符串时所调用的方法。<code>String.prototype.replace()</code> 方法会调用此方法。</p></blockquote><p><strong>Symbol.search</strong></p><blockquote><p>指定了一个搜索方法，这个方法接受用户输入的正则表达式，返回该正则表达式在字符串中匹配到的下标，这个方法由以下的方法来调用 <code>String.prototype.search()</code></p></blockquote><p><strong>Symbol.split</strong></p><blockquote><p>指向 一个正则表达式的索引处分割字符串的方法。 这个方法通过<code>String.prototype.split()</code> 调用</p></blockquote><h3 id="2-4-其他属性"><a href="#2-4-其他属性" class="headerlink" title="2.4 其他属性"></a>2.4 其他属性</h3><p><strong>Symbol.hasInstance</strong></p><blockquote><p>一个确定一个构造器对象识别的对象是否为它的实例的方法</p></blockquote><p><strong>Symbol.toStringTag</strong></p><blockquote><p>用于对象的默认描述的字符串值。使用<code>Object.prototype.toString().</code></p></blockquote><h2 id="三、静态方法"><a href="#三、静态方法" class="headerlink" title="三、静态方法"></a>三、静态方法</h2><h3 id="3-1-Symbol-for-key"><a href="#3-1-Symbol-for-key" class="headerlink" title="3.1 Symbol.for(key)"></a>3.1 Symbol.for(key)</h3><blockquote><p>根据给定的键 <code>key</code>， 从运行时的 <code>symbol</code> 注册表中找到对应的 <code>symbol</code>，如果找到了，则返回它，否则，新建一个与该键关联的 <code>symbol</code>，并放入全局 <code>symbol</code> 注册表</p></blockquote><ul><li>这里的参数<code>key</code>，是一个字符串，作为 <code>symbol</code> 注册表中与某 <code>symbol</code> 关联的键</li><li>和 <code>Symbol()</code> 不同的是，用<code>Symbol.for()</code> 方法创建的 <code>symbol</code> 会被放入一个全局 symbol 注册表中</li><li><code>Symbol.for()</code> 并不是每次都会创建一个新的 symbol，它会首先检查给定的 <code>key</code> 是否已经在注册表中了，如果是，则会直接返回上次存储的那个。否则，会再新建一个</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>); <span class="comment">// 创建一个 symbol 并放入 symbol 注册表中，键为 "foo"</span></span><br><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>); <span class="comment">// 从 symbol 注册表中读取键为"foo"的 symbol</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>); <span class="comment">// true，证明了上面说的</span></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>(<span class="string">"bar"</span>); <span class="comment">// false，Symbol() 函数每次都会返回新的一个 symbol</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sym = <span class="built_in">Symbol</span>.for(<span class="string">"mario"</span>);</span><br><span class="line">sym.toString(); </span><br><span class="line"><span class="comment">// "Symbol(mario)"，mario 既是该 symbol 在 symbol 注册表中的键名，又是该 symbol 自身的描述字符串</span></span><br></pre></td></tr></table></figure><h3 id="3-2-Symbol-keyFor-sym"><a href="#3-2-Symbol-keyFor-sym" class="headerlink" title="3.2 Symbol.keyFor(sym)"></a>3.2 Symbol.keyFor(sym)</h3><ul><li>该方法用来获取 <code>symbol</code> 注册表中与某个 <code>symbol</code> 关联的键。</li><li>参数 <code>sym</code> 是指存储在 <code>symbol</code> 注册表中的某个 <code>symbol</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 symbol 并放入 Symbol 注册表，key 为 "foo"</span></span><br><span class="line"><span class="keyword">var</span> globalSym = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>); </span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(globalSym); <span class="comment">// "foo"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 symbol，但不放入 symbol 注册表中</span></span><br><span class="line"><span class="keyword">var</span> localSym = <span class="built_in">Symbol</span>(); </span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(localSym); <span class="comment">// undefined，所以是找不到 key 的</span></span><br></pre></td></tr></table></figure><h2 id="四、遍历"><a href="#四、遍历" class="headerlink" title="四、遍历"></a>四、遍历</h2><blockquote><p><code>Symbol</code>定义的属性不会出现在下面循环中</p></blockquote><ul><li><code>for in</code>:可获取原型属性，不可获取不可枚举属性</li><li><code>for of</code>:不可遍历对象，可遍历数组</li><li><code>Object.keys</code>：原型属性和不可枚举属性都不能获取</li><li><code>Object.getOwnPropertyByNames</code>：不可获取原型属性，可获取不可枚举属性</li><li><code>JSON.stringify</code>：原型属性和不可枚举属性都不能获取</li><li><code>Reflect.ownKeys</code>：可获取不可枚举和<code>Symbol</code>，不可获取原型</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;<span class="attr">w</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(p);</span><br><span class="line">obj.a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">"b"</span>,&#123;</span><br><span class="line">    value:<span class="number">123</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Symbol</span>(<span class="string">'b'</span>);</span><br><span class="line"></span><br><span class="line">obj[a] = <span class="string">'Hello'</span>;</span><br><span class="line">obj[b] = <span class="string">'World'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj);<span class="comment">// [Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></figure><blockquote><p>或者使用<code>Object.getOwnPropertySymbols(obj)</code>遍历</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;ES6&lt;/code&gt;新加入了一种原始数据类型&lt;code&gt;Symbol&lt;/code&gt;，表
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="ES6" scheme="http://blog.poetries.top/tags/ES6/"/>
    
      <category term="Javascript" scheme="http://blog.poetries.top/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>ES6系列之装饰器</title>
    <link href="http://blog.poetries.top/2018/12/21/es6-decorator/"/>
    <id>http://blog.poetries.top/2018/12/21/es6-decorator/</id>
    <published>2018-12-21T03:50:24.000Z</published>
    <updated>2019-01-07T08:48:58.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><blockquote><p>装饰器依赖于 <code>ES5</code> 的 <code>Object.defineProperty</code> 方法 </p></blockquote><h3 id="1-1-Object-defineProperty"><a href="#1-1-Object-defineProperty" class="headerlink" title="1.1 Object.defineProperty"></a>1.1 Object.defineProperty</h3><ul><li><code>Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象</li><li>该方法允许精确添加或修改对象的属性。通过赋值来添加的普通属性会创建在属性枚举期间显示的属性（<code>for...in</code> 或 <code>Object.keys</code> 方法）， 这些值可以被改变，也可以被删除。这种方法允许这些额外的细节从默认值改变。默认情况下，使用 <code>Object.defineProperty()</code> 添加的属性值是不可变的</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, prop, descriptor)</span><br></pre></td></tr></table></figure><ul><li><code>obj</code>：要在其上定义属性的对象。</li><li><code>prop</code>：要定义或修改的属性的名称。</li><li><code>descriptor</code>：将被定义或修改的属性描述符。</li><li>返回值：被传递给函数的对象。</li></ul><blockquote><p>在<code>ES6</code>中，由于 <code>Symbol</code>类型 的特殊性，用 <code>Symbol</code>类型 的值来做对象的<code>key</code>与常规的定义或修改不同，而<code>Object.defineProperty</code> 是定义 <code>key</code>为 <code>Symbol</code> 的属性的方法之一</p></blockquote><p><strong>descriptor属性描述符</strong></p><blockquote><p>对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符</p></blockquote><ul><li>数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。</li><li>存取描述符是由 <code>getter-setter</code> 函数对描述的属性。</li></ul><p><strong>configurable</strong></p><blockquote><p>当且仅当该属性的 <code>configurable</code> 为 <code>true</code> 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 <code>false</code></p></blockquote><p><strong>enumerable</strong></p><ul><li><code>enumerable</code>定义了对象的属性是否可以在 <code>for...in</code>循环和 <code>Object.keys()</code> 中被枚举。</li><li>当且仅当该属性的 <code>enumerable</code> 为 <code>true</code> 时，该属性才能够出现在对象的枚举属性中。默认为 <code>false</code>。</li></ul><h2 id="二、Babel"><a href="#二、Babel" class="headerlink" title="二、Babel"></a>二、Babel</h2><p><strong>安装编译</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @babel/core @babel/cli</span><br><span class="line"></span><br><span class="line">npm install --save-dev @babel/plugin-proposal-decorators @babel/plugin-proposal-class-properties</span><br></pre></td></tr></table></figure><blockquote><p>新建 <code>.babelrc</code> 文件</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    [<span class="string">"@babel/plugin-proposal-decorators"</span>, &#123; <span class="attr">"legacy"</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">    [<span class="string">"@babel/plugin-proposal-class-properties"</span>, &#123;<span class="attr">"loose"</span>: <span class="literal">true</span>&#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再编译指定的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">babel decorator.js --out-file decorator-compiled.js</span><br></pre></td></tr></table></figure><h2 id="三、用法"><a href="#三、用法" class="headerlink" title="三、用法"></a>三、用法</h2><p><strong>装饰器主要用于</strong></p><ul><li>装饰类</li><li>装饰方法或属性</li></ul><h3 id="3-1-类的装饰"><a href="#3-1-类的装饰" class="headerlink" title="3.1 类的装饰"></a>3.1 类的装饰</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@testable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  target.isTestable = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyTestableClass.isTestable <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>上面代码中，<code>@testable</code> 就是一个装饰器。它修改了 <code>MyTestableClass</code>这 个类的行为，为它加上了静态属性<code>isTestable</code>。<code>testable</code> 函数的参数 <code>target</code> 是 <code>MyTestableClass</code> 类本身</p></blockquote><p>基本上，装饰器的行为就是下面这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@decorator</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line">A = decorator(A) || A;</span><br></pre></td></tr></table></figure><blockquote><p>也就是说，装饰器是一个对类进行处理的函数。装饰器函数的第一个参数，就是所要装饰的目标类</p></blockquote><p>如果觉得一个参数不够用，可以在装饰器外面再封装一层函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">isTestable</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    target.isTestable = isTestable;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable(<span class="literal">true</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;&#125;</span><br><span class="line">MyTestableClass.isTestable <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">@testable(<span class="literal">false</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line">MyClass.isTestable <span class="comment">// false</span></span><br></pre></td></tr></table></figure><blockquote><p>上面代码中，装饰器 <code>testable</code> 可以接受参数，这就等于可以修改装饰器的行为</p></blockquote><p><strong>注意</strong>，装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，装饰器能在编译阶段运行代码。也就是说，装饰器本质就是编译时执行的函数。</p><blockquote><p>前面的例子是为类添加一个静态属性，如果想添加实例属性，可以通过目标类的 <code>prototype</code> 对象操作</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mixins.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mixins</span>(<span class="params">...list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(target.prototype, ...list)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; mixins &#125; <span class="keyword">from</span> <span class="string">'./mixins'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  foo() &#123; <span class="built_in">console</span>.log(<span class="string">'foo'</span>) &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@mixins(Foo)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo() <span class="comment">// 'foo'</span></span><br></pre></td></tr></table></figure><blockquote><p>上面代码通过装饰器 <code>mixins</code>，把<code>Foo</code>对象的方法添加到了 <code>MyClass</code>的实例上面</p></blockquote><h3 id="3-2-方法的装饰"><a href="#3-2-方法的装饰" class="headerlink" title="3.2 方法的装饰"></a>3.2 方法的装饰</h3><blockquote><p>装饰器不仅可以装饰类，还可以装饰类的属性</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="comment">// 装饰器 readonly 用来装饰“类”的name方法。</span></span><br><span class="line">  @readonly</span><br><span class="line">  name() &#123; <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.first&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.last&#125;</span>`</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>装饰器函数 <code>readonly</code> 一共可以接受三个参数。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">target, name, descriptor</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// descriptor对象原来的值如下</span></span><br><span class="line">  <span class="comment">// &#123;</span></span><br><span class="line">  <span class="comment">//   value: specifiedFunction,</span></span><br><span class="line">  <span class="comment">//   enumerable: false,</span></span><br><span class="line">  <span class="comment">//   configurable: true,</span></span><br><span class="line">  <span class="comment">//   writable: true</span></span><br><span class="line">  <span class="comment">// &#125;;</span></span><br><span class="line">  descriptor.writable = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readonly(Person.prototype, <span class="string">'name'</span>, descriptor);</span><br><span class="line"><span class="comment">// 类似于</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">'name'</span>, descriptor);</span><br></pre></td></tr></table></figure><ul><li>第一个参数是类的原型对象，上例是 <code>Person.prototype</code>，装饰器的本意是要“装饰”类的实例，但是这个时候实例还没生成，所以只能去装饰原型（这不同于类的装饰，那种情况时<code>target</code>参数指的是类本身）</li><li>第二个参数是 所要装饰的属性名</li><li>第三个参数是 该属性的描述对象</li></ul><h3 id="3-3-函数方法的装饰"><a href="#3-3-函数方法的装饰" class="headerlink" title="3.3 函数方法的装饰"></a>3.3 函数方法的装饰</h3><ul><li>装饰器只能用于类和类的方法，不能用于函数，因为存在函数提升</li><li>另一方面，如果一定要装饰函数，可以采用高阶函数的形式直接执行</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello, '</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingDecorator</span>(<span class="params">wrapped</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Starting'</span>);</span><br><span class="line">    <span class="keyword">const</span> result = wrapped.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Finished'</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapped = loggingDecorator(doSomething);</span><br></pre></td></tr></table></figure><h2 id="四、使用场景"><a href="#四、使用场景" class="headerlink" title="四、使用场景"></a>四、使用场景</h2><h3 id="4-1-装饰器有注释的作用"><a href="#4-1-装饰器有注释的作用" class="headerlink" title="4.1 装饰器有注释的作用"></a>4.1 装饰器有注释的作用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@testable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @readonly</span><br><span class="line">  @nonenumerable</span><br><span class="line">  name() &#123; <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.first&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.last&#125;</span>`</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从上面代码中，我们一眼就能看出，<code>Person</code>类是可测试的，而<code>name</code>方法是只读和不可枚举的</p></blockquote><h3 id="4-2-React-的-connect"><a href="#4-2-React-的-connect" class="headerlink" title="4.2 React 的 connect"></a>4.2 React 的 connect</h3><blockquote><p>实际开发中，React 与 Redux 库结合使用时，常常需要写成下面这样</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReactComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);</span><br></pre></td></tr></table></figure><blockquote><p>有了装饰器，就可以改写上面的代码。装饰</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@connect(mapStateToProps, mapDispatchToProps)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReactComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-loading"><a href="#4-3-loading" class="headerlink" title="4.3 loading"></a>4.3 loading</h3><blockquote><p>在 <code>React</code> 项目中，我们可能需要在向后台请求数据时，页面出现 <code>loading</code> 动画。这个时候，你就可以使用装饰器，优雅地实现功能。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@autobind</span><br><span class="line">@loadingWrap(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">async</span> handleSelect(params) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">this</span>.props.dispatch(&#123;</span><br><span class="line">    type: <span class="string">'product_list/setQuerypParams'</span>,</span><br><span class="line">    querypParams: params</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>loadingWrap 函数如下：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">loadingWrap</span>(<span class="params">needHide</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> defaultLoading = (</span><br><span class="line">    &lt;div className=<span class="string">"toast-loading"</span>&gt;</span><br><span class="line">      &lt;Loading className=<span class="string">"loading-icon"</span>/&gt;</span><br><span class="line">      &lt;div&gt;加载中...&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, property, descriptor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> raw = descriptor.value;</span><br><span class="line">    </span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      Toast.info(text || defaultLoading, <span class="number">0</span>, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">const</span> res = raw.apply(<span class="keyword">this</span>, args);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (needHide) &#123;</span><br><span class="line">        <span class="keyword">if</span> (get(<span class="string">'finally'</span>)(res)) &#123;</span><br><span class="line">          res.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            Toast.hide();</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Toast.hide();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-log"><a href="#4-4-log" class="headerlink" title="4.4 log"></a>4.4 log</h3><blockquote><p>为一个方法添加 log 函数，检查输入的参数：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">  @log</span><br><span class="line">  add(a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> log = <span class="function">(<span class="params">type</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">target, name, descriptor</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> method = descriptor.value;</span><br><span class="line">    descriptor.value =  <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.info(<span class="string">`(<span class="subst">$&#123;type&#125;</span>) 正在执行: <span class="subst">$&#123;name&#125;</span>(<span class="subst">$&#123;args&#125;</span>) = ?`</span>);</span><br><span class="line">      <span class="keyword">let</span> ret;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ret = method.apply(target, args);</span><br><span class="line">        <span class="built_in">console</span>.info(<span class="string">`(<span class="subst">$&#123;type&#125;</span>) 成功 : <span class="subst">$&#123;name&#125;</span>(<span class="subst">$&#123;args&#125;</span>) =&gt; <span class="subst">$&#123;ret&#125;</span>`</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">`(<span class="subst">$&#123;type&#125;</span>) 失败: <span class="subst">$&#123;name&#125;</span>(<span class="subst">$&#123;args&#125;</span>) =&gt; <span class="subst">$&#123;error&#125;</span>`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> math = <span class="keyword">new</span> <span class="built_in">Math</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Calling add with [2, 4]</span></span><br><span class="line">math.add(<span class="number">2</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><h3 id="4-5-autobind"><a href="#4-5-autobind" class="headerlink" title="4.5 autobind"></a>4.5 autobind</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @autobind</span><br><span class="line">  getPerson() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> &#123; getPerson &#125; = person;</span><br><span class="line"></span><br><span class="line">getPerson() === person;</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>我们很容易想到的一个场景是 React 绑定事件的时候</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toggle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  @autobind</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        button</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>我们来写这样一个 <code>autobind</code>函数：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; defineProperty, getPrototypeOf&#125; = <span class="built_in">Object</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fn.bind) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn.bind(context);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">__autobind__</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(context, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createDefaultSetter</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, key, &#123;</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      writable: <span class="literal">true</span>,</span><br><span class="line">      enumerable: <span class="literal">true</span>,</span><br><span class="line">      value: newValue</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newValue;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">autobind</span>(<span class="params">target, key, &#123; value: fn, configurable, enumerable &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">SyntaxError</span>(<span class="string">`@autobind can only be used on functions, not: <span class="subst">$&#123;fn&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="keyword">constructor</span> &#125; = target;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    configurable,</span><br><span class="line">    enumerable,</span><br><span class="line"></span><br><span class="line">    get() &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 使用这种方式相当于替换了这个函数，所以当比如</span></span><br><span class="line"><span class="comment">       * Class.prototype.hasOwnProperty(key) 的时候，为了正确返回</span></span><br><span class="line"><span class="comment">       * 所以这里做了 this 的判断</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span> === target) &#123;</span><br><span class="line">        <span class="keyword">return</span> fn;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> boundFn = bind(fn, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">      defineProperty(<span class="keyword">this</span>, key, &#123;</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        value: boundFn</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> boundFn;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: createDefaultSetter(key)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-debounce"><a href="#4-6-debounce" class="headerlink" title="4.6 debounce"></a>4.6 debounce</h3><blockquote><p>有的时候，我们需要对执行的方法进行防抖处理:</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toggle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  @debounce(<span class="number">500</span>, <span class="literal">true</span>)</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'toggle'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        button</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout) clearTimeout(timeout);</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            <span class="keyword">if</span> (callNow) func.apply(context, args)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">wait, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">handleDescriptor</span>(<span class="params">target, key, descriptor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> callback = descriptor.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">SyntaxError</span>(<span class="string">'Only functions can be debounced'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fn = _debounce(callback, wait, immediate)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...descriptor,</span><br><span class="line">      value() &#123;</span><br><span class="line">        fn()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-7-time"><a href="#4-7-time" class="headerlink" title="4.7 time"></a>4.7 time</h3><blockquote><p>用于统计方法执行的时间:</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">time</span>(<span class="params">prefix</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">handleDescriptor</span>(<span class="params">target, key, descriptor</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fn = descriptor.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prefix == <span class="literal">null</span>) &#123;</span><br><span class="line">      prefix = <span class="string">`<span class="subst">$&#123;target.constructor.name&#125;</span>.<span class="subst">$&#123;key&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">SyntaxError</span>(<span class="string">`@time can only be used on functions, not: <span class="subst">$&#123;fn&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...descriptor,</span><br><span class="line">      value() &#123;</span><br><span class="line">        <span class="keyword">const</span> label = <span class="string">`<span class="subst">$&#123;prefix&#125;</span>-<span class="subst">$&#123;count&#125;</span>`</span>;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="built_in">console</span>.time(label);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.timeEnd(label);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-8-mixin"><a href="#4-8-mixin" class="headerlink" title="4.8 mixin"></a>4.8 mixin</h3><blockquote><p>用于将对象的方法混入<code>Class</code> 中</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SingerMixin = &#123;</span><br><span class="line">  sing(sound) &#123;</span><br><span class="line">    alert(sound);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FlyMixin = &#123;</span><br><span class="line">  <span class="comment">// All types of property descriptors are supported</span></span><br><span class="line">  get speed() &#123;&#125;,</span><br><span class="line">  fly() &#123;&#125;,</span><br><span class="line">  land() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@mixin(SingerMixin, FlyMixin)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">  singMatingCall() &#123;</span><br><span class="line">    <span class="keyword">this</span>.sing(<span class="string">'tweet tweet'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bird = <span class="keyword">new</span> Bird();</span><br><span class="line">bird.singMatingCall();</span><br><span class="line"><span class="comment">// alerts "tweet tweet"</span></span><br></pre></td></tr></table></figure><blockquote><p><code>mixin</code> 的一个简单实现如下</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params">...mixins</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">target</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mixins.length) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">SyntaxError</span>(<span class="string">`@mixin() class <span class="subst">$&#123;target.name&#125;</span> requires at least one mixin as an argument`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = mixins.length; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> descs = <span class="built_in">Object</span>.getOwnPropertyDescriptors(mixins[i]);</span><br><span class="line">      <span class="keyword">const</span> keys = <span class="built_in">Object</span>.getOwnPropertyNames(descs);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>, k = keys.length; j &lt; k; j++) &#123;</span><br><span class="line">        <span class="keyword">const</span> key = keys[j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!target.prototype.hasOwnProperty(key)) &#123;</span><br><span class="line">          <span class="built_in">Object</span>.defineProperty(target.prototype, key, descs[key]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;装饰器依赖于 &lt;code&gt;ES5&lt;/code&gt; 的 &lt;code&gt;Object.defineProp
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="ES6" scheme="http://blog.poetries.top/tags/ES6/"/>
    
      <category term="Javascript" scheme="http://blog.poetries.top/tags/Javascript/"/>
    
  </entry>
  
</feed>
